{"chunk_id": "best_practices.rst_sem_0", "source": "best_practices.rst", "text": "The Symfony Framework Best Practices This article describes the **best practices for developing web applications with\nSymfony** that fit the philosophy envisioned by the original Symfony creators. If you don't agree with some of these recommendations, they might be a good\n**starting point** that you can then **extend and fit to your specific needs**.\nYou can even ignore them completely and continue using your own best practices\nand methodologies. Symfony is flexible enough to adapt to your needs. This article assumes that you already have experience developing Symfony\napplications. If you don't, first read the Getting Started\nsection of the documentation. Symfony provides a sample application called `Symfony Demo`_ that follows\nall these best practices, so you can experience them in practice. Creating the Project Use the Symfony Binary to Create Symfony Applications The Symfony binary is an executable command created in your machine when you\n`download Symfony`_. It provides multiple utilities, including the simplest way\nto create new Symfony applications: $ symfony new my_project_directory Under the hood, this Symfony binary command executes the needed `Composer`_\ncommand to create a new Symfony application\nbased on the current stable version. Use the Default Directory Structure Unless your project follows a development practice that imposes a certain\ndirectory structure, follow the default Symfony directory structure. It's flat,\nself-explanatory and not coupled to Symfony: your_project/\n├─ assets/\n├─ bin/\n│ └─ console\n├─ config/\n│ ├─ packages/\n│ ├─ routes/\n│ └─ services.yaml\n├─ migrations/\n├─ public/\n│ ├─ build/\n│ └─ index.php\n├─ src/\n│ ├─ Kernel.php\n│ ├─ Command/\n│ ├─ Controller/\n│ ├─ DataFixtures/\n│ ├─ Entity/\n│ ├─ EventSubscriber/\n│ ├─ Form/\n│ ├─ Repository/\n│ ├─ Security/\n│ └─ Twig/\n├─ templates/\n├─ tests/\n├─ translations/\n├─ var/\n│ ├─ cache/\n│ └─ log/\n└─ vendor/ Configuration Use Environment Variables for Infrastructure Configuration The values of these options change from one machine to another (e.g. from your\ndevelopment machine to the production server), but they don't modify the\napplication behavior. Use env vars in your project to define these options\nand create multiple .env files to configure env vars per environment . Use Secrets for Sensitive Information When your application has sensitive configuration, like an API key, you should\nstore those securely via Symfony's secrets management system . Use Parameters for Application Configuration These are the options used to modify the application behavior, such as the sender\nof email notifications, or the enabled `feature toggles`_. Their value doesn't\nchange per machine, so don't define them as environment variables. Define these options as parameters in the\nconfig/services.yaml file. You can override these options per\nenvironment in the config/services_dev.yaml\nand config/services_prod.yaml files. Unless the application configuration is reused multiple times and needs\nrigid validation, do *not* use the Config component\nto define the options. Use Short and Prefixed Parameter Names", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "best_practices.rst_sem_1", "source": "best_practices.rst", "text": "Consider using app. as the prefix of your parameters\nto avoid collisions with Symfony and third-party bundles/libraries parameters.\nThen, use only one or two words to describe the purpose of the parameter: # config/services.yaml\nparameters:\n# don't do this: 'dir' is too generic, and it doesn't convey any meaning\napp.dir: '...'\n# do this: short but easy to understand names\napp.contents_dir: '...'\n# it's OK to use dots, underscores, dashes or nothing, but always\n# be consistent and use the same format for all the parameters\napp.dir.contents: '...'\napp.contents-dir: '...' Use Constants to Define Options that Rarely Change Configuration options like the number of items to display in some listing rarely\nchange. Instead of defining them as configuration parameters ,\ndefine them as PHP constants in the related classes. Example:: // src/Entity/Post.php\nnamespace App\\Entity; class Post\n{\npublic const NUMBER_OF_ITEMS = 10; // ...\n} The main advantage of constants is that you can use them everywhere, including\nTwig templates and Doctrine entities, whereas parameters are only available\nfrom places with access to the service container . The only notable disadvantage of using constants for this kind of configuration\nvalues is that it's complicated to redefine their values in your tests. Business Logic Don't Create any Bundle to Organize your Application Logic When Symfony 2.0 was released, applications used bundles to\ndivide their code into logical features: UserBundle, ProductBundle,\nInvoiceBundle, etc. However, a bundle is meant to be something that can be\nreused as a stand-alone piece of software. If you need to reuse some feature in your projects, create a bundle for it (in a\nprivate repository, do not make it publicly available). For the rest of your\napplication code, use PHP namespaces to organize code instead of bundles. Use Autowiring to Automate the Configuration of Application Services Service autowiring is a feature that\nreads the type-hints on your constructor (or other methods) and automatically\npasses the correct services to each method, making it unnecessary to configure\nservices explicitly and simplifying the application maintenance. Use it in combination with service autoconfiguration\nto also add service tags to the services\nneeding them, such as Twig extensions, event subscribers, etc. Services Should be Private Whenever Possible Make services private to prevent you from accessing\nthose services via $container->get(). Instead, you will need to use proper\ndependency injection. Use the YAML Format to Configure your own Services If you use the default services.yaml configuration ,\nmost services will be configured automatically. However, in some edge cases\nyou'll need to configure services (or parts of them) manually. YAML is the format recommended configuring services because it's friendly to\nnewcomers and concise, but Symfony also supports XML and PHP configuration. Use Attributes to Define the Doctrine Entity Mapping Doctrine entities are plain PHP objects that you store in some \"database\".\nDoctrine only knows about your entities through the mapping metadata configured\nfor your model classes.", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "best_practices.rst_sem_2", "source": "best_practices.rst", "text": "Doctrine supports several metadata formats, but it's recommended to use PHP\nattributes because they are by far the most convenient and agile way of setting\nup and looking for mapping information. Controllers Make your Controller Extend the AbstractController Base Controller Symfony provides a base controller\nwhich includes shortcuts for the most common needs such as rendering templates\nor checking security permissions. Extending your controllers from this base controller couples your application\nto Symfony. Coupling is generally wrong, but it may be OK in this case because\ncontrollers shouldn't contain any business logic. Controllers should contain\nnothing more than a few lines of *glue-code*, so you are not coupling the\nimportant parts of your application. Use Attributes to Configure Routing, Caching, and Security Using attributes for routing, caching, and security simplifies\nconfiguration. You don't need to browse several files created with different\nformats (YAML, XML, PHP): all the configuration is just where you require it,\nand it only uses one format. Use Dependency Injection to Get Services If you extend the base AbstractController, you can only get access to the most\ncommon services (e.g twig, router, doctrine, etc.), directly from the\ncontainer via $this->container->get().\nInstead, you must use dependency injection to fetch services by\ntype-hinting action method arguments or\nconstructor arguments. Use Entity Value Resolvers If They Are Convenient If you're using Doctrine , then you can *optionally* use\nthe EntityValueResolver to\nautomatically query for an entity and pass it as an argument to your\ncontroller. It will also show a 404 page if no entity can be found. If the logic to get an entity from a route variable is more complex, instead of\nconfiguring the EntityValueResolver, it's better to make the Doctrine query\ninside the controller (e.g. by calling to a Doctrine repository method ). Templates Use Snake Case for Template Names and Variables Use lowercase snake_case for template names, directories, and variables (e.g.\nuser_profile instead of userProfile and product/edit_form.html.twig\ninstead of Product/EditForm.html.twig). Prefix Template Fragments with an Underscore Template fragments, also called *\"partial templates\"*, allow to\nreuse template contents . Prefix their names\nwith an underscore to better differentiate them from complete templates (e.g.\n_user_metadata.html.twig or _caution_message.html.twig). Forms Define your Forms as PHP Classes Creating forms in classes allows reusing\nthem in different parts of the application. Besides, not creating forms in\ncontrollers simplifies the code and maintenance of the controllers. Add Form Buttons in Templates Form classes should be agnostic to where they will be used. For example, the\nbutton of a form used to both create and edit items should change from \"Add new\"\nto \"Save changes\" depending on where it's used. Instead of adding buttons in form classes or the controllers, it's recommended\nto add buttons in the templates. This also improves the separation of concerns\nbecause the button styling (CSS class and other attributes) is defined in the\ntemplate instead of in a PHP class.", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "best_practices.rst_sem_3", "source": "best_practices.rst", "text": "However, if you create a form with multiple submit buttons\nyou should define them in the controller instead of the template. Otherwise, you\nwon't be able to check which button was clicked when handling the form in the controller. Define Validation Constraints on the Underlying Object Attaching validation constraints to form fields\ninstead of to the mapped object prevents the validation from being reused in\nother forms or other places where the object is used. Use a Single Action to Render and Process the Form Rendering forms and processing forms\nare two of the main tasks when handling forms. Both are too similar (most of the\ntime, almost identical), so it's much simpler to let a single controller action\nhandle both. Internationalization Use the XLIFF Format for Your Translation Files Of all the translation formats supported by Symfony (PHP, Qt, .po, .mo,\nJSON, CSV, INI, etc.), XLIFF and gettext have the best support in the tools used\nby professional translators. And since it's based on XML, you can validate XLIFF\nfile contents as you write them. Symfony also supports notes in XLIFF files, making them more user-friendly for\ntranslators. At the end, good translations are all about context, and these\nXLIFF notes allow you to define that context. Use Keys for Translations Instead of Content Strings Using keys simplifies the management of the translation files because you can\nchange the original contents in templates, controllers, and services without\nhaving to update all the translation files. Keys should always describe their *purpose* and *not* their location. For\nexample, if a form has a field with the label \"Username\", then a nice key\nwould be label.username, *not* edit_form.label.username. Security Define a Single Firewall Unless you have two legitimately different authentication systems and users\n(e.g. form login for the main site and a token system for your API only), it's\nrecommended to have only one firewall to keep things simple. Use the auto Password Hasher The auto password hasher automatically\nselects the best possible encoder/hasher depending on your PHP installation.\nCurrently, the default auto hasher is bcrypt. Use Voters to Implement Fine-grained Security Restrictions If your security logic is complex, you should create custom\nsecurity voters instead of defining long expressions\ninside the #[Security] attribute. Web Assets Use AssetMapper to Manage Web Assets Web assets are the CSS, JavaScript, and image files that make the frontend of\nyour site look and work great. AssetMapper lets\nyou write modern JavaScript and CSS without the complexity of using a bundler\nsuch as `Webpack`_ (directly or via Webpack Encore ). Tests Smoke Test your URLs In software engineering, `smoke testing`_ consists of *\"preliminary testing to\nreveal simple failures severe enough to reject a prospective software release\"*.\nUsing `PHPUnit data providers`_ you can define a functional test that\nchecks that all application URLs load successfully:: // tests/ApplicationAvailabilityFunctionalTest.php\nnamespace App\\Tests; use PHPUnit\\Framework\\Attributes\\DataProvider;\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase; class ApplicationAvailabilityFunctionalTest extends WebTestCase\n{\n#[DataProvider('urlProvider')]\npublic function testPageIsSuccessful($url): void\n{\n$client = self::createClient();\n$client->request('GET', $url); $this->assertResponseIsSuccessful();\n}", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "best_practices.rst_sem_4", "source": "best_practices.rst", "text": "public static function urlProvider(): \\Generator\n{\nyield ['/'];\nyield ['/posts'];\nyield ['/post/fixture-post-1'];\nyield ['/blog/category/fixture-category'];\nyield ['/archives'];\n// ...\n}\n} Add this test while creating your application because it requires little effort\nand checks that none of your pages returns an error. Later, you'll add more\nspecific tests for each page. Hard-code URLs in a Functional Test In Symfony applications, it's recommended to generate URLs\nusing routes to automatically update all links when a URL changes. However, if a\npublic URL changes, users won't be able to browse it unless you set up a\nredirection to the new URL. That's why it's recommended to use raw URLs in tests instead of generating them\nfrom routes. Whenever a route changes, tests will fail, and you'll know that\nyou must set up a redirection.", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "bundles.rst_sem_0", "source": "bundles.rst", "text": "The Bundle System In Symfony versions prior to 4.0, it was recommended to organize your own\napplication code using bundles. This is no longer recommended and bundles\nshould only be used to share code and features between multiple applications. Do you prefer video tutorials? Check out the `Symfony Bundle Development screencast series`_. A bundle is similar to a plugin in other software, but even better. The core\nfeatures of Symfony framework are implemented with bundles (FrameworkBundle,\nSecurityBundle, DebugBundle, etc.) Bundles are also used to add new features in\nyour application via `third-party bundles`_. Bundles used in your applications must be enabled per\nenvironment in the config/bundles.php\nfile:: // config/bundles.php\nreturn [\n// 'all' means that the bundle is enabled for any Symfony environment\nSymfony\\Bundle\\FrameworkBundle\\FrameworkBundle::class => ['all' => true],\n// ... // this bundle is enabled only in 'dev'\nSymfony\\Bundle\\DebugBundle\\DebugBundle::class => ['dev' => true],\n// ... // this bundle is enabled only in 'dev' and 'test', so you can't use it in 'prod'\nSymfony\\Bundle\\WebProfilerBundle\\WebProfilerBundle::class => ['dev' => true, 'test' => true],\n// ...\n]; In a default Symfony application that uses Symfony Flex ,\nbundles are enabled/disabled automatically for you when installing/removing\nthem, so you don't need to look at or edit this bundles.php file. Creating a Bundle This section creates and enables a new bundle to show that only a few steps are required.\nThe new bundle is called AcmeBlogBundle, where the Acme portion is an example\nname that should be replaced by some \"vendor\" name that represents you or your\norganization (e.g. AbcBlogBundle for some company named Abc). Start by creating a new class called AcmeBlogBundle:: // src/AcmeBlogBundle.php\nnamespace Acme\\BlogBundle; use Symfony\\Component\\HttpKernel\\Bundle\\AbstractBundle; class AcmeBlogBundle extends AbstractBundle\n{\n} If your bundle must be compatible with previous Symfony versions you have to\nextend from the Symfony\\\\Component\\\\HttpKernel\\\\Bundle\\\\Bundle instead. The name AcmeBlogBundle follows the standard\nBundle naming conventions . You could\nalso choose to shorten the name of the bundle to simply BlogBundle by naming\nthis class BlogBundle (and naming the file BlogBundle.php). This empty class is the only piece you need to create the new bundle. Though\ncommonly empty, this class is powerful and can be used to customize the behavior\nof the bundle. Now that you've created the bundle, enable it:: // config/bundles.php\nreturn [\n// ...\nAcme\\BlogBundle\\AcmeBlogBundle::class => ['all' => true],\n]; And while it doesn't do anything yet, AcmeBlogBundle is now ready to be used. Bundle Directory Structure The directory structure of a bundle is meant to help to keep code consistent\nbetween all Symfony bundles. It follows a set of conventions, but is flexible\nto be adjusted if needed: assets/\nContains the web asset sources like JavaScript and TypeScript files, CSS and\nSass files, but also images and other assets related to the bundle that are\nnot in public/ (e.g. Stimulus controllers). config/\nHouses configuration, including routing configuration (e.g. routes.php). public/\nContains web assets (images, compiled CSS and JavaScript files, etc.) and is\ncopied or symbolically linked into the project public/ directory via the\nassets:install console command.", "title": "The Bundle System", "category": "bundles"}
{"chunk_id": "bundles.rst_sem_1", "source": "bundles.rst", "text": "src/\nContains all PHP classes related to the bundle logic (e.g. Controller/CategoryController.php). templates/\nHolds templates organized by controller name (e.g. category/show.html.twig). tests/\nHolds all tests for the bundle. translations/\nHolds translations organized by domain and locale (e.g. AcmeBlogBundle.en.xlf). The recommended bundle structure was changed in Symfony 5, read the\n`Symfony 4.4 bundle documentation`_ for information about the old\nstructure. When using the new AbstractBundle class, the bundle defaults to the\nnew structure. Override the Bundle::getPath() method to change to\nthe old structure:: class AcmeBlogBundle extends AbstractBundle\n{\npublic function getPath(): string\n{\nreturn __DIR__;\n}\n} It's recommended to use the `PSR-4`_ autoload standard on your bundle's\ncomposer.json file. Use the namespace as key, and the location of the\nbundle's main class (relative to composer.json) as value. As the main\nclass is located in the src/ directory of the bundle: {\n\"autoload\": {\n\"psr-4\": {\n\"Acme\\\\BlogBundle\\\\\": \"src/\"\n}\n},\n\"autoload-dev\": {\n\"psr-4\": {\n\"Acme\\\\BlogBundle\\\\Tests\\\\\": \"tests/\"\n}\n}\n} Developing a Reusable Bundle Bundles are meant to be reusable pieces of code that live independently from\nany particular Symfony application. However, a bundle cannot run on its own: it\nmust be registered inside an application to execute its code. This can be a bit challenging during development. When working on a bundle in\nits own repository, there's no Symfony application around it, so you need a way\nto test your changes inside a real application environment. There are two common approaches to do this, depending on whether your bundle has\nalready been published or is still under development. Using a Local Path Repository If your bundle hasn't been published yet (for example, it's not available on\nPackagist), you can point Composer to your local bundle directory from any\nSymfony application you use for testing. Edit the composer.json file of your application and add this: {\n\"repositories\": [\n{\n\"type\": \"path\",\n\"url\": \"/path/to/your/AcmeBlogBundle\"\n}\n],\n\"require\": {\n\"acme/blog-bundle\": \"*\"\n}\n} Then, in your application, install the bundle as usual: $ composer require acme/blog-bundle Composer will create a symbolic link (symlink) to your local bundle directory,\nso any change you make in the AcmeBlogBundle/ directory is immediately\nvisible in the application. You can now enable the bundle in config/bundles.php:: return [\n// ...\nAcme\\BlogBundle\\AcmeBlogBundle::class => ['all' => true],\n]; This setup is ideal during early development because it allows quick iteration\nwithout publishing or rebuilding archives. Linking an Already Published Bundle If your bundle is already public (for example, it's published on Packagist),\nyou can still develop it locally while testing it inside a Symfony application. In your application, replace the installed bundle with a symlink to your local\ndevelopment copy. For example, if your bundle is installed under\nvendor/acme/blog-bundle/ and your local copy is in ~/Projects/AcmeBlogBundle/: $ rm -rf vendor/acme/blog-bundle/\n$ ln -s ~/Projects/AcmeBlogBundle/ vendor/acme/blog-bundle", "title": "The Bundle System", "category": "bundles"}
{"chunk_id": "bundles.rst_sem_2", "source": "bundles.rst", "text": "Symfony will now use your local bundle directly. You can edit its code, run\ntests, and see the changes immediately. When you're done, restore the vendor\nfolder or reinstall the package with Composer to go back to the published version. Learn more * /bundles/override\n* /bundles/best_practices\n* /bundles/configuration\n* /bundles/extension\n* /bundles/prepend_extension", "title": "The Bundle System", "category": "bundles"}
{"chunk_id": "cache.rst_sem_0", "source": "cache.rst", "text": "Cache Using a cache is a great way of making your application run quicker. The Symfony cache\ncomponent ships with many adapters to different storages. Every adapter is\ndeveloped for high performance. The following example shows a typical usage of the cache:: use Symfony\\Contracts\\Cache\\ItemInterface; // The callable will only be executed on a cache miss.\n$value = $pool->get('my_cache_key', function (ItemInterface $item): string {\n$item->expiresAfter(3600); // ... do some HTTP request or heavy computations\n$computedValue = 'foobar'; return $computedValue;\n}); echo $value; // 'foobar' // ... and to remove the cache key\n$pool->delete('my_cache_key'); Symfony supports Cache Contracts and PSR-6/16 interfaces.\nYou can read more about these at the component documentation . Configuring Cache with FrameworkBundle When configuring the cache component there are a few concepts you should know: **Pool**\nThis is a service that you will interact with. Each pool will always have\nits own namespace and cache items. There are never conflicts between pools.\n**Adapter**\nAn adapter is a *template* that you use to create pools.\n**Provider**\nA provider is a service that some adapters use to connect to the storage.\nRedis and Memcached are examples of such adapters. If a DSN is used as the\nprovider then a service is automatically created. There are two pools that are always enabled by default. They are cache.app and\ncache.system. The system cache is used for things like annotations, serializer,\nand validation. The cache.app can be used in your code. You can configure which\nadapter (template) they use by using the app and system key like: # config/packages/cache.yaml\nframework:\ncache:\napp: cache.adapter.filesystem\nsystem: cache.adapter.system <!-- config/packages/cache.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n>\n<framework:config>\n<framework:cache\napp=\"cache.adapter.filesystem\"\nsystem=\"cache.adapter.system\"\n/>\n</framework:config>\n</container> // config/packages/cache.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->cache()\n->app('cache.adapter.filesystem')\n->system('cache.adapter.system')\n;\n}; While it is possible to reconfigure the system cache, it's recommended\nto keep the default configuration applied to it by Symfony. The Cache component comes with a series of adapters pre-configured: * cache.adapter.apcu\n* cache.adapter.array\n* cache.adapter.doctrine_dbal\n* cache.adapter.filesystem\n* cache.adapter.memcached\n* cache.adapter.pdo\n* cache.adapter.psr6\n* cache.adapter.redis\n* cache.adapter.redis_tag_aware (Redis adapter optimized to work with tags) There's also a special cache.adapter.system adapter. It's recommended to\nuse it for the system cache . This adapter uses some\nlogic to dynamically select the best possible storage based on your system\n(either PHP files or APCu). Some of these adapters could be configured via shortcuts. # config/packages/cache.yaml\nframework:\ncache:\ndirectory: '%kernel.cache_dir%/pools' # Only used with cache.adapter.filesystem default_doctrine_dbal_provider: 'doctrine.dbal.default_connection'\ndefault_psr6_provider: 'app.my_psr6_service'\ndefault_redis_provider: 'redis://localhost'\ndefault_memcached_provider: 'memcached://localhost'\ndefault_pdo_provider: 'pgsql:host=localhost' <!-- config/packages/cache.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n>\n<framework:config>\n<!-- \"directory\" attribute is only used with cache.adapter.filesystem -->\n<framework:cache directory=\"%kernel.cache_dir%/pools\"\ndefault-doctrine-dbal-provider=\"doctrine.dbal.default_connection\"\ndefault-psr6-provider=\"app.my_psr6_service\"\ndefault-redis-provider=\"redis://localhost\"\ndefault-memcached-provider=\"memcached://localhost\"\ndefault-pdo-provider=\"pgsql:host=localhost\"\n/>\n</framework:config>\n</container> // config/packages/cache.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->cache()\n// Only used with cache.adapter.filesystem\n->directory('%kernel.cache_dir%/pools') ->defaultDoctrineDbalProvider('doctrine.dbal.default_connection')\n->defaultPsr6Provider('app.my_psr6_service')\n->defaultRedisProvider('redis://localhost')\n->defaultMemcachedProvider('memcached://localhost')\n->defaultPdoProvider('pgsql:host=localhost')\n;\n}; Using a DSN as the provider for the PDO adapter was introduced in Symfony 7.1.", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_sem_1", "source": "cache.rst", "text": "Creating Custom (Namespaced) Pools You can also create more customized pools: # config/packages/cache.yaml\nframework:\ncache:\ndefault_memcached_provider: 'memcached://localhost' pools:\n# creates a \"custom_thing.cache\" service\n# autowireable via \"CacheInterface $customThingCache\"\n# uses the \"app\" cache configuration\ncustom_thing.cache:\nadapter: cache.app # creates a \"my_cache_pool\" service\n# autowireable via \"CacheInterface $myCachePool\"\nmy_cache_pool:\nadapter: cache.adapter.filesystem # uses the default_memcached_provider from above\nacme.cache:\nadapter: cache.adapter.memcached # control adapter's configuration\nfoobar.cache:\nadapter: cache.adapter.memcached\nprovider: 'memcached://user:password@example.com' # uses the \"foobar.cache\" pool as its backend but controls\n# the lifetime and (like all pools) has a separate cache namespace\nshort_cache:\nadapter: foobar.cache\ndefault_lifetime: 60 <!-- config/packages/cache.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n>\n<framework:config>\n<framework:cache default-memcached-provider=\"memcached://localhost\">\n<!-- creates a \"custom_thing.cache\" service\nautowireable via \"CacheInterface $customThingCache\"\nuses the \"app\" cache configuration -->\n<framework:pool name=\"custom_thing.cache\" adapter=\"cache.app\"/> <!-- creates a \"my_cache_pool\" service\nautowireable via \"CacheInterface $myCachePool\" -->\n<framework:pool name=\"my_cache_pool\" adapter=\"cache.adapter.filesystem\"/> <!-- uses the default_memcached_provider from above -->\n<framework:pool name=\"acme.cache\" adapter=\"cache.adapter.memcached\"/> <!-- control adapter's configuration -->\n<framework:pool name=\"foobar.cache\" adapter=\"cache.adapter.memcached\"\nprovider=\"memcached://user:password@example.com\"\n/> <!-- uses the \"foobar.cache\" pool as its backend but controls\nthe lifetime and (like all pools) has a separate cache namespace -->\n<framework:pool name=\"short_cache\" adapter=\"foobar.cache\" default-lifetime=\"60\"/>\n</framework:cache>\n</framework:config>\n</container> // config/packages/cache.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$cache = $framework->cache();\n$cache->defaultMemcachedProvider('memcached://localhost'); // creates a \"custom_thing.cache\" service\n// autowireable via \"CacheInterface $customThingCache\"\n// uses the \"app\" cache configuration\n$cache->pool('custom_thing.cache')\n->adapters(['cache.app']); // creates a \"my_cache_pool\" service\n// autowireable via \"CacheInterface $myCachePool\"\n$cache->pool('my_cache_pool')\n->adapters(['cache.adapter.filesystem']); // uses the default_memcached_provider from above\n$cache->pool('acme.cache')\n->adapters(['cache.adapter.memcached']); // control adapter's configuration\n$cache->pool('foobar.cache')\n->adapters(['cache.adapter.memcached'])\n->provider('memcached://user:password@example.com'); $cache->pool('short_cache')\n->adapters(['foobar.cache'])\n->defaultLifetime(60);\n}; Each pool manages a set of independent cache keys: keys from different pools\n*never* collide, even if they share the same backend. This is achieved by prefixing\nkeys with a namespace that's generated by hashing the name of the pool, the name\nof the cache adapter class and a configurable seed\nthat defaults to the project directory and compiled container class. Each custom pool becomes a service whose service ID is the name of the pool\n(e.g. custom_thing.cache). An autowiring alias is also created for each pool\nusing the camel case version of its name - e.g. custom_thing.cache can be\ninjected automatically by naming the argument $customThingCache and type-hinting it\nwith either Symfony\\\\Contracts\\\\Cache\\\\CacheInterface or\nPsr\\Cache\\CacheItemPoolInterface:: use Symfony\\Contracts\\Cache\\CacheInterface;\n// ... // from a controller method\npublic function listProducts(CacheInterface $customThingCache): Response\n{\n// ...\n} // in a service\npublic function __construct(private CacheInterface $customThingCache)\n{\n// ...\n} If you need the namespace to be interoperable with a third-party app,\nyou can take control over auto-generation by setting the namespace\nattribute of the cache.pool service tag. For example, you can\noverride the service definition of the adapter: # config/services.yaml\nservices:\n# ... app.cache.adapter.redis:\nparent: 'cache.adapter.redis'\ntags:\n- { name: 'cache.pool', namespace: 'my_custom_namespace' } <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"\n>\n<services>\n<!-- ... --> <service id=\"app.cache.adapter.redis\" parent=\"cache.adapter.redis\">\n<tag name=\"cache.pool\" namespace=\"my_custom_namespace\"/>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void {\n$container->services()\n// ...", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_sem_2", "source": "cache.rst", "text": "->set('app.cache.adapter.redis')\n->parent('cache.adapter.redis')\n->tag('cache.pool', ['namespace' => 'my_custom_namespace'])\n;\n}; Custom Provider Options Some providers have specific options that can be configured. The\nRedisAdapter allows you to\ncreate providers with the options timeout, retry_interval. etc. To use these\noptions with non-default values you need to create your own \\Redis provider\nand use that when configuring the pool. # config/packages/cache.yaml\nframework:\ncache:\npools:\ncache.my_redis:\nadapter: cache.adapter.redis\nprovider: app.my_custom_redis_provider services:\napp.my_custom_redis_provider:\nclass: \\Redis\nfactory: ['Symfony\\Component\\Cache\\Adapter\\RedisAdapter', 'createConnection']\narguments:\n- 'redis://localhost'\n- { retry_interval: 2, timeout: 10 } <!-- config/packages/cache.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n>\n<framework:config>\n<framework:cache>\n<framework:pool name=\"cache.my_redis\"\nadapter=\"cache.adapter.redis\"\nprovider=\"app.my_custom_redis_provider\"\n/>\n</framework:cache>\n</framework:config> <services>\n<service id=\"app.my_custom_redis_provider\" class=\"\\Redis\">\n<factory class=\"Symfony\\Component\\Cache\\Adapter\\RedisAdapter\" method=\"createConnection\"/>\n<argument>redis://localhost</argument>\n<argument type=\"collection\">\n<argument key=\"retry_interval\">2</argument>\n<argument key=\"timeout\">10</argument>\n</argument>\n</service>\n</services>\n</container> // config/packages/cache.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\Cache\\Adapter\\RedisAdapter;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Config\\FrameworkConfig; return static function (ContainerBuilder $container, FrameworkConfig $framework): void {\n$framework->cache()\n->pool('cache.my_redis')\n->adapters(['cache.adapter.redis'])\n->provider('app.my_custom_redis_provider'); $container->register('app.my_custom_redis_provider', \\Redis::class)\n->setFactory([RedisAdapter::class, 'createConnection'])\n->addArgument('redis://localhost')\n->addArgument([\n'retry_interval' => 2,\n'timeout' => 10\n])\n;\n}; Creating a Cache Chain Different cache adapters have different strengths and weaknesses. Some might be\nreally quick but optimized to store small items and some may be able to contain\na lot of data but are quite slow. To get the best of both worlds you may use a\nchain of adapters. A cache chain combines several cache pools into a single one. When storing an\nitem in a cache chain, Symfony stores it in all pools sequentially. When\nretrieving an item, Symfony tries to get it from the first pool. If it's not\nfound, it tries the next pools until the item is found or an exception is thrown.\nBecause of this behavior, it's recommended to define the adapters in the chain\nin order from fastest to slowest. If an error happens when storing an item in a pool, Symfony stores it in the\nother pools and no exception is thrown. Later, when the item is retrieved,\nSymfony stores the item automatically in all the missing pools. # config/packages/cache.yaml\nframework:\ncache:\npools:\nmy_cache_pool:\ndefault_lifetime: 31536000 # One year\nadapters:\n- cache.adapter.array\n- cache.adapter.apcu\n- {name: cache.adapter.redis, provider: 'redis://user:password@example.com'} <!-- config/packages/cache.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n>\n<framework:config>\n<framework:cache>\n<framework:pool name=\"my_cache_pool\"\ndefault-lifetime=\"31536000\"> <!-- One year -->\n<framework:adapter name=\"cache.adapter.array\"/>\n<framework:adapter name=\"cache.adapter.apcu\"/>\n<framework:adapter name=\"cache.adapter.redis\" provider=\"redis://user:password@example.com\"/>\n</framework:pool>\n</framework:cache>\n</framework:config>\n</container> // config/packages/cache.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->cache()\n->pool('my_cache_pool')\n->defaultLifetime(31536000) // One year\n->adapters([\n'cache.adapter.array',\n'cache.adapter.apcu',\n['name' => 'cache.adapter.redis', 'provider' => 'redis://user:password@example.com'],\n])\n;\n}; Using Cache Tags In applications with many cache keys it could be useful to organize the data stored\nto be able to invalidate the cache more efficiently. One way to achieve that is to\nuse cache tags. One or more tags could be added to the cache item. All items with\nthe same tag could be invalidated with one function call:: use Symfony\\Contracts\\Cache\\ItemInterface;\nuse Symfony\\Contracts\\Cache\\TagAwareCacheInterface;", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_sem_3", "source": "cache.rst", "text": "class SomeClass\n{\n// using autowiring to inject the cache pool\npublic function __construct(\nprivate TagAwareCacheInterface $myCachePool,\n) {\n} public function someMethod(): void\n{\n$value0 = $this->myCachePool->get('item_0', function (ItemInterface $item): string {\n$item->tag(['foo', 'bar']); return 'debug';\n}); $value1 = $this->myCachePool->get('item_1', function (ItemInterface $item): string {\n$item->tag('foo'); return 'debug';\n}); // Remove all cache keys tagged with \"bar\"\n$this->myCachePool->invalidateTags(['bar']);\n}\n} The cache adapter needs to implement Symfony\\\\Contracts\\\\Cache\\\\TagAwareCacheInterface\nto enable this feature. This could be added by using the following configuration. # config/packages/cache.yaml\nframework:\ncache:\npools:\nmy_cache_pool:\nadapter: cache.adapter.redis_tag_aware\ntags: true <!-- config/packages/cache.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n>\n<framework:config>\n<framework:cache>\n<framework:pool name=\"my_cache_pool\"\nadapter=\"cache.adapter.redis_tag_aware\"\ntags=\"true\"\n/>\n</framework:cache>\n</framework:config>\n</container> // config/packages/cache.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->cache()\n->pool('my_cache_pool')\n->tags(true)\n->adapters(['cache.adapter.redis_tag_aware'])\n;\n}; Tags are stored in the same pool by default. This is good in most scenarios. But\nsometimes it might be better to store the tags in a different pool. That could be\nachieved by specifying the adapter. # config/packages/cache.yaml\nframework:\ncache:\npools:\nmy_cache_pool:\nadapter: cache.adapter.redis\ntags: tag_pool\ntag_pool:\nadapter: cache.adapter.apcu <!-- config/packages/cache.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n>\n<framework:config>\n<framework:cache>\n<framework:pool name=\"my_cache_pool\"\nadapter=\"cache.adapter.redis\"\ntags=\"tag_pool\"\n/>\n<framework:pool name=\"tag_pool\" adapter=\"cache.adapter.apcu\"/>\n</framework:cache>\n</framework:config>\n</container> // config/packages/cache.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->cache()\n->pool('my_cache_pool')\n->tags('tag_pool')\n->adapters(['cache.adapter.redis'])\n; $framework->cache()\n->pool('tag_pool')\n->adapters(['cache.adapter.apcu'])\n;\n}; The interface Symfony\\\\Contracts\\\\Cache\\\\TagAwareCacheInterface is\nautowired to the cache.app service. Clearing the Cache To clear the cache you can use the bin/console cache:pool:clear [pool] command.\nThat will remove all the entries from your storage and you will have to recalculate\nall the values. You can also group your pools into \"cache clearers\". There are 3 cache\nclearers by default: * cache.global_clearer\n* cache.system_clearer\n* cache.app_clearer The global clearer clears all the cache items in every pool. The system cache clearer\nis used in the bin/console cache:clear command. The app clearer is the default\nclearer. To see all available cache pools: $ php bin/console cache:pool:list Clear one pool: $ php bin/console cache:pool:clear my_cache_pool Clear all custom pools: $ php bin/console cache:pool:clear cache.app_clearer Clear all cache pools: $ php bin/console cache:pool:clear --all Clear all cache pools except some: $ php bin/console cache:pool:clear --all --exclude=my_cache_pool --exclude=another_cache_pool Clear all caches everywhere: $ php bin/console cache:pool:clear cache.global_clearer Clear cache by tag(s): # invalidate tag1 from all taggable pools\n$ php bin/console cache:pool:invalidate-tags tag1 # invalidate tag1 & tag2 from all taggable pools\n$ php bin/console cache:pool:invalidate-tags tag1 tag2 # invalidate tag1 & tag2 from cache.app pool\n$ php bin/console cache:pool:invalidate-tags tag1 tag2 --pool=cache.app # invalidate tag1 & tag2 from cache1 & cache2 pools\n$ php bin/console cache:pool:invalidate-tags tag1 tag2 -p cache1 -p cache2 Encrypting the Cache To encrypt the cache using libsodium, you can use the\nSymfony\\\\Component\\\\Cache\\\\Marshaller\\\\SodiumMarshaller. First, you need to generate a secure key and add it to your secret\nstore as CACHE_DECRYPTION_KEY: $ php -r 'echo base64_encode(sodium_crypto_box_keypair());' Then, register the SodiumMarshaller service using this key: # config/packages/cache.yaml", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_sem_4", "source": "cache.rst", "text": "# ...\nservices:\nSymfony\\Component\\Cache\\Marshaller\\SodiumMarshaller:\ndecorates: cache.default_marshaller\narguments:\n- ['%env(base64:CACHE_DECRYPTION_KEY)%']\n# use multiple keys in order to rotate them\n#- ['%env(base64:CACHE_DECRYPTION_KEY)%', '%env(base64:OLD_CACHE_DECRYPTION_KEY)%']\n- '@.inner' <!-- config/packages/cache.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <services>\n<service id=\"Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller\" decorates=\"cache.default_marshaller\">\n<argument type=\"collection\">\n<argument>env(base64:CACHE_DECRYPTION_KEY)</argument>\n<!-- use multiple keys in order to rotate them -->\n<!-- <argument>env(base64:OLD_CACHE_DECRYPTION_KEY)</argument> -->\n</argument>\n<argument type=\"service\" id=\".inner\"/>\n</service>\n</services>\n</container> // config/packages/cache.php\nuse Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller;\nuse Symfony\\Component\\DependencyInjection\\ChildDefinition;\nuse Symfony\\Component\\DependencyInjection\\Reference; // ...\n$container->setDefinition(SodiumMarshaller::class, new ChildDefinition('cache.default_marshaller'))\n->addArgument(['env(base64:CACHE_DECRYPTION_KEY)'])\n// use multiple keys in order to rotate them\n//->addArgument(['env(base64:CACHE_DECRYPTION_KEY)', 'env(base64:OLD_CACHE_DECRYPTION_KEY)'])\n->addArgument(new Reference('.inner')); This will encrypt the values of the cache items, but not the cache keys. Be\ncareful not to leak sensitive data in the keys. When configuring multiple keys, the first key will be used for reading and\nwriting, and the additional key(s) will only be used for reading. Once all\ncache items encrypted with the old key have expired, you can completely remove\nOLD_CACHE_DECRYPTION_KEY. Computing Cache Values Asynchronously The Cache component uses the `probabilistic early expiration`_ algorithm to\nprotect against the cache stampede problem.\nThis means that some cache items are elected for early-expiration while they are\nstill fresh. By default, expired cache items are computed synchronously. However, you can\ncompute them asynchronously by delegating the value computation to a background\nworker using the Messenger component . In this case,\nwhen an item is queried, its cached value is immediately returned and a\nSymfony\\\\Component\\\\Cache\\\\Messenger\\\\EarlyExpirationMessage is\ndispatched through a Messenger bus. When this message is handled by a message consumer, the refreshed cache value is\ncomputed asynchronously. The next time the item is queried, the refreshed value\nwill be fresh and returned. First, create a service that will compute the item's value:: // src/Cache/CacheComputation.php\nnamespace App\\Cache; use Psr\\Cache\\CacheItemInterface;\nuse Symfony\\Contracts\\Cache\\CallbackInterface; class CacheComputation implements CallbackInterface\n{\npublic function __invoke(CacheItemInterface $item, bool &$save): string\n{\n$item->expiresAfter(5); // this is just a random example; here you must do your own calculation\nreturn sprintf('#%06X', mt_rand(0, 0xFFFFFF));\n}\n} This cache value will be requested from a controller, another service, etc.\nIn the following example, the value is requested from a controller:: // src/Controller/CacheController.php\nnamespace App\\Controller; use App\\Cache\\CacheComputation;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\nuse Symfony\\Contracts\\Cache\\CacheInterface;\nuse Symfony\\Contracts\\Cache\\ItemInterface; class CacheController extends AbstractController\n{\n#[Route('/cache', name: 'cache')]\npublic function index(CacheInterface $asyncCache, CacheComputation $cacheComputation): Response\n{\n// pass to the cache the service method that refreshes the item\n$cachedValue = $asyncCache->get('my_value', $cacheComputation) // ...\n}\n} Finally, configure a new cache pool (e.g. called async.cache) that will use\na message bus to compute values in a worker: # config/packages/framework.yaml\nframework:\ncache:\npools:\nasync.cache:\nearly_expiration_message_bus: messenger.default_bus messenger:\ntransports:\nasync_bus: '%env(MESSENGER_TRANSPORT_DSN)%'\nrouting:\n'Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage': async_bus <!-- config/packages/framework.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n>\n<framework:config>\n<framework:cache>\n<framework:pool name=\"async.cache\" early-expiration-message-bus=\"messenger.default_bus\"/>\n</framework:cache> <framework:messenger>\n<framework:transport name=\"async_bus\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport>\n<framework:routing message-class=\"Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage\">\n<framework:sender service=\"async_bus\"/>\n</framework:routing>\n</framework:messenger>\n</framework:config>\n</container> // config/framework/framework.php\nuse Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage;\nuse Symfony\\Config\\FrameworkConfig;\nuse function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env; return static function (FrameworkConfig $framework): void {\n$framework->cache()\n->pool('async.cache')\n->earlyExpirationMessageBus('messenger.default_bus'); $framework->messenger()\n->transport('async_bus')\n->dsn(env('MESSENGER_TRANSPORT_DSN'))\n->routing(EarlyExpirationMessage::class)\n->senders(['async_bus']);\n};", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_sem_5", "source": "cache.rst", "text": "You can now start the consumer: $ php bin/console messenger:consume async_bus That's it! Now, whenever an item is queried from this cache pool, its cached\nvalue will be returned immediately. If it is elected for early-expiration, a\nmessage will be sent through to bus to schedule a background computation to refresh\nthe value.", "title": "Cache", "category": "cache"}
{"chunk_id": "configuration.rst_sem_0", "source": "configuration.rst", "text": "Configuring Symfony Configuration Files Symfony applications are configured with the files stored in the config/\ndirectory, which has this default structure: your-project/\n├─ config/\n│ ├─ packages/\n│ ├─ bundles.php\n│ ├─ routes.yaml\n│ └─ services.yaml * The routes.yaml file defines the routing configuration ;\n* The services.yaml file configures the services of the service container ;\n* The bundles.php file enables/disables packages in your application;\n* The config/packages/ directory stores the configuration of every package\ninstalled in your application. Packages (also called \"bundles\" in Symfony and \"plugins/modules\" in other\nprojects) add ready-to-use features to your projects. When using Symfony Flex , which is enabled by default in\nSymfony applications, packages update the bundles.php file and create new\nfiles in config/packages/ automatically during their installation. For\nexample, this is the default file created by the \"API Platform\" bundle: # config/packages/api_platform.yaml\napi_platform:\nmapping:\npaths: ['%kernel.project_dir%/src/Entity'] Splitting the configuration into lots of small files might seem intimidating to some\nSymfony newcomers. However, you'll get used to them quickly and you rarely need\nto change these files after package installation. To learn about all the available configuration options, check out the\nSymfony Configuration Reference or run the\nconfig:dump-reference command. Configuration Formats Unlike other frameworks, Symfony doesn't impose a specific format on you to\nconfigure your applications, but lets you choose between YAML, XML and PHP.\nThroughout the Symfony documentation, all configuration examples will be\nshown in these three formats. There isn't any practical difference between formats. In fact, Symfony\ntransforms all of them into PHP and caches them before running the application,\nso there's not even any performance difference. YAML is used by default when installing packages because it's concise and very\nreadable. These are the main advantages and disadvantages of each format: * **YAML**: simple, clean and readable, but not all IDEs support autocompletion\nand validation for it. Learn the YAML syntax ;\n* **XML**: autocompleted/validated by most IDEs and is parsed natively by PHP,\nbut sometimes it generates configuration considered too verbose. `Learn the XML syntax`_;\n* **PHP**: very powerful and it allows you to create dynamic configuration with\narrays or a ConfigBuilder . By default Symfony loads the configuration files defined in YAML and PHP\nformats. If you define configuration in XML format, update the\nSymfony\\\\Bundle\\\\FrameworkBundle\\\\Kernel\\\\MicroKernelTrait::configureContainer\nand/or\nSymfony\\\\Bundle\\\\FrameworkBundle\\\\Kernel\\\\MicroKernelTrait::configureRoutes\nmethods in the src/Kernel.php file to add support for the .xml file\nextension. Importing Configuration Files Symfony loads configuration files using the Config component\n, which provides advanced features such as importing other\nconfiguration files, even if they use a different format: # config/services.yaml\nimports:\n- { resource: 'legacy_config.php' } # glob expressions are also supported to load multiple files\n- { resource: '/etc/myapp/*.yaml' } # ignore_errors: not_found silently discards errors if the loaded file doesn't exist\n- { resource: 'my_config_file.xml', ignore_errors: not_found }\n# ignore_errors: true silently discards all errors (including invalid code and not found)\n- { resource: 'my_other_config_file.xml', ignore_errors: true } # ... <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_1", "source": "configuration.rst", "text": "<imports>\n<import resource=\"legacy_config.php\"/>\n<!-- glob expressions are also supported to load multiple files -->\n<import resource=\"/etc/myapp/*.yaml\"/> <!-- ignore-errors=\"not_found\" silently discards errors if the loaded file doesn't exist -->\n<import resource=\"my_config_file.yaml\" ignore-errors=\"not_found\"/>\n<!-- ignore-errors=\"true\" silently discards all errors (including invalid code and not found) -->\n<import resource=\"my_other_config_file.yaml\" ignore-errors=\"true\"/>\n</imports> <!-- ... -->\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return static function (ContainerConfigurator $container): void {\n$container->import('legacy_config.php'); // glob expressions are also supported to load multiple files\n$container->import('/etc/myapp/*.yaml'); // the third optional argument of import() is 'ignore_errors'\n// 'ignore_errors' set to 'not_found' silently discards errors if the loaded file doesn't exist\n$container->import('my_config_file.yaml', null, 'not_found');\n// 'ignore_errors' set to true silently discards all errors (including invalid code and not found)\n$container->import('my_config_file.yaml', null, true);\n}; // ... Configuration Parameters Sometimes the same configuration value is used in several configuration files.\nInstead of repeating it, you can define it as a \"parameter\", which is like a\nreusable configuration value. By convention, parameters are defined under the\nparameters key in the config/services.yaml file: # config/services.yaml\nparameters:\n# the parameter name is an arbitrary string (the 'app.' prefix is recommended\n# to better differentiate your parameters from Symfony parameters).\napp.admin_email: 'something@example.com' # boolean parameters\napp.enable_v2_protocol: true # array/collection parameters\napp.supported_locales: ['en', 'es', 'fr'] # binary content parameters (encode the contents with base64_encode())\napp.some_parameter: !!binary VGhpcyBpcyBhIEJlbGwgY2hhciAH # PHP constants as parameter values\napp.some_constant: !php/const GLOBAL_CONSTANT\napp.another_constant: !php/const App\\Entity\\BlogPost::MAX_ITEMS # Enum case as parameter values\napp.some_enum: !php/enum App\\Enum\\PostState::Published # ... <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <parameters>\n<!-- the parameter name is an arbitrary string (the 'app.' prefix is recommended\nto better differentiate your parameters from Symfony parameters). -->\n<parameter key=\"app.admin_email\">something@example.com</parameter> <!-- boolean parameters -->\n<parameter key=\"app.enable_v2_protocol\">true</parameter>\n<!-- if you prefer to store the boolean value as a string in the parameter -->\n<parameter key=\"app.enable_v2_protocol\" type=\"string\">true</parameter> <!-- array/collection parameters -->\n<parameter key=\"app.supported_locales\" type=\"collection\">\n<parameter>en</parameter>\n<parameter>es</parameter>\n<parameter>fr</parameter>\n</parameter> <!-- binary content parameters (encode the contents with base64_encode()) -->\n<parameter key=\"app.some_parameter\" type=\"binary\">VGhpcyBpcyBhIEJlbGwgY2hhciAH</parameter> <!-- PHP constants as parameter values -->\n<parameter key=\"app.some_constant\" type=\"constant\">GLOBAL_CONSTANT</parameter>\n<parameter key=\"app.another_constant\" type=\"constant\">App\\Entity\\BlogPost::MAX_ITEMS</parameter> <!-- Enum case as parameter values -->\n<parameter key=\"app.some_enum\" type=\"constant\">App\\Enum\\PostState::Published</parameter>\n</parameters> <!-- ... -->\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Entity\\BlogPost;\nuse App\\Enum\\PostState; return static function (ContainerConfigurator $container): void {\n$container->parameters()\n// the parameter name is an arbitrary string (the 'app.' prefix is recommended\n// to better differentiate your parameters from Symfony parameters).\n->set('app.admin_email', 'something@example.com') // boolean parameters\n->set('app.enable_v2_protocol', true) // array/collection parameters\n->set('app.supported_locales', ['en', 'es', 'fr']) // binary content parameters (use the PHP escape sequences)\n->set('app.some_parameter', 'This is a Bell char: \\x07') // PHP constants as parameter values\n->set('app.some_constant', GLOBAL_CONSTANT)\n->set('app.another_constant', BlogPost::MAX_ITEMS) // Enum case as parameter values\n->set('app.some_enum', PostState::Published);\n}; // ... By default and when using XML configuration, the values between <parameter>\ntags are not trimmed. This means that the value of the following parameter will be\n'\\n something@example.com\\n': <parameter key=\"app.admin_email\">\nsomething@example.com\n</parameter>", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_2", "source": "configuration.rst", "text": "If you want to trim the value of your parameter, use the trim attribute.\nWhen using it, the value of the following parameter will be something@example.com: <parameter key=\"app.admin_email\" trim=\"true\">\nsomething@example.com\n</parameter> Once defined, you can reference this parameter value from any other\nconfiguration file using a special syntax: wrap the parameter name in two %\n(e.g. %app.admin_email%): # config/packages/some_package.yaml\nsome_package:\n# any string surrounded by two % is replaced by that parameter value\nemail_address: '%app.admin_email%' <!-- config/packages/some_package.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- any string surrounded by two % is replaced by that parameter value -->\n<some-package:config email-address=\"%app.admin_email%\">\n<!-- ... -->\n</some-package:config>\n</container> // config/packages/some_package.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\nuse function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\param; return static function (ContainerConfigurator $container): void {\n$container->extension('some_package', [\n// when using the param() function, you only have to pass the parameter name...\n'email_address' => param('app.admin_email'), // ... but if you prefer it, you can also pass the name as a string\n// surrounded by two % (same as in YAML and XML formats) and Symfony will\n// replace it by that parameter value\n'email_address' => '%app.admin_email%',\n]);\n}; If some parameter value includes the % character, you need to escape it\nby adding another %, so Symfony doesn't consider it a reference to a\nparameter name: # config/services.yaml\nparameters:\n# Parsed as 'https://symfony.com/?foo=%s&amp;bar=%d'\nurl_pattern: 'https://symfony.com/?foo=%%s&amp;bar=%%d' <!-- config/services.xml -->\n<parameters>\n<parameter key=\"url_pattern\">http://symfony.com/?foo=%%s&amp;bar=%%d</parameter>\n</parameters> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return static function (ContainerConfigurator $container): void {\n$container->parameters()\n->set('url_pattern', 'http://symfony.com/?foo=%%s&amp;bar=%%d');\n}; Configuration parameters are very common in Symfony applications. Some packages\neven define their own parameters (e.g. when installing the translation package,\na new locale parameter is added to the config/services.yaml file). By convention, parameters whose names start with a dot . (for example,\n.mailer.transport), are available only during the container compilation.\nThey are useful when working with Compiler Passes\nto declare some temporary parameters that won't be available later in the application. Configuration parameters are usually validation-free, but you can ensure that\nessential parameters for your application's functionality are not empty:: /** @var ContainerBuilder $container */\n$container->parameterCannotBeEmpty('app.private_key', 'Did you forget to set a value for the \"app.private_key\" parameter?'); If a non-empty parameter is null, an empty string '', or an empty array [],\nSymfony will throw an exception. This validation is **not** made at compile time\nbut when attempting to retrieve the value of the parameter. Validating non-empty parameters was introduced in Symfony 7.2. Later in this article you can read how to\nget configuration parameters in controllers and services . Configuration Environments You have only one application, but whether you realize it or not, you need it\nto behave differently at different times: * While **developing**, you want to log everything and expose nice debugging tools;\n* After deploying to **production**, you want that same application to be\noptimized for speed and only log errors.", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_3", "source": "configuration.rst", "text": "The files stored in config/packages/ are used by Symfony to configure the\napplication services . In other words, you can change\nthe application behavior by changing which configuration files are loaded.\nThat's the idea of Symfony's **configuration environments**. A typical Symfony application begins with three environments: * dev for local development,\n* prod for production servers,\n* test for automated tests . When running the application, Symfony loads the configuration files in this\norder (the last files can override the values set in the previous ones): #. The files in config/packages/*.<extension>;\n#. the files in config/packages/<environment-name>/*.<extension>;\n#. config/services.<extension>;\n#. config/services_<environment-name>.<extension>. Take the framework package, installed by default, as an example: * First, config/packages/framework.yaml is loaded in all environments and\nit configures the framework with some options;\n* In the **prod** environment, nothing extra will be set as there is no\nconfig/packages/prod/framework.yaml file;\n* In the **dev** environment, there is no file either (\nconfig/packages/dev/framework.yaml does not exist).\n* In the **test** environment, the config/packages/test/framework.yaml file\nis loaded to override some of the settings previously configured in\nconfig/packages/framework.yaml. In reality, each environment differs only somewhat from others. This means that\nall environments share a large base of common configuration, which is put in\nfiles directly in the config/packages/ directory. You can also define options for different environments in a single\nconfiguration file using the special when keyword: # config/packages/webpack_encore.yaml\nwebpack_encore:\n# ...\noutput_path: '%kernel.project_dir%/public/build'\nstrict_mode: true\ncache: false # cache is enabled only in the \"prod\" environment\nwhen@prod:\nwebpack_encore:\ncache: true # disable strict mode only in the \"test\" environment\nwhen@test:\nwebpack_encore:\nstrict_mode: false # YAML syntax allows to reuse contents using \"anchors\" (&some_name) and \"aliases\" (*some_name).\n# In this example, 'test' configuration uses the exact same configuration as in 'prod'\nwhen@prod: &webpack_prod\nwebpack_encore:\n# ...\nwhen@test: *webpack_prod <!-- config/packages/webpack_encore.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n<webpack-encore:config\noutput-path=\"%kernel.project_dir%/public/build\"\nstrict-mode=\"true\"\ncache=\"false\"\n/> <!-- cache is enabled only in the \"test\" environment -->\n<when env=\"prod\">\n<webpack-encore:config cache=\"true\"/>\n</when> <!-- disable strict mode only in the \"test\" environment -->\n<when env=\"test\">\n<webpack-encore:config strict-mode=\"false\"/>\n</when>\n</container> // config/packages/framework.php\nuse Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\nuse Symfony\\Config\\WebpackEncoreConfig; return static function (WebpackEncoreConfig $webpackEncore, ContainerConfigurator $container): void {\n$webpackEncore\n->outputPath('%kernel.project_dir%/public/build')\n->strictMode(true)\n->cache(false)\n; // cache is enabled only in the \"prod\" environment\nif ('prod' === $container->env()) {\n$webpackEncore->cache(true);\n} // disable strict mode only in the \"test\" environment\nif ('test' === $container->env()) {\n$webpackEncore->strictMode(false);\n}\n}; See the configureContainer() method of\nthe Kernel class to\nlearn everything about the loading order of configuration files. Selecting the Active Environment Symfony applications come with a file called .env located at the project\nroot directory. This file is used to define the value of environment variables\nand it's explained in detail later in this article . Open the .env file (or better, the .env.local file if you created one)\nand edit the value of the APP_ENV variable to change the environment in\nwhich the application runs. For example, to run the application in production: # .env (or .env.local)\nAPP_ENV=prod", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_4", "source": "configuration.rst", "text": "This value is used both for the web and for the console commands. However, you\ncan override it for commands by setting the APP_ENV value before running them: # Use the environment defined in the .env file\n$ php bin/console command_name # Ignore the .env file and run this command in production\n$ APP_ENV=prod php bin/console command_name Creating a New Environment The default three environments provided by Symfony are enough for most projects,\nbut you can define your own environments too. For example, this is how you can\ndefine a staging environment where the client can test the project before\ngoing to production: #. Create a configuration directory with the same name as the environment (in\nthis case, config/packages/staging/);\n#. Add the needed configuration files in config/packages/staging/ to\ndefine the behavior of the new environment. Symfony loads the\nconfig/packages/*.yaml files first, so you only need to configure the\ndifferences to those files;\n#. Select the staging environment using the APP_ENV env var as explained\nin the previous section. It's common for environments to be similar to each other, so you can\nuse `symbolic links`_ between config/packages/<environment-name>/\ndirectories to reuse the same configuration. Instead of creating new environments, you can use environment variables as\nexplained in the following section. This way you can use the same application\nand environment (e.g. prod) but change its behavior thanks to the\nconfiguration based on environment variables (e.g. to run the application in\ndifferent scenarios: staging, quality assurance, client review, etc.) Configuration Based on Environment Variables Using `environment variables`_ (or \"env vars\" for short) is a common practice to: * Configure options that depend on where the application is run (e.g. the database\ncredentials are usually different in production versus your local machine);\n* Configure options that can change dynamically in a production environment (e.g.\nto update the value of an expired API key without having to redeploy the entire\napplication). In other cases, it's recommended to keep using configuration parameters . Use the special syntax %env(ENV_VAR_NAME)% to reference environment variables.\nThe values of these options are resolved at runtime (only once per request, to\nnot impact performance) so you can change the application behavior without having\nto clear the cache. This example shows how you could configure the application secret using an env var: # config/packages/framework.yaml\nframework:\n# by convention the env var names are always uppercase\nsecret: '%env(APP_SECRET)%'\n# ... <!-- config/packages/framework.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/framework\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- by convention the env var names are always uppercase -->\n<framework:config secret=\"%env(APP_SECRET)%\"/> </container> // config/packages/framework.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return static function (ContainerConfigurator $container): void {\n$container->extension('framework', [\n// by convention the env var names are always uppercase\n'secret' => '%env(APP_SECRET)%',\n]);\n}; Your env vars can also be accessed via the PHP super globals $_ENV and\n$_SERVER (both are equivalent):: $databaseUrl = $_ENV['DATABASE_URL']; // mysql://db_user:db_password@127.0.0.1:3306/db_name\n$env = $_SERVER['APP_ENV']; // prod", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_5", "source": "configuration.rst", "text": "However, in Symfony applications there's no need to use this, because the\nconfiguration system provides a better way of working with env vars. The values of env vars can only be strings, but Symfony includes some\nenv var processors to transform\ntheir contents (e.g. to turn a string value into an integer). To define the value of an env var, you have several options: * Add the value to a .env file ;\n* Encrypt the value as a secret ;\n* Set the value as a real environment variable in your shell or your web server. If your application tries to use an env var that hasn't been defined, you'll see\nan exception. You can prevent that by defining a default value for the env var.\nTo do so, define a parameter with the same name as the env var using this syntax: # config/packages/framework.yaml\nparameters:\n# if the SECRET env var value is not defined anywhere, Symfony uses this value\nenv(SECRET): 'some_secret' # ... <!-- config/packages/framework.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <parameters>\n<!-- if the SECRET env var value is not defined anywhere, Symfony uses this value -->\n<parameter key=\"env(SECRET)\">some_secret</parameter>\n</parameters> <!-- ... -->\n</container> // config/packages/framework.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Config\\FrameworkConfig; return static function (ContainerBuilder $container, FrameworkConfig $framework) {\n// if the SECRET env var value is not defined anywhere, Symfony uses this value\n$container->setParameter('env(SECRET)', 'some_secret'); // ...\n}; Some hosts - like Upsun - offer easy `utilities to manage env vars`_\nin production. Some configuration features are not compatible with env vars. For example,\ndefining some container parameters conditionally based on the existence of\nanother configuration option. When using an env var, the configuration option\nalways exists, because its value will be null when the related env var\nis not defined. Beware that dumping the contents of the $_SERVER and $_ENV variables\nor outputting the phpinfo() contents will display the values of the\nenvironment variables, exposing sensitive information such as the database\ncredentials. The values of the env vars are also exposed in the web interface of the\nSymfony profiler . In practice this shouldn't be a\nproblem because the web profiler must **never** be enabled in production. Configuring Environment Variables in .env Files Instead of defining env vars in your shell or your web server, Symfony provides\na convenient way to define them inside a .env (with a leading dot) file\nlocated at the root of your project. The .env file is read and parsed on every request and its env vars are added\nto the $_ENV & $_SERVER PHP variables. Any existing env vars are *never*\noverwritten by the values defined in .env, so you can combine both. For example, to define the DATABASE_URL env var shown earlier in this article,\nyou can add: # .env\nDATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name\"", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_6", "source": "configuration.rst", "text": "This file should be committed to your repository and (due to that fact) should\nonly contain \"default\" values that are good for local development. This file\nshould not contain production values. In addition to your own env vars, this .env file also contains the env vars\ndefined by the third-party packages installed in your application (they are\nadded automatically by Symfony Flex when installing packages). Since the .env file is read and parsed on every request, you don't need to\nclear the Symfony cache or restart the PHP container if you're using Docker. .env File Syntax\n................ Add comments by prefixing them with #: # database credentials\nDB_USER=root\nDB_PASS=pass # this is the secret password Use environment variables in values by prefixing variables with $: DB_USER=root\nDB_PASS=${DB_USER}pass # include the user as a password prefix The order is important when some env var depends on the value of other env\nvars. In the above example, DB_PASS must be defined after DB_USER.\nMoreover, if you define multiple .env files and put DB_PASS first,\nits value will depend on the DB_USER value defined in other files\ninstead of the value defined in this file. Define a default value in case the environment variable is not set: DB_USER=\nDB_PASS=${DB_USER:-root}pass # results in DB_PASS=rootpass Embed commands via $() (not supported on Windows): START_TIME=$(date) Using $() might not work depending on your shell. As a .env file is a regular shell script, you can source it in\nyour own shell scripts: $ source .env Overriding Environment Values via .env.local If you need to override an environment value (e.g. to a different value on your\nlocal machine), you can do that in a .env.local file: # .env.local\nDATABASE_URL=\"mysql://root:@127.0.0.1:3306/my_database_name\" This file should be ignored by git and should *not* be committed to your repository.\nSeveral other .env files are available to set environment variables in *just*\nthe right situation: * .env: defines the default values of the env vars needed by the application;\n* .env.local: overrides the default values for all environments but only on\nthe machine which contains the file. This file should not be committed to the\nrepository and it's ignored in the test environment (because tests should\nproduce the same results for everyone);\n* .env.<environment> (e.g. .env.test): overrides env vars only for one\nenvironment but for all machines (these files *are* committed);\n* .env.<environment>.local (e.g. .env.test.local): defines machine-specific\nenv var overrides only for one environment. It's similar to .env.local,\nbut the overrides only apply to one environment. *Real* environment variables always win over env vars created by any of the\n.env files. Note that this behavior depends on the\n`variables_order <http://php.net/manual/en/ini.core.php#ini.variables-order>`_\nconfiguration, which must contain an E to expose the $_ENV superglobal.\nThis is the default configuration in PHP.", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_7", "source": "configuration.rst", "text": "The .env and .env.<environment> files should be committed to the\nrepository because they are the same for all developers and machines. However,\nthe env files ending in .local (.env.local and .env.<environment>.local)\n**should not be committed** because only you will use them. In fact, the\n.gitignore file that comes with Symfony prevents them from being committed. Overriding Environment Variables Defined By The System If you need to override an environment variable defined by the system, use the\noverrideExistingVars parameter defined by the\nSymfony\\\\Component\\\\Dotenv\\\\Dotenv::loadEnv,\nSymfony\\\\Component\\\\Dotenv\\\\Dotenv::bootEnv, and\nSymfony\\\\Component\\\\Dotenv\\\\Dotenv::populate methods:: use Symfony\\Component\\Dotenv\\Dotenv; $dotenv = new Dotenv();\n$dotenv->loadEnv(__DIR__.'/.env', overrideExistingVars: true); // ... This will override environment variables defined by the system but it **won't**\noverride environment variables defined in .env files. Configuring Environment Variables in Production In production, the .env files are also parsed and loaded on each request. So\nthe easiest way to define env vars is by creating a .env.local file on your\nproduction server(s) with your production values. To improve performance, you can optionally run the dump-env Composer command: # parses ALL .env files and dumps their final values to .env.local.php\n$ composer dump-env prod If you don't have Composer installed in production, you can use the\ndotenv:dump command instead (available in Symfony Flex\n1.2 or later). The command is not registered by default, so you must register\nfirst in your services: # config/services.yaml\nservices:\nSymfony\\Component\\Dotenv\\Command\\DotenvDumpCommand: ~ Then, run the command: # parses ALL .env files and dumps their final values to .env.local.php\n$ APP_ENV=prod APP_DEBUG=0 php bin/console dotenv:dump After running this command, Symfony will load the .env.local.php file to\nget the environment variables and will not spend time parsing the .env files. Update your deployment tools/workflow to run the dotenv:dump command after\neach deploy to improve the application performance. Storing Environment Variables In Other Files By default, the environment variables are stored in the .env file located\nat the root of your project. However, you can store them in other files in\nmultiple ways. If you use the Runtime component , the dotenv\npath is part of the options you can set in your composer.json file: {\n// ...\n\"extra\": {\n// ...\n\"runtime\": {\n\"dotenv_path\": \"my/custom/path/to/.env\"\n}\n}\n} As an alternate option, you can directly invoke the Dotenv class in your\nbootstrap.php file or any other file of your application:: use Symfony\\Component\\Dotenv\\Dotenv; (new Dotenv())->bootEnv(dirname(__DIR__).'my/custom/path/to/.env'); Symfony will then look for the environment variables in that file, but also in\nthe local and environment-specific files (e.g. .*.local and\n.*.<environment>.local). Read\nhow to override environment variables\nto learn more about this. If you need to know the path to the .env file that Symfony is using, you can\nread the SYMFONY_DOTENV_PATH environment variable in your application. The SYMFONY_DOTENV_PATH environment variable was introduced in Symfony\n7.1. Encrypting Environment Variables (Secrets) Instead of defining a real environment variable or adding it to a .env file,\nif the value of a variable is sensitive (e.g. an API key or a database password),\nyou can encrypt the value using the secrets management system .", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_8", "source": "configuration.rst", "text": "Listing Environment Variables Use the debug:dotenv command to understand how Symfony parses the different\n.env files to set the value of each environment variable: $ php bin/console debug:dotenv Dotenv Variables & Files Scanned Files (in descending priority) * ⨯ .env.local.php\n* ⨯ .env.dev.local\n* ✓ .env.dev\n* ⨯ .env.local\n* ✓ .env Variables ---------- ------- ---------- ------\nVariable Value .env.dev .env\n---------- ------- ---------- ------\nFOO BAR n/a BAR\nALICE BOB BOB bob\n---------- ------- ---------- ------ # look for a specific variable passing its full or partial name as an argument\n$ php bin/console debug:dotenv foo Additionally, and regardless of how you set environment variables, you can see all\nenvironment variables, with their values, referenced in Symfony's container configuration,\nyou can also see the number of occurrences of each environment variable in the container: $ php bin/console debug:container --env-vars ------------ ----------------- ------------------------------------ -------------\nName Default value Real value Usage count\n------------ ----------------- ------------------------------------ -------------\nAPP_SECRET n/a \"471a62e2d601a8952deb186e44186cb3\" 2\nBAR n/a n/a 1\nBAZ n/a \"value\" 0\nFOO \"[1, \"2.5\", 3]\" n/a 1\n------------ ----------------- ------------------------------------ ------------- # you can also filter the list of env vars by name:\n$ php bin/console debug:container --env-vars foo # run this command to show all the details for a specific env var:\n$ php bin/console debug:container --env-var=FOO Creating Your Own Logic To Load Env Vars You can implement your own logic to load environment variables if the default\nSymfony behavior doesn't fit your needs. To do so, create a service whose class\nimplements Symfony\\\\Component\\\\DependencyInjection\\\\EnvVarLoaderInterface. If you're using the default services.yaml configuration ,\nthe autoconfiguration feature will enable and tag this service automatically.\nOtherwise, you need to register and tag your service\nwith the container.env_var_loader tag. Let's say you have a JSON file named env.json containing your environment\nvariables: {\n\"vars\": {\n\"APP_ENV\": \"prod\",\n\"APP_DEBUG\": false\n}\n} You can define a class like the following JsonEnvVarLoader to populate the\nenvironment variables from the file:: namespace App\\DependencyInjection; use Symfony\\Component\\DependencyInjection\\EnvVarLoaderInterface; final class JsonEnvVarLoader implements EnvVarLoaderInterface\n{\nprivate const ENV_VARS_FILE = 'env.json'; public function loadEnvVars(): array\n{\n$fileName = __DIR__.\\DIRECTORY_SEPARATOR.self::ENV_VARS_FILE;\nif (!is_file($fileName)) {\n// throw an exception or just ignore this loader, depending on your needs\n} $content = json_decode(file_get_contents($fileName), true); return $content['vars'];\n}\n} That's it! Now the application will look for a env.json file in the\ncurrent directory to populate environment variables (in addition to the\nalready existing .env files). If you want an env var to have a value on a certain environment but to fallback\non loaders on another environment, assign an empty value to the env var for\nthe environment you want to use loaders: # .env (or .env.local)\nAPP_ENV=prod # .env.prod (or .env.prod.local) - this will fallback on the loaders you defined\nAPP_ENV= Accessing Configuration Parameters Controllers and services can access all the configuration parameters. This\nincludes both the parameters defined by yourself\nand the parameters created by packages/bundles. Run the following command to see\nall the parameters that exist in your application: $ php bin/console debug:container --parameters", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_9", "source": "configuration.rst", "text": "In controllers extending from the AbstractController ,\nuse the getParameter() helper:: // src/Controller/UserController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response; class UserController extends AbstractController\n{\n// ... public function index(): Response\n{\n$projectDir = $this->getParameter('kernel.project_dir');\n$adminEmail = $this->getParameter('app.admin_email'); // ...\n}\n} In services and controllers not extending from AbstractController, inject\nthe parameters as arguments of their constructors. You must inject them\nexplicitly because service autowiring\ndoesn't work for parameters: # config/services.yaml\nparameters:\napp.contents_dir: '...' services:\nApp\\Service\\MessageGenerator:\narguments:\n$contentsDir: '%app.contents_dir%' <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters>\n<parameter key=\"app.contents_dir\">...</parameter>\n</parameters> <services>\n<service id=\"App\\Service\\MessageGenerator\">\n<argument key=\"$contentsDir\">%app.contents_dir%</argument>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator; return static function (ContainerConfigurator $container): void {\n$container->parameters()\n->set('app.contents_dir', '...'); $container->services()\n->get(MessageGenerator::class)\n->arg('$contentsDir', '%app.contents_dir%');\n}; If you inject the same parameters over and over again, use the\nservices._defaults.bind option instead. The arguments defined in that option are\ninjected automatically whenever a service constructor or controller action\ndefines an argument with that exact name. For example, to inject the value of the\nkernel.project_dir parameter\nwhenever a service/controller defines a $projectDir argument, use this: # config/services.yaml\nservices:\n_defaults:\nbind:\n# pass this value to any $projectDir argument for any service\n# that's created in this file (including controller arguments)\n$projectDir: '%kernel.project_dir%' # ... <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<defaults autowire=\"true\" autoconfigure=\"true\" public=\"false\">\n<!-- pass this value to any $projectDir argument for any service\nthat's created in this file (including controller arguments) -->\n<bind key=\"$projectDir\">%kernel.project_dir%</bind>\n</defaults> <!-- ... -->\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return static function (ContainerConfigurator $container): void {\n$container->services()\n->defaults()\n// pass this value to any $projectDir argument for any service\n// that's created in this file (including controller arguments)\n->bind('$projectDir', '%kernel.project_dir%'); // ...\n}; Read the article about binding arguments by name and/or type\nto learn more about this powerful feature. Finally, if some service needs access to lots of parameters, instead of\ninjecting each of them individually, you can inject all the application\nparameters at once by type-hinting any of its constructor arguments with the\nSymfony\\\\Component\\\\DependencyInjection\\\\ParameterBag\\\\ContainerBagInterface:: // src/Service/MessageGenerator.php\nnamespace App\\Service; // ... use Symfony\\Component\\DependencyInjection\\ParameterBag\\ContainerBagInterface; class MessageGenerator\n{\npublic function __construct(\nprivate ContainerBagInterface $params,\n) {\n} public function someMethod(): void\n{\n// get any container parameter from $this->params, which stores all of them\n$sender = $this->params->get('mailer_sender');\n// ...\n}\n} Using PHP ConfigBuilders Writing PHP config is sometimes difficult because you end up with large nested\narrays and you have no autocompletion help from your favorite IDE. A way to\naddress this is to use \"ConfigBuilders\". They are objects that will help you\nbuild these arrays. Symfony generates the ConfigBuilder classes automatically in the\nkernel build directory for all the\nbundles installed in your application. By convention they all live in the\nnamespace Symfony\\Config:: // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n$security->firewall('main')\n->pattern('^/*')\n->lazy(true)\n->security(false); $security\n->roleHierarchy('ROLE_ADMIN', ['ROLE_USER'])\n->roleHierarchy('ROLE_SUPER_ADMIN', ['ROLE_ADMIN', 'ROLE_ALLOWED_TO_SWITCH'])\n->accessControl()\n->path('^/user')\n->roles('ROLE_USER'); $security->accessControl(['path' => '^/admin', 'roles' => 'ROLE_ADMIN']);\n};", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_sem_10", "source": "configuration.rst", "text": "Only root classes in the namespace Symfony\\Config are ConfigBuilders.\nNested configs (e.g. \\Symfony\\Config\\Framework\\CacheConfig) are regular\nPHP objects which aren't autowired when using them as an argument type. In order to get ConfigBuilders autocompletion in your IDE/editor, make sure\nto not exclude the directory where these classes are generated (by default,\nin var/cache/dev/Symfony/Config/). Keep Going! Congratulations! You've tackled the basics of Symfony. Next, learn about *each*\npart of Symfony individually by following the guides. Check out: * /forms\n* /doctrine\n* /service_container\n* /security\n* /mailer\n* /logging And all the other topics related to configuration: :maxdepth: 1\n:glob: configuration/*", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "console.rst_sem_0", "source": "console.rst", "text": "Console Commands The Symfony framework provides lots of commands through the bin/console script\n(e.g. the well-known bin/console cache:clear command). These commands are\ncreated with the Console component . You can also\nuse it to create your own commands. Running Commands Each Symfony application comes with a large set of commands. You can use\nthe list command to view all available commands in the application: $ php bin/console list\n... Available commands:\nabout Display information about the current project\ncompletion Dump the shell completion script\nhelp Display help for a command\nlist List commands\nassets\nassets:install Install bundle's web assets under a public directory\ncache\ncache:clear Clear the cache\n... list is the default command, so running php bin/console is the same. If you find the command you need, you can run it with the --help option\nto view the command's documentation: $ php bin/console assets:install --help --help is one of the built-in global options from the Console component,\nwhich are available for all commands, including those you can create.\nTo learn more about them, you can read\nthis section . APP_ENV & APP_DEBUG Console commands run in the environment defined in the APP_ENV\nvariable of the .env file, which is dev by default. It also reads the APP_DEBUG\nvalue to turn \"debug\" mode on or off (it defaults to 1, which is on). To run the command in another environment or debug mode, edit the value of APP_ENV\nand APP_DEBUG. You can also define this env vars when running the\ncommand, for instance: # clears the cache for the prod environment\n$ APP_ENV=prod php bin/console cache:clear Console Completion If you are using the Bash, Zsh or Fish shell, you can install Symfony's\ncompletion script to get auto completion when typing commands in the\nterminal. All commands support name and option completion, and some can\neven complete values. :alt: The terminal completes the command name \"secrets:remove\" and the argument \"SOME_OTHER_SECRET\". First, you have to install the completion script *once*. Run\nbin/console completion --help for the installation instructions for\nyour shell. When using Bash, make sure you installed and setup the \"bash completion\"\npackage for your OS (typically named bash-completion). After installing and restarting your terminal, you're all set to use\ncompletion (by default, by pressing the Tab key). Many PHP tools are built using the Symfony Console component (e.g.\nComposer, PHPstan and Behat). If they are using version 5.4 or higher,\nyou can also install their completion script to enable console completion: $ php vendor/bin/phpstan completion --help\n$ composer completion --help If you are using the Symfony CLI tool, follow\nthese instructions to enable autocompletion. Creating a Command Commands are defined in classes and auto-registered using the #[AsCommand]\nattribute. For example, you may want a command to create a user:: // src/Command/CreateUserCommand.php\nnamespace App\\Command; use Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Command\\Command; // the name of the command is what users type after \"php bin/console\"\n#[AsCommand(name: 'app:create-user')]\nclass CreateUserCommand\n{\npublic function __invoke(): int\n{\n// ... put here the code to create the user", "title": "Console Commands", "category": "console"}
{"chunk_id": "console.rst_sem_1", "source": "console.rst", "text": "// this method must return an integer number with the \"exit status code\"\n// of the command. You can also use these constants to make code more readable // return this if there was no problem running the command\n// (it's equivalent to returning int(0))\nreturn Command::SUCCESS; // or return this if some error happened during the execution\n// (it's equivalent to returning int(1))\n// return Command::FAILURE; // or return this to indicate incorrect command usage; e.g. invalid options\n// or missing arguments (it's equivalent to returning int(2))\n// return Command::INVALID\n}\n} Support for invokable commands that don't extend the base Command class\nwas introduced in Symfony 7.3 If you can't use PHP attributes, register the command as a service and\ntag it with the console.command tag. If you're using the\ndefault services.yaml configuration ,\nthis is already done for you, thanks to autoconfiguration . You can also use #[AsCommand] to add a description and longer help text for the command:: #[AsCommand(\nname: 'app:create-user',\ndescription: 'Creates a new user.', // the command description shown when running \"php bin/console list\"\nhelp: 'This command allows you to create a user...', // the command help shown when running the command with the \"--help\" option\n)]\nclass CreateUserCommand\n{\npublic function __invoke(): int\n{\n// ...\n}\n} Additionally, you can extend the Symfony\\\\Component\\\\Console\\\\Command\\\\Command class to\nleverage advanced features like lifecycle hooks (e.g. Symfony\\\\Component\\\\Console\\\\Command\\\\Command::initialize and\nand Symfony\\\\Component\\\\Console\\\\Command\\\\Command::interact):: use Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface; #[AsCommand(name: 'app:create-user')]\nclass CreateUserCommand extends Command\n{\npublic function initialize(InputInterface $input, OutputInterface $output): void\n{\n// ...\n} public function interact(InputInterface $input, OutputInterface $output): void\n{\n// ...\n} public function __invoke(): int\n{\n// ...\n}\n} Running the Command After configuring and registering the command, you can run it in the terminal: $ php bin/console app:create-user As you might expect, this command will do nothing as you didn't write any logic\nyet. Add your own logic inside the __invoke() method. Console Output The __invoke() method has access to the output stream to write messages to\nthe console:: // ...\npublic function __invoke(OutputInterface $output): int\n{\n// outputs multiple lines to the console (adding \"\\n\" at the end of each line)\n$output->writeln([\n'User Creator',\n'============',\n'',\n]); // the value returned by someMethod() can be an iterator (https://php.net/iterator)\n// that generates and returns the messages with the 'yield' PHP keyword\n$output->writeln($this->someMethod()); // outputs a message followed by a \"\\n\"\n$output->writeln('Whoa!'); // outputs a message without adding a \"\\n\" at the end of the line\n$output->write('You are about to ');\n$output->write('create a user.'); return Command::SUCCESS;\n} Now, try executing the command: $ php bin/console app:create-user\nUser Creator Whoa!\nYou are about to create a user. Output Sections The regular console output can be divided into multiple independent regions\ncalled \"output sections\". Create one or more of these sections when you need to\nclear and overwrite the output information. Sections are created with the\nConsoleOutput::section()\nmethod, which returns an instance of\nSymfony\\\\Component\\\\Console\\\\Output\\\\ConsoleSectionOutput:: // ...\nuse Symfony\\Component\\Console\\Output\\ConsoleOutputInterface;", "title": "Console Commands", "category": "console"}
{"chunk_id": "console.rst_sem_2", "source": "console.rst", "text": "#[AsCommand(name: 'app:my-command')]\nclass MyCommand\n{\npublic function __invoke(OutputInterface $output): int\n{\nif (!$output instanceof ConsoleOutputInterface) {\nthrow new \\LogicException('This command accepts only an instance of \"ConsoleOutputInterface\".');\n} $section1 = $output->section();\n$section2 = $output->section(); $section1->writeln('Hello');\n$section2->writeln('World!');\nsleep(1);\n// Output displays \"Hello\\nWorld!\\n\" // overwrite() replaces all the existing section contents with the given content\n$section1->overwrite('Goodbye');\nsleep(1);\n// Output now displays \"Goodbye\\nWorld!\\n\" // clear() deletes all the section contents...\n$section2->clear();\nsleep(1);\n// Output now displays \"Goodbye\\n\" // ...but you can also delete a given number of lines\n// (this example deletes the last two lines of the section)\n$section1->clear(2);\nsleep(1);\n// Output is now completely empty! // setting the max height of a section will make new lines replace the old ones\n$section1->setMaxHeight(2);\n$section1->writeln('Line1');\n$section1->writeln('Line2');\n$section1->writeln('Line3'); return Command::SUCCESS;\n}\n} A new line is appended automatically when displaying information in a section. Output sections let you manipulate the Console output in advanced ways, such as\ndisplaying multiple progress bars which\nare updated independently and appending rows to tables\nthat have already been rendered. Terminals only allow overwriting the visible content, so you must take into\naccount the console height when trying to write/overwrite section contents. Console Input Use input options or arguments to pass information to the command:: use Symfony\\Component\\Console\\Attribute\\Argument; // The #[Argument] attribute configures $username as a\n// required input argument and its value is automatically\n// passed to this parameter\npublic function __invoke(#[Argument('The username of the user.')] string $username, OutputInterface $output): int\n{\n$output->writeln([\n'User Creator',\n'============',\n'',\n]); $output->writeln('Username: '.$username); return Command::SUCCESS;\n} Now, you can pass the username to the command: $ php bin/console app:create-user Wouter\nUser Creator Username: Wouter Read /console/input for more information about console options and\narguments. Getting Services from the Service Container To actually create a new user, the command has to access some\nservices . Since your command is already registered\nas a service, you can use normal dependency injection. Imagine you have a\nApp\\Service\\UserManager service that you want to access:: // ...\nuse App\\Service\\UserManager;\nuse Symfony\\Component\\Console\\Attribute\\Argument;\nuse Symfony\\Component\\Console\\Attribute\\AsCommand; #[AsCommand(name: 'app:create-user')]\nclass CreateUserCommand\n{\npublic function __construct(\nprivate UserManager $userManager\n) {\n} public function __invoke(#[Argument] string $username, OutputInterface $output): int\n{\n// ... $this->userManager->create($username); $output->writeln('User successfully generated!'); return Command::SUCCESS;\n}\n} Command Lifecycle Commands have three lifecycle methods that are invoked when running the\ncommand: Symfony\\\\Component\\\\Console\\\\Command\\\\Command::initialize *(optional)*\nThis method is executed before the interact() and the execute()\nmethods. Its main purpose is to initialize variables used in the rest of\nthe command methods. Symfony\\\\Component\\\\Console\\\\Command\\\\Command::interact *(optional)*\nThis method is executed after initialize() and before execute().\nIts purpose is to check if some of the options/arguments are missing\nand interactively ask the user for those values. This is the last place\nwhere you can ask for missing required options/arguments. This method is\ncalled before validating the input.\nNote that it will not be called when the command is run without interaction\n(e.g. when passing the --no-interaction global option flag).", "title": "Console Commands", "category": "console"}
{"chunk_id": "console.rst_sem_3", "source": "console.rst", "text": "__invoke() (or Symfony\\\\Component\\\\Console\\\\Command\\\\Command::execute) *(required)*\nThis method is executed after interact() and initialize().\nIt contains the logic you want the command to execute and it must\nreturn an integer which will be used as the command `exit status`_. Testing Commands Symfony provides several tools to help you test your commands. The most\nuseful one is the Symfony\\\\Component\\\\Console\\\\Tester\\\\CommandTester\nclass. It uses special input and output classes to ease testing without a real\nconsole:: // tests/Command/CreateUserCommandTest.php\nnamespace App\\Tests\\Command; use Symfony\\Bundle\\FrameworkBundle\\Console\\Application;\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Symfony\\Component\\Console\\Tester\\CommandTester; class CreateUserCommandTest extends KernelTestCase\n{\npublic function testExecute(): void\n{\nself::bootKernel();\n$application = new Application(self::$kernel); $command = $application->find('app:create-user');\n$commandTester = new CommandTester($command);\n$commandTester->execute([\n// pass arguments to the helper\n'username' => 'Wouter', // prefix the key with two dashes when passing options,\n// e.g: '--some-option' => 'option_value',\n// use brackets for testing array value,\n// e.g: '--some-option' => ['option_value'],\n]); $commandTester->assertCommandIsSuccessful(); // the output of the command in the console\n$output = $commandTester->getDisplay();\n$this->assertStringContainsString('Username: Wouter', $output); // ...\n}\n} If you are using a single-command application ,\ncall setAutoExit(false) on it to get the command result in CommandTester. You can also test a whole console application by using\nSymfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester. When testing commands using the CommandTester class, console events are\nnot dispatched. If you need to test those events, use the\nSymfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester instead. When testing commands using the Symfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester\nclass, don't forget to disable the auto exit flag:: $application = new Application();\n$application->setAutoExit(false); $tester = new ApplicationTester($application); When testing InputOption::VALUE_NONE command options, you must pass true\nto them:: $commandTester = new CommandTester($command);\n$commandTester->execute(['--some-option' => true]); When using the Console component in a standalone project, use\nSymfony\\\\Component\\\\Console\\\\Application\nand extend the normal \\PHPUnit\\Framework\\TestCase. When testing your commands, it could be useful to understand how your command\nreacts on different settings like the width and the height of the terminal, or\neven the color mode being used. You have access to such information thanks to the\nSymfony\\\\Component\\\\Console\\\\Terminal class:: use Symfony\\Component\\Console\\Terminal; $terminal = new Terminal(); // gets the number of lines available\n$height = $terminal->getHeight(); // gets the number of columns available\n$width = $terminal->getWidth(); // gets the color mode\n$colorMode = $terminal->getColorMode(); // changes the color mode\n$colorMode = $terminal->setColorMode(AnsiColorMode::Ansi24); Logging Command Errors Whenever an exception is thrown while running commands, Symfony adds a log\nmessage for it including the entire failing command. In addition, Symfony\nregisters an event subscriber to listen to the\nConsoleEvents::TERMINATE event and adds a log\nmessage whenever a command doesn't finish with the 0 `exit status`_. Using Events And Handling Signals When a command is running, many events are dispatched, one of them allows to\nreact to signals, read more in this section . Profiling Commands Symfony allows to profile the execution of any command, including yours. First,\nmake sure that the debug mode and the profiler\nare enabled. Then, add the --profile option when running the command: $ php bin/console --profile app:my-command", "title": "Console Commands", "category": "console"}
{"chunk_id": "console.rst_sem_4", "source": "console.rst", "text": "Symfony will now collect data about the command execution, which is helpful to\ndebug errors or check other issues. When the command execution is over, the\nprofile is accessible through the web page of the profiler. If you run the command in verbose mode (adding the -v option), Symfony\nwill display in the output a clickable link to the command profile (if your\nterminal supports links). If you run it in debug verbosity (-vvv) you'll\nalso see the time and memory consumed by the command. When profiling the messenger:consume command from the Messenger\ncomponent, add the --no-reset option to the command or you won't get any\nprofile. Moreover, consider using the --limit option to only process a few\nmessages to make the profile more readable in the profiler. Learn More :maxdepth: 1\n:glob: console/* The console component also contains a set of \"helpers\" - different small\ntools capable of helping you with different tasks: * /components/console/helpers/questionhelper: interactively ask the user for information\n* /components/console/helpers/formatterhelper: customize the output colorization\n* /components/console/helpers/progressbar: shows a progress bar\n* /components/console/helpers/progressindicator: shows a progress indicator\n* /components/console/helpers/table: displays tabular data as a table\n* /components/console/helpers/debug_formatter: provides functions to\noutput debug information when running an external program\n* /components/console/helpers/processhelper: allows to run processes using DebugFormatterHelper\n* /components/console/helpers/cursor: allows to manipulate the cursor in the terminal\n* /components/console/helpers/tree: displays tree-like structures", "title": "Console Commands", "category": "console"}
{"chunk_id": "doctrine.rst_sem_0", "source": "doctrine.rst", "text": "Databases and the Doctrine ORM :class: screencast Do you prefer video tutorials? Check out the `Doctrine screencast series`_. Symfony provides all the tools you need to use databases in your applications\nthanks to `Doctrine`_, the best set of PHP libraries to work with databases.\nThese tools support relational databases like MySQL and PostgreSQL and also\nNoSQL databases like MongoDB. Databases are a broad topic, so the documentation is divided in three articles: * This article explains the recommended way to work with **relational databases**\nin Symfony applications;\n* Read this other article if you need **low-level access**\nto perform raw SQL queries to relational databases (similar to PHP's `PDO`_);\n* Read `DoctrineMongoDBBundle docs`_ if you are working with **MongoDB databases**. Installing Doctrine First, install Doctrine support via the orm Symfony pack ,\nas well as the MakerBundle, which will help generate some code: $ composer require symfony/orm-pack\n$ composer require --dev symfony/maker-bundle Configuring the Database The database connection information is stored as an environment variable called\nDATABASE_URL. For development, you can find and customize this inside .env: # .env (or override DATABASE_URL in .env.local to avoid committing your changes) # customize this line!\nDATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=8.0.37\" # to use mariadb:\n# Before doctrine/dbal < 3.7\n# DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=mariadb-10.5.8\"\n# Since doctrine/dbal 3.7\n# DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=10.5.8-MariaDB\" # to use sqlite:\n# DATABASE_URL=\"sqlite:///%kernel.project_dir%/var/app.db\" # to use postgresql:\n# DATABASE_URL=\"postgresql://db_user:db_password@127.0.0.1:5432/db_name?serverVersion=12.19 (Debian 12.19-1.pgdg120+1)&charset=utf8\" # to use oracle:\n# DATABASE_URL=\"oci8://db_user:db_password@127.0.0.1:1521/db_name\" If the username, password, host or database name contain any character considered\nspecial in a URI (such as : / ? # [ ] @ ! $ & ' ( ) * + , ; =),\nyou must encode them. See `RFC 3986`_ for the full list of reserved characters.\nYou can use the urlencode function to encode them or\nthe urlencode environment variable processor .\nIn this case you need to remove the resolve: prefix in config/packages/doctrine.yaml\nto avoid errors: url: '%env(DATABASE_URL)%' Now that your connection parameters are setup, Doctrine can create the db_name\ndatabase for you: $ php bin/console doctrine:database:create There are more options in config/packages/doctrine.yaml that you can configure,\nincluding your server_version (e.g. 8.0.37 if you're using MySQL 8.0.37), which may\naffect how Doctrine functions. There are many other Doctrine commands. Run php bin/console list doctrine\nto see a full list. Creating an Entity Class Suppose you're building an application where products need to be displayed.\nWithout even thinking about Doctrine or databases, you already know that\nyou need a Product object to represent those products. You can use the make:entity command to create this class and any fields you\nneed. The command will ask you some questions - answer them like done below: $ php bin/console make:entity Class name of the entity to create or update:\n> Product New property name (press <return> to stop adding fields):\n> name Field type (enter ? to see all types) [string]:\n> string Field length [255]:\n> 255 Can this field be null in the database (nullable) (yes/no) [no]:\n> no", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_sem_1", "source": "doctrine.rst", "text": "New property name (press <return> to stop adding fields):\n> price Field type (enter ? to see all types) [string]:\n> integer Can this field be null in the database (nullable) (yes/no) [no]:\n> no New property name (press <return> to stop adding fields):\n>\n(press enter again to finish) Whoa! You now have a new src/Entity/Product.php file:: // src/Entity/Product.php\nnamespace App\\Entity; use App\\Repository\\ProductRepository;\nuse Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity(repositoryClass: ProductRepository::class)]\nclass Product\n{\n#[ORM\\Id]\n#[ORM\\GeneratedValue]\n#[ORM\\Column]\nprivate ?int $id = null; #[ORM\\Column(length: 255)]\nprivate ?string $name = null; #[ORM\\Column]\nprivate ?int $price = null; public function getId(): ?int\n{\nreturn $this->id;\n} // ... getter and setter methods\n} Starting in `MakerBundle`_: v1.57.0 - You can pass either --with-uuid or\n--with-ulid to make:entity. Leveraging Symfony's Uid Component ,\nthis generates an entity with the id type as Uuid\nor Ulid instead of int. Starting in v1.44.0 - `MakerBundle`_: only supports entities using PHP attributes. Confused why the price is an integer? Don't worry: this is just an example.\nBut, storing prices as integers (e.g. 100 = $1 USD) can avoid rounding issues. There is a `limit of 767 bytes for the index key prefix`_ when using\nInnoDB tables in MySQL 5.6 and earlier versions. String columns with 255\ncharacter length and utf8mb4 encoding surpass that limit. This means\nthat any column of type string and unique=true must set its\nmaximum length to 190. Otherwise, you'll see this error:\n*\"[PDOException] SQLSTATE[42000]: Syntax error or access violation:\n1071 Specified key was too long; max key length is 767 bytes\"*. This class is called an \"entity\". And soon, you'll be able to save and query Product\nobjects to a product table in your database. Each property in the Product\nentity can be mapped to a column in that table. This is usually done with attributes:\nthe #[ORM\\Column(...)] comments that you see above each property: <object data=\"_images/doctrine/mapping_single_entity.svg\" type=\"image/svg+xml\"\nalt=\"Doctrine mapping between properties of a Product PHP object and the data in the product database table\"\n></object> The make:entity command is a tool to make life easier. But this is *your* code:\nadd/remove fields, add/remove methods or update configuration. Doctrine supports a wide variety of field types, each with their own options.\nCheck out the `list of Doctrine mapping types`_ in the Doctrine documentation.\nIf you want to use XML instead of attributes, add type: xml and\ndir: '%kernel.project_dir%/config/doctrine' to the entity mappings in your\nconfig/packages/doctrine.yaml file. Be careful not to use reserved SQL keywords as your table or column names\n(e.g. GROUP or USER). See Doctrine's `Reserved SQL keywords documentation`_\nfor details on how to escape these. Or, change the table name with\n#[ORM\\Table(name: 'groups')] above the class or configure the column name with\nthe name: 'group_name' option. Migrations: Creating the Database Tables/Schema The Product class is fully-configured and ready to save to a product table.\nIf you just defined this class, your database doesn't actually have the product\ntable yet. To add it, you can leverage the `DoctrineMigrationsBundle`_, which is\nalready installed:", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_sem_2", "source": "doctrine.rst", "text": "$ php bin/console make:migration Starting in `MakerBundle`_: v1.56.0 - Passing --formatted to make:migration\ngenerates a nice and tidy migration file. If everything worked, you should see something like this: SUCCESS! Next: Review the new migration \"migrations/Version20211116204726.php\"\nThen: Run the migration with php bin/console doctrine:migrations:migrate If you open this file, it contains the SQL needed to update your database! To run\nthat SQL, execute your migrations: $ php bin/console doctrine:migrations:migrate This command executes all migration files that have not already been run against\nyour database. You should run this command on production when you deploy to keep\nyour production database up-to-date. Migrations & Adding more Fields But what if you need to add a new field property to Product, like a\ndescription? You can edit the class to add the new property. But, you can\nalso use make:entity again: $ php bin/console make:entity Class name of the entity to create or update\n> Product New property name (press <return> to stop adding fields):\n> description Field type (enter ? to see all types) [string]:\n> text Can this field be null in the database (nullable) (yes/no) [no]:\n> no New property name (press <return> to stop adding fields):\n>\n(press enter again to finish) This adds the new description property and getDescription() and setDescription()\nmethods: // src/Entity/Product.php\n// ...\n+ use Doctrine\\DBAL\\Types\\Types; class Product\n{\n// ... + #[ORM\\Column(type: Types::TEXT)]\n+ private string $description; // getDescription() & setDescription() were also added\n} The new property is mapped, but it doesn't exist yet in the product table. No\nproblem! Generate a new migration: $ php bin/console make:migration This time, the SQL in the generated file will look like this: ALTER TABLE product ADD description LONGTEXT NOT NULL The migration system is *smart*. It compares all of your entities with the current\nstate of the database and generates the SQL needed to synchronize them! Like\nbefore, execute your migrations: $ php bin/console doctrine:migrations:migrate If you are using an SQLite database, you'll see the following error:\n*PDOException: SQLSTATE[HY000]: General error: 1 Cannot add a NOT NULL\ncolumn with default value NULL*. Add a nullable=true option to the\ndescription property to fix the problem. This will only execute the *one* new migration file, because DoctrineMigrationsBundle\nknows that the first migration was already executed earlier. Behind the scenes, it\nmanages a migration_versions table to track this. Each time you make a change to your schema, run these two commands to generate the\nmigration and then execute it. Be sure to commit the migration files and execute\nthem when you deploy. If you prefer to add new properties manually, the make:entity command can\ngenerate the getter & setter methods for you: $ php bin/console make:entity --regenerate If you make some changes and want to regenerate *all* getter/setter methods,\nalso pass --overwrite. Persisting Objects to the Database It's time to save a Product object to the database! Let's create a new controller\nto experiment: $ php bin/console make:controller ProductController", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_sem_3", "source": "doctrine.rst", "text": "Inside the controller, you can create a new Product object, set data on it,\nand save it:: // src/Controller/ProductController.php\nnamespace App\\Controller; // ...\nuse App\\Entity\\Product;\nuse Doctrine\\ORM\\EntityManagerInterface;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class ProductController extends AbstractController\n{\n#[Route('/product', name: 'create_product')]\npublic function createProduct(EntityManagerInterface $entityManager): Response\n{\n$product = new Product();\n$product->setName('Keyboard');\n$product->setPrice(1999);\n$product->setDescription('Ergonomic and stylish!'); // tell Doctrine you want to (eventually) save the Product (no queries yet)\n$entityManager->persist($product); // actually executes the queries (i.e. the INSERT query)\n$entityManager->flush(); return new Response('Saved new product with id '.$product->getId());\n}\n} Try it out! http://localhost:8000/product Congratulations! You just created your first row in the product table. To prove it,\nyou can query the database directly: $ php bin/console dbal:run-sql 'SELECT * FROM product' # on Windows systems not using Powershell, run this command instead:\n# php bin/console dbal:run-sql \"SELECT * FROM product\" Take a look at the previous example in more detail: * **line 13** The EntityManagerInterface $entityManager argument tells Symfony\nto inject the Entity Manager service into\nthe controller method. This object is responsible for saving objects to, and\nfetching objects from, the database. * **lines 15-18** In this section, you instantiate and work with the $product\nobject like any other normal PHP object. * **line 21** The persist($product) call tells Doctrine to \"manage\" the\n$product object. This does **not** cause a query to be made to the database. * **line 24** When the flush() method is called, Doctrine looks through\nall of the objects that it's managing to see if they need to be persisted\nto the database. In this example, the $product object's data doesn't\nexist in the database, so the entity manager executes an INSERT query,\ncreating a new row in the product table. If the flush() call fails, a Doctrine\\ORM\\ORMException exception\nis thrown. See `Transactions and Concurrency`_. Whether you're creating or updating objects, the workflow is always the same: Doctrine\nis smart enough to know if it should INSERT or UPDATE your entity. Validating Objects The Symfony validator can reuse Doctrine metadata to perform\nsome basic validation tasks. First, add or configure the\nauto_mapping option to define which\nentities should be introspected by Symfony to add automatic validation constraints. Consider the following controller code:: // src/Controller/ProductController.php\nnamespace App\\Controller; use App\\Entity\\Product;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n// ... class ProductController extends AbstractController\n{\n#[Route('/product', name: 'create_product')]\npublic function createProduct(ValidatorInterface $validator): Response\n{\n$product = new Product(); // ... update the product data somehow (e.g. with a form) ... $errors = $validator->validate($product);\nif (count($errors) > 0) {\nreturn new Response((string) $errors, 400);\n} // ...\n}\n} Although the Product entity doesn't define any explicit\nvalidation configuration , if the auto_mapping option\nincludes it in the list of entities to introspect, Symfony will infer some\nvalidation rules for it and will apply them. For example, given that the name property can't be null in the database, a\nNotNull constraint is added automatically\nto the property (if it doesn't contain that constraint already).", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_sem_4", "source": "doctrine.rst", "text": "The following table summarizes the mapping between Doctrine metadata and\nthe corresponding validation constraints added automatically by Symfony: ================== ========================================================= =====\nDoctrine attribute Validation constraint Notes\n================== ========================================================= =====\nnullable=false NotNull Requires installing the PropertyInfo component\ntype Type Requires installing the PropertyInfo component\nunique=true UniqueEntity\nlength Length\n================== ========================================================= ===== Because the Form component as well as `API Platform`_ internally\nuse the Validator component, all your forms and web APIs will also automatically\nbenefit from these automatic validation constraints. This automatic validation is a nice feature to improve your productivity, but it\ndoesn't replace the validation configuration entirely. You still need to add\nsome validation constraints to ensure that data\nprovided by the user is correct. Fetching Objects from the Database Fetching an object back out of the database is even easier. Suppose you want to\nbe able to go to /product/1 to see your new product:: // src/Controller/ProductController.php\nnamespace App\\Controller; use App\\Entity\\Product;\nuse Doctrine\\ORM\\EntityManagerInterface;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\n// ... class ProductController extends AbstractController\n{\n#[Route('/product/{id}', name: 'product_show')]\npublic function show(EntityManagerInterface $entityManager, int $id): Response\n{\n$product = $entityManager->getRepository(Product::class)->find($id); if (!$product) {\nthrow $this->createNotFoundException(\n'No product found for id '.$id\n);\n} return new Response('Check out this great product: '.$product->getName()); // or render a template\n// in the template, print things with {{ product.name }}\n// return $this->render('product/show.html.twig', ['product' => $product]);\n}\n} Another possibility is to use the ProductRepository using Symfony's autowiring\nand injected by the dependency injection container:: // src/Controller/ProductController.php\nnamespace App\\Controller; use App\\Entity\\Product;\nuse App\\Repository\\ProductRepository;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\n// ... class ProductController extends AbstractController\n{\n#[Route('/product/{id}', name: 'product_show')]\npublic function show(ProductRepository $productRepository, int $id): Response\n{\n$product = $productRepository\n->find($id); // ...\n}\n} Try it out! http://localhost:8000/product/1 When you query for a particular type of object, you always use what's known\nas its \"repository\". You can think of a repository as a PHP class whose only\njob is to help you fetch entities of a certain class. Once you have a repository object, you have many helper methods:: $repository = $entityManager->getRepository(Product::class); // look for a single Product by its primary key (usually \"id\")\n$product = $repository->find($id); // look for a single Product by name\n$product = $repository->findOneBy(['name' => 'Keyboard']);\n// or find by name and price\n$product = $repository->findOneBy([\n'name' => 'Keyboard',\n'price' => 1999,\n]); // look for multiple Product objects matching the name, ordered by price\n$products = $repository->findBy(\n['name' => 'Keyboard'],\n['price' => 'ASC']\n); // look for *all* Product objects\n$products = $repository->findAll(); You can also add *custom* methods for more complex queries! More on that later in\nthe doctrine-queries section. When rendering an HTML page, the web debug toolbar at the bottom of the page\nwill display the number of queries and the time it took to execute them: :alt: The web dev toolbar showing the Doctrine item.\n:class: with-browser", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_sem_5", "source": "doctrine.rst", "text": "If the number of database queries is too high, the icon will turn yellow to\nindicate that something may not be correct. Click on the icon to open the\nSymfony Profiler and see the exact queries that were executed. If you don't\nsee the web debug toolbar, install the profiler Symfony pack\nby running this command: composer require --dev symfony/profiler-pack. For more information, read the Symfony profiler documentation . Automatically Fetching Objects (EntityValueResolver) Autowiring of the EntityValueResolver was introduced in DoctrineBundle 2.7.1. In many cases, you can use the EntityValueResolver to do the query for you\nautomatically! You can simplify the controller to:: // src/Controller/ProductController.php\nnamespace App\\Controller; use App\\Entity\\Product;\nuse App\\Repository\\ProductRepository;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\n// ... class ProductController extends AbstractController\n{\n#[Route('/product/{id}')]\npublic function show(Product $product): Response\n{\n// use the Product!\n// ...\n}\n} That's it! The attribute uses the {id} from the route to query for the Product\nby the id column. If it's not found, a 404 error is thrown. You can change this behavior by making the controller argument optional. In that\ncase, no 404 is thrown automatically and you're free to handle the missing entity\nyourself:: #[Route('/product/{id}')]\npublic function show(?Product $product): Response\n{\nif (null === $product) {\n// run your own logic to return a custom response\n} // ...\n} When enabled globally, it's possible to disable the behavior on a specific\ncontroller, by using the MapEntity set to disabled:: public function show(\n#[CurrentUser]\n#[MapEntity(disabled: true)]\nUser $user\n): Response {\n// User is not resolved by the EntityValueResolver\n// ...\n} Fetch Automatically If your route wildcards match properties on your entity, then the resolver\nwill automatically fetch them:: /**\n* Fetch via primary key because {id} is in the route.\n*/\n#[Route('/product/{id}')]\npublic function showByPk(Product $product): Response\n{\n} /**\n* Perform a findOneBy() where the slug property matches {slug}.\n*/\n#[Route('/product/{slug:product}')]\npublic function showBySlug(Product $product): Response\n{\n} Automatic fetching works in these situations: * If {id} is in your route, then this is used to fetch by\nprimary key via the find() method. * The resolver will attempt to do a findOneBy() fetch by using\n*all* of the wildcards in your route that are actually properties\non your entity (non-properties are ignored). The {slug:product} syntax maps the route parameter named slug to the\ncontroller argument named $product. It also hints the resolver to look up\nthe corresponding Product object from the database using the slug. Route parameter mapping was introduced in Symfony 7.1. You can also configure the mapping explicitly for any controller argument\nusing the MapEntity attribute. You can even control the behavior of the\nEntityValueResolver by using the `MapEntity options`_ :: // src/Controller/ProductController.php\nnamespace App\\Controller; use App\\Entity\\Product;\nuse Symfony\\Bridge\\Doctrine\\Attribute\\MapEntity;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\n// ... class ProductController extends AbstractController\n{\n#[Route('/product/{slug}')]\npublic function show(\n#[MapEntity(mapping: ['slug' => 'slug'])]\nProduct $product\n): Response {\n// use the Product!\n// ...\n}\n} Fetch via an Expression", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_sem_6", "source": "doctrine.rst", "text": "If automatic fetching doesn't work for your use case, you can write an expression\nusing the ExpressionLanguage component :: #[Route('/product/{product_id}')]\npublic function show(\n#[MapEntity(expr: 'repository.find(product_id)')]\nProduct $product\n): Response {\n} In the expression, the repository variable will be your entity's\nRepository class and any route wildcards - like {product_id} are\navailable as variables. The repository method called in the expression can also return a list of entities.\nIn that case, update the type of your controller argument:: #[Route('/posts_by/{author_id}')]\npublic function authorPosts(\n#[MapEntity(class: Post::class, expr: 'repository.findBy({\"author\": author_id}, {}, 10)')]\niterable $posts\n): Response {\n} The mapping of the lists of entities was introduced in Symfony 7.1. This can also be used to help resolve multiple arguments:: #[Route('/product/{id}/comments/{comment_id}')]\npublic function show(\nProduct $product,\n#[MapEntity(expr: 'repository.find(comment_id)')]\nComment $comment\n): Response {\n} In the example above, the $product argument is handled automatically,\nbut $comment is configured with the attribute since they cannot both follow\nthe default convention. If you need to get other information from the request to query the database, you\ncan also access the request in your expression thanks to the request\nvariable. Let's say you want the first or the last comment of a product depending on a query parameter named sort:: #[Route('/product/{id}/comments')]\npublic function show(\nProduct $product,\n#[MapEntity(expr: 'repository.findOneBy({\"product\": id}, {\"createdAt\": request.query.get(\"sort\", \"DESC\")})')]\nComment $comment\n): Response {\n} Fetch via Interfaces Suppose your Product class implements an interface called ProductInterface.\nIf you want to decouple your controllers from the concrete entity implementation,\nyou can reference the entity by its interface instead. To enable this, first configure the\nresolve_target_entities option .\nThen, your controller can type-hint the interface, and the entity will be\nresolved automatically:: public function show(\n#[MapEntity]\nProductInterface $product\n): Response {\n// ...\n} Support for target entity resolution in the EntityValueResolver was\nintroduced Symfony 7.3 MapEntity Options A number of options are available on the MapEntity attribute to\ncontrol behavior: id\nIf an id option is configured and matches a route parameter, then\nthe resolver will find by the primary key:: #[Route('/product/{product_id}')]\npublic function show(\n#[MapEntity(id: 'product_id')]\nProduct $product\n): Response {\n} mapping\nConfigures the properties and values to use with the findOneBy()\nmethod: the key is the route placeholder name and the value is the Doctrine\nproperty name:: #[Route('/product/{category}/{slug}/comments/{comment_slug}')]\npublic function show(\n#[MapEntity(mapping: ['category' => 'category', 'slug' => 'slug'])]\nProduct $product,\n#[MapEntity(mapping: ['comment_slug' => 'slug'])]\nComment $comment\n): Response {\n} stripNull\nIf true, then when findOneBy() is used, any values that are\nnull will not be used for the query. objectManager\nBy default, the EntityValueResolver uses the *default*\nobject manager, but you can configure this:: #[Route('/product/{id}')]\npublic function show(\n#[MapEntity(objectManager: 'foo')]\nProduct $product\n): Response {\n} evictCache\nIf true, forces Doctrine to always fetch the entity from the database\ninstead of cache. disabled\nIf true, the EntityValueResolver will not try to replace the argument. message\nAn optional custom message displayed when there's a Symfony\\\\Component\\\\HttpKernel\\\\Exception\\\\NotFoundHttpException,\nbut **only in the development environment** (you won't see this message in production)::", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_sem_7", "source": "doctrine.rst", "text": "#[Route('/product/{product_id}')]\npublic function show(\n#[MapEntity(id: 'product_id', message: 'The product does not exist')]\nProduct $product\n): Response {\n} The message option was introduced in Symfony 7.1. Updating an Object Once you've fetched an object from Doctrine, you interact with it the same as\nwith any PHP model:: // src/Controller/ProductController.php\nnamespace App\\Controller; use App\\Entity\\Product;\nuse App\\Repository\\ProductRepository;\nuse Doctrine\\ORM\\EntityManagerInterface;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\n// ... class ProductController extends AbstractController\n{\n#[Route('/product/edit/{id}', name: 'product_edit')]\npublic function update(EntityManagerInterface $entityManager, int $id): Response\n{\n$product = $entityManager->getRepository(Product::class)->find($id); if (!$product) {\nthrow $this->createNotFoundException(\n'No product found for id '.$id\n);\n} $product->setName('New product name!');\n$entityManager->flush(); return $this->redirectToRoute('product_show', [\n'id' => $product->getId()\n]);\n}\n} Using Doctrine to edit an existing product consists of three steps: #. fetching the object from Doctrine;\n#. modifying the object;\n#. calling flush() on the entity manager. You *can* call $entityManager->persist($product), but it isn't necessary:\nDoctrine is already \"watching\" your object for changes. Deleting an Object Deleting an object is very similar, but requires a call to the remove()\nmethod of the entity manager:: $entityManager->remove($product);\n$entityManager->flush(); As you might expect, the remove() method notifies Doctrine that you'd\nlike to remove the given object from the database. The DELETE query isn't\nactually executed until the flush() method is called. Querying for Objects: The Repository You've already seen how the repository object allows you to run basic queries\nwithout any work:: // from inside a controller\n$repository = $entityManager->getRepository(Product::class);\n$product = $repository->find($id); But what if you need a more complex query? When you generated your entity with\nmake:entity, the command *also* generated a ProductRepository class:: // src/Repository/ProductRepository.php\nnamespace App\\Repository; use App\\Entity\\Product;\nuse Doctrine\\Bundle\\DoctrineBundle\\Repository\\ServiceEntityRepository;\nuse Doctrine\\Persistence\\ManagerRegistry; class ProductRepository extends ServiceEntityRepository\n{\npublic function __construct(ManagerRegistry $registry)\n{\nparent::__construct($registry, Product::class);\n}\n} When you fetch your repository (i.e. ->getRepository(Product::class)), it is\n*actually* an instance of *this* object! This is because of the repositoryClass\nconfig that was generated at the top of your Product entity class. Suppose you want to query for all Product objects greater than a certain price. Add\na new method for this to your repository:: // src/Repository/ProductRepository.php // ...\nclass ProductRepository extends ServiceEntityRepository\n{\npublic function __construct(ManagerRegistry $registry)\n{\nparent::__construct($registry, Product::class);\n} /**\n* @return Product[]\n*/\npublic function findAllGreaterThanPrice(int $price): array\n{\n$entityManager = $this->getEntityManager(); $query = $entityManager->createQuery(\n'SELECT p\nFROM App\\Entity\\Product p\nWHERE p.price > :price\nORDER BY p.price ASC'\n)->setParameter('price', $price); // returns an array of Product objects\nreturn $query->getResult();\n}\n} The string passed to createQuery() might look like SQL, but it is\n`Doctrine Query Language`_. This allows you to type queries using commonly\nknown query language, but referencing PHP objects instead (i.e. in the FROM\nstatement). Now, you can call this method on the repository:: // from inside a controller\n$minPrice = 1000; $products = $entityManager->getRepository(Product::class)->findAllGreaterThanPrice($minPrice); // ... See services-constructor-injection for how to inject the repository into\nany service. Querying with the Query Builder", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_sem_8", "source": "doctrine.rst", "text": "Doctrine also provides a `Query Builder`_, an object-oriented way to write\nqueries. It is recommended to use this when queries are built dynamically (i.e.\nbased on PHP conditions):: // src/Repository/ProductRepository.php // ...\nclass ProductRepository extends ServiceEntityRepository\n{\npublic function findAllGreaterThanPrice(int $price, bool $includeUnavailableProducts = false): array\n{\n// automatically knows to select Products\n// the \"p\" is an alias you'll use in the rest of the query\n$qb = $this->createQueryBuilder('p')\n->where('p.price > :price')\n->setParameter('price', $price)\n->orderBy('p.price', 'ASC'); if (!$includeUnavailableProducts) {\n$qb->andWhere('p.available = TRUE');\n} $query = $qb->getQuery(); return $query->execute(); // to get just one result:\n// $product = $query->setMaxResults(1)->getOneOrNullResult();\n}\n} Querying with SQL In addition, you can query directly with SQL if you need to:: // src/Repository/ProductRepository.php // ...\nclass ProductRepository extends ServiceEntityRepository\n{\npublic function findAllGreaterThanPrice(int $price): array\n{\n$conn = $this->getEntityManager()->getConnection(); $sql = '\nSELECT * FROM product p\nWHERE p.price > :price\nORDER BY p.price ASC\n'; $resultSet = $conn->executeQuery($sql, ['price' => $price]); // returns an array of arrays (i.e. a raw data set)\nreturn $resultSet->fetchAllAssociative();\n}\n} With SQL, you will get back raw data, not objects (unless you use the `NativeQuery`_\nfunctionality). Configuration See the Doctrine config reference . Relationships and Associations Doctrine provides all the functionality you need to manage database relationships\n(also known as associations), including ManyToOne, OneToMany, OneToOne and ManyToMany\nrelationships. For info, see /doctrine/associations. Database Testing Read the article about testing code that interacts with the database . Doctrine Extensions (Timestampable, Translatable, etc.) Doctrine community has created some extensions to implement common needs such as\n*\"set the value of the createdAt property automatically when creating an entity\"*.\nRead more about the `available Doctrine extensions`_ and use the\n`StofDoctrineExtensionsBundle`_ to integrate them in your application. Learn more :maxdepth: 1 doctrine/associations\ndoctrine/events\ndoctrine/custom_dql_functions\ndoctrine/dbal\ndoctrine/multiple_entity_managers\ndoctrine/resolve_target_entity\ntesting/database", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "event_dispatcher.rst_sem_0", "source": "event_dispatcher.rst", "text": "Events and Event Listeners During the execution of a Symfony application, lots of event notifications are\ntriggered. Your application can listen to these notifications and respond to\nthem by executing any piece of code. Symfony triggers several events related to the kernel\nwhile processing the HTTP Request. Third-party bundles may also dispatch events, and\nyou can even dispatch custom events from your\nown code. All the examples shown in this article use the same KernelEvents::EXCEPTION\nevent for consistency purposes. In your own application, you can use any event\nand even mix several of them in the same subscriber. Creating an Event Listener The most common way to listen to an event is to register an **event listener**:: // src/EventListener/ExceptionListener.php\nnamespace App\\EventListener; use Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent;\nuse Symfony\\Component\\HttpKernel\\Exception\\HttpExceptionInterface; class ExceptionListener\n{\npublic function __invoke(ExceptionEvent $event): void\n{\n// You get the exception object from the received event\n$exception = $event->getThrowable();\n$message = sprintf(\n'My Error says: %s with code: %s',\n$exception->getMessage(),\n$exception->getCode()\n); // Customize your response object to display the exception details\n$response = new Response();\n$response->setContent($message);\n// the exception message can contain unfiltered user input;\n// set the content-type to text to avoid XSS issues\n$response->headers->set('Content-Type', 'text/plain; charset=utf-8'); // HttpExceptionInterface is a special type of exception that\n// holds status code and header details\nif ($exception instanceof HttpExceptionInterface) {\n$response->setStatusCode($exception->getStatusCode());\n$response->headers->replace($exception->getHeaders());\n} else {\n$response->setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR);\n} // sends the modified response object to the event\n$event->setResponse($response);\n}\n} Now that the class is created, you need to register it as a service and\nnotify Symfony that it is an event listener by using a special \"tag\": # config/services.yaml\nservices:\nApp\\EventListener\\ExceptionListener:\ntags: [kernel.event_listener] <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<service id=\"App\\EventListener\\ExceptionListener\">\n<tag name=\"kernel.event_listener\"/>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\EventListener\\ExceptionListener; return function(ContainerConfigurator $container): void {\n$services = $container->services(); $services->set(ExceptionListener::class)\n->tag('kernel.event_listener')\n;\n}; Symfony follows this logic to decide which method to call inside the event\nlistener class: #. If the kernel.event_listener tag defines the method attribute, that's\nthe name of the method to be called;\n#. If no method attribute is defined, try to call the __invoke() magic\nmethod (which makes event listeners invokable);\n#. If the __invoke() method is not defined either, throw an exception. There is an optional attribute for the kernel.event_listener tag called\npriority, which is a positive or negative integer that defaults to 0\nand it controls the order in which listeners are executed (the higher the\nnumber, the earlier a listener is executed). This is useful when you need to\nguarantee that one listener is executed before another. The priorities of the\ninternal Symfony listeners usually range from -256 to 256 but your\nown listeners can use any positive or negative integer.", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_sem_1", "source": "event_dispatcher.rst", "text": "There is an optional attribute for the kernel.event_listener tag called\nevent which is useful when listener $event argument is not typed.\nIf you configure it, it will change type of $event object.\nFor the kernel.exception event, it is Symfony\\\\Component\\\\HttpKernel\\\\Event\\\\ExceptionEvent.\nCheck out the Symfony events reference to see\nwhat type of object each event provides. With this attribute, Symfony follows this logic to decide which method to call\ninside the event listener class: #. If the kernel.event_listener tag defines the method attribute, that's\nthe name of the method to be called;\n#. If no method attribute is defined, try to call the method whose name\nis on + \"PascalCased event name\" (e.g. onKernelException() method for\nthe kernel.exception event);\n#. If that method is not defined either, try to call the __invoke() magic\nmethod (which makes event listeners invokable);\n#. If the __invoke() method is not defined either, throw an exception. Defining Event Listeners with PHP Attributes An alternative way to define an event listener is to use the\nSymfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener\nPHP attribute. This allows you to configure the listener inside its class, without\nhaving to add any configuration in external files:: namespace App\\EventListener; use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; #[AsEventListener]\nfinal class MyListener\n{\npublic function __invoke(CustomEvent $event): void\n{\n// ...\n}\n} You can add multiple #[AsEventListener] attributes to configure different methods.\nThe method property is optional, and when not defined, it defaults to\non + uppercased event name. In the example below, the 'foo' event listener\ndoesn't explicitly define its method, so the onFoo() method will be called:: namespace App\\EventListener; use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; #[AsEventListener(event: CustomEvent::class, method: 'onCustomEvent')]\n#[AsEventListener(event: 'foo', priority: 42)]\n#[AsEventListener(event: 'bar', method: 'onBarEvent')]\nfinal class MyMultiListener\n{\npublic function onCustomEvent(CustomEvent $event): void\n{\n// ...\n} public function onFoo(): void\n{\n// ...\n} public function onBarEvent(): void\n{\n// ...\n}\n} Symfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener\ncan also be applied to methods directly:: namespace App\\EventListener; use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; final class MyMultiListener\n{\n#[AsEventListener]\npublic function onCustomEvent(CustomEvent $event): void\n{\n// ...\n} #[AsEventListener(event: 'foo', priority: 42)]\npublic function onFoo(): void\n{\n// ...\n} #[AsEventListener(event: 'bar')]\npublic function onBarEvent(): void\n{\n// ...\n}\n} Note that the attribute doesn't require its event parameter to be set\nif the method already type-hints the expected event. Creating an Event Subscriber Another way to listen to events is via an **event subscriber**, which is a class\nthat defines one or more methods that listen to one or various events. The main\ndifference with the event listeners is that subscribers always know the events\nto which they are listening. If different event subscriber methods listen to the same event, their order is\ndefined by the priority parameter. This value is a positive or negative\ninteger which defaults to 0. The higher the number, the earlier the method\nis called. **Priority is aggregated for all listeners and subscribers**, so your\nmethods could be called before or after the methods defined in other listeners\nand subscribers. To learn more about event subscribers, read /components/event_dispatcher.", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_sem_2", "source": "event_dispatcher.rst", "text": "The following example shows an event subscriber that defines several methods which\nlisten to the same kernel.exception event\nvia its ExceptionEvent class:: // src/EventSubscriber/ExceptionSubscriber.php\nnamespace App\\EventSubscriber; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent; class ExceptionSubscriber implements EventSubscriberInterface\n{\npublic static function getSubscribedEvents(): array\n{\n// return the subscribed events, their methods and priorities\nreturn [\nExceptionEvent::class => [\n['processException', 10],\n['logException', 0],\n['notifyException', -10],\n],\n];\n} public function processException(ExceptionEvent $event): void\n{\n// ...\n} public function logException(ExceptionEvent $event): void\n{\n// ...\n} public function notifyException(ExceptionEvent $event): void\n{\n// ...\n}\n} That's it! Your services.yaml file should already be setup to load services from\nthe EventSubscriber directory. Symfony takes care of the rest. If your methods are *not* called when an exception is thrown, double-check that\nyou're loading services from\nthe EventSubscriber directory and have autoconfigure\nenabled. You can also manually add the kernel.event_subscriber tag. Request Events, Checking Types A single page can make several requests (one main request, and then multiple\nsub-requests - typically when embedding controllers in templates ).\nFor the core Symfony events, you might need to check to see if the event is for\na \"main\" request or a \"sub request\":: // src/EventListener/RequestListener.php\nnamespace App\\EventListener; use Symfony\\Component\\HttpKernel\\Event\\RequestEvent; class RequestListener\n{\npublic function onKernelRequest(RequestEvent $event): void\n{\nif (!$event->isMainRequest()) {\n// don't do anything if it's not the main request\nreturn;\n} // ...\n}\n} Certain things, like checking information on the *real* request, may not need to\nbe done on the sub-request listeners. Listeners or Subscribers Listeners and subscribers can be used in the same application indistinctly. The\ndecision to use either of them is usually a matter of personal taste. However,\nthere are some minor advantages for each of them: * **Subscribers are easier to reuse** because the knowledge of the events is kept\nin the class rather than in the service definition. This is the reason why\nSymfony uses subscribers internally;\n* **Listeners are more flexible** because bundles can enable or disable each of\nthem conditionally depending on some configuration value. Event Aliases When configuring event listeners and subscribers via dependency injection,\nSymfony's core events can also be referred to by the fully qualified class\nname (FQCN) of the corresponding event class:: // src/EventSubscriber/RequestSubscriber.php\nnamespace App\\EventSubscriber; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent; class RequestSubscriber implements EventSubscriberInterface\n{\npublic static function getSubscribedEvents(): array\n{\nreturn [\nRequestEvent::class => 'onKernelRequest',\n];\n} public function onKernelRequest(RequestEvent $event): void\n{\n// ...\n}\n} Internally, the event FQCN are treated as aliases for the original event names.\nSince the mapping already happens when compiling the service container, event\nlisteners and subscribers using FQCN instead of event names will appear under\nthe original event name when inspecting the event dispatcher. This alias mapping can be extended for custom events by registering the\ncompiler pass AddEventAliasesPass:: // src/Kernel.php\nnamespace App; use App\\Event\\MyCustomEvent;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\EventDispatcher\\DependencyInjection\\AddEventAliasesPass;\nuse Symfony\\Component\\HttpKernel\\Kernel as BaseKernel; class Kernel extends BaseKernel\n{\nprotected function build(ContainerBuilder $container): void\n{\n$container->addCompilerPass(new AddEventAliasesPass([\nMyCustomEvent::class => 'my_custom_event',\n]));\n}\n}", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_sem_3", "source": "event_dispatcher.rst", "text": "The compiler pass will always extend the existing list of aliases. Because of\nthat, it is safe to register multiple instances of the pass with different\nconfigurations. Debugging Event Listeners You can find out what listeners are registered in the event dispatcher\nusing the console. To show all events and their listeners, run: $ php bin/console debug:event-dispatcher You can get registered listeners for a particular event by specifying\nits name: $ php bin/console debug:event-dispatcher kernel.exception or can get everything which partial matches the event name: $ php bin/console debug:event-dispatcher kernel // matches \"kernel.exception\", \"kernel.response\" etc.\n$ php bin/console debug:event-dispatcher Security // matches \"Symfony\\Component\\Security\\Http\\Event\\CheckPassportEvent\" The security system uses an event dispatcher per\nfirewall. Use the --dispatcher option to get the registered listeners\nfor a particular event dispatcher: $ php bin/console debug:event-dispatcher --dispatcher=security.event_dispatcher.main How to Set Up Before and After Filters It is quite common in web application development to need some logic to be\nperformed right before or directly after your controller actions acting as\nfilters or hooks. Some web frameworks define methods like preExecute() and postExecute(),\nbut there is no such thing in Symfony. The good news is that there is a much\nbetter way to interfere with the Request -> Response process using the\nEventDispatcher component . Token Validation Example Imagine that you need to develop an API where some controllers are public\nbut some others are restricted to one or some clients. For these private features,\nyou might provide a token to your clients to identify themselves. So, before executing your controller action, you need to check if the action\nis restricted or not. If it is restricted, you need to validate the provided\ntoken. Please note that for simplicity in this recipe, tokens will be defined\nin config and neither database setup nor authentication via the Security\ncomponent will be used. Before Filters with the kernel.controller Event First, define some token configuration as parameters: # config/services.yaml\nparameters:\ntokens:\nclient1: pass1\nclient2: pass2 <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters>\n<parameter key=\"tokens\" type=\"collection\">\n<parameter key=\"client1\">pass1</parameter>\n<parameter key=\"client2\">pass2</parameter>\n</parameter>\n</parameters>\n</container> // config/services.php\n$container->setParameter('tokens', [\n'client1' => 'pass1',\n'client2' => 'pass2',\n]); Tag Controllers to Be Checked\n............................. A kernel.controller (aka KernelEvents::CONTROLLER) listener gets notified\non *every* request, right before the controller is executed. So, first, you need\nsome way to identify if the controller that matches the request needs token validation. A clean and simple way is to create an empty interface and make the controllers\nimplement it:: namespace App\\Controller; interface TokenAuthenticatedController\n{\n// ...\n} A controller that implements this interface looks like this:: namespace App\\Controller; use App\\Controller\\TokenAuthenticatedController;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response; class FooController extends AbstractController implements TokenAuthenticatedController\n{\n// An action that needs authentication\npublic function bar(): Response\n{\n// ...\n}\n} Creating an Event Subscriber\n............................", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_sem_4", "source": "event_dispatcher.rst", "text": "Next, you'll need to create an event subscriber, which will hold the logic\nthat you want to be executed before your controllers. If you're not familiar with\nevent subscribers, you can learn more about how to use them :: // src/EventSubscriber/TokenSubscriber.php\nnamespace App\\EventSubscriber; use App\\Controller\\TokenAuthenticatedController;\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\HttpKernel\\Exception\\AccessDeniedHttpException;\nuse Symfony\\Component\\HttpKernel\\KernelEvents; class TokenSubscriber implements EventSubscriberInterface\n{\npublic function __construct(\nprivate array $tokens\n) {\n} public function onKernelController(ControllerEvent $event): void\n{\n$controller = $event->getController(); // when a controller class defines multiple action methods, the controller\n// is returned as [$controllerInstance, 'methodName']\nif (is_array($controller)) {\n$controller = $controller[0];\n} if ($controller instanceof TokenAuthenticatedController) {\n$token = $event->getRequest()->query->get('token');\nif (!in_array($token, $this->tokens)) {\nthrow new AccessDeniedHttpException('This action needs a valid token!');\n}\n}\n} public static function getSubscribedEvents(): array\n{\nreturn [\nKernelEvents::CONTROLLER => 'onKernelController',\n];\n}\n} That's it! Your services.yaml file should already be setup to load services from\nthe EventSubscriber directory. Symfony takes care of the rest. Your\nTokenSubscriber onKernelController() method will be executed on each request.\nIf the controller that is about to be executed implements TokenAuthenticatedController,\ntoken authentication is applied. This lets you have a \"before\" filter on any controller\nyou want. If your subscriber is *not* called on each request, double-check that\nyou're loading services from\nthe EventSubscriber directory and have autoconfigure\nenabled. You can also manually add the kernel.event_subscriber tag. After Filters with the kernel.response Event In addition to having a \"hook\" that's executed *before* your controller, you\ncan also add a hook that's executed *after* your controller. For this example,\nimagine that you want to add a sha1 hash (with a salt using that token) to\nall responses that have passed this token authentication. Another core Symfony event - called kernel.response (aka KernelEvents::RESPONSE) -\nis notified on every request, but after the controller returns a Response object.\nTo create an \"after\" listener, create a listener class and register\nit as a service on this event. For example, take the TokenSubscriber from the previous example and first\nrecord the authentication token inside the request attributes. This will\nserve as a basic flag that this request underwent token authentication:: public function onKernelController(ControllerEvent $event): void\n{\n// ... if ($controller instanceof TokenAuthenticatedController) {\n$token = $event->getRequest()->query->get('token');\nif (!in_array($token, $this->tokens)) {\nthrow new AccessDeniedHttpException('This action needs a valid token!');\n} // mark the request as having passed token authentication\n$event->getRequest()->attributes->set('auth_token', $token);\n}\n} Now, configure the subscriber to listen to another event and add onKernelResponse().\nThis will look for the auth_token flag on the request object and set a custom\nheader on the response if it's found:: // add the new use statement at the top of your file\nuse Symfony\\Component\\HttpKernel\\Event\\ResponseEvent; public function onKernelResponse(ResponseEvent $event): void\n{\n// check to see if onKernelController marked this as a token \"auth'ed\" request\nif (!$token = $event->getRequest()->attributes->get('auth_token')) {\nreturn;\n} $response = $event->getResponse(); // create a hash and set it as a response header\n$hash = sha1($response->getContent().$token);\n$response->headers->set('X-CONTENT-HASH', $hash);\n}", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_sem_5", "source": "event_dispatcher.rst", "text": "public static function getSubscribedEvents(): array\n{\nreturn [\nKernelEvents::CONTROLLER => 'onKernelController',\nKernelEvents::RESPONSE => 'onKernelResponse',\n];\n} That's it! The TokenSubscriber is now notified before every controller is\nexecuted (onKernelController()) and after every controller returns a response\n(onKernelResponse()). By making specific controllers implement the TokenAuthenticatedController\ninterface, your listener knows which controllers it should take action on.\nAnd by storing a value in the request's \"attributes\" bag, the onKernelResponse()\nmethod knows to add the extra header. Have fun! How to Customize a Method Behavior without Using Inheritance If you want to do something right before, or directly after a method is\ncalled, you can dispatch an event respectively at the beginning or at the\nend of the method:: class CustomMailer\n{\n// ... public function send(string $subject, string $message): mixed\n{\n// dispatch an event before the method\n$event = new BeforeSendMailEvent($subject, $message);\n$this->dispatcher->dispatch($event, 'mailer.pre_send'); // get $subject and $message from the event, they may have been modified\n$subject = $event->getSubject();\n$message = $event->getMessage(); // the real method implementation is here\n$returnValue = ...; // do something after the method\n$event = new AfterSendMailEvent($returnValue);\n$this->dispatcher->dispatch($event, 'mailer.post_send'); return $event->getReturnValue();\n}\n} In this example, two events are dispatched: #. mailer.pre_send, before the method is called,\n#. and mailer.post_send after the method is called. Each uses a custom Event class to communicate information to the listeners\nof the two events. For example, BeforeSendMailEvent might look like\nthis:: // src/Event/BeforeSendMailEvent.php\nnamespace App\\Event; use Symfony\\Contracts\\EventDispatcher\\Event; class BeforeSendMailEvent extends Event\n{\npublic function __construct(\nprivate string $subject,\nprivate string $message,\n) {\n} public function getSubject(): string\n{\nreturn $this->subject;\n} public function setSubject(string $subject): void\n{\n$this->subject = $subject;\n} public function getMessage(): string\n{\nreturn $this->message;\n} public function setMessage(string $message): void\n{\n$this->message = $message;\n}\n} And the AfterSendMailEvent even like this:: // src/Event/AfterSendMailEvent.php\nnamespace App\\Event; use Symfony\\Contracts\\EventDispatcher\\Event; class AfterSendMailEvent extends Event\n{\npublic function __construct(\nprivate mixed $returnValue,\n) {\n} public function getReturnValue(): mixed\n{\nreturn $this->returnValue;\n} public function setReturnValue(mixed $returnValue): void\n{\n$this->returnValue = $returnValue;\n}\n} Both events allow you to get some information (e.g. getMessage()) and even change\nthat information (e.g. setMessage()). Now, you can create an event subscriber to hook into this event. For example, you\ncould listen to the mailer.post_send event and change the method's return value:: // src/EventSubscriber/MailPostSendSubscriber.php\nnamespace App\\EventSubscriber; use App\\Event\\AfterSendMailEvent;\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; class MailPostSendSubscriber implements EventSubscriberInterface\n{\npublic function onMailerPostSend(AfterSendMailEvent $event): void\n{\n$returnValue = $event->getReturnValue();\n// modify the original $returnValue value $event->setReturnValue($returnValue);\n} public static function getSubscribedEvents(): array\n{\nreturn [\n'mailer.post_send' => 'onMailerPostSend',\n];\n}\n} That's it! Your subscriber should be called automatically (or read more about\nevent subscriber configuration ). Learn More - The Request-Response Lifecycle\n- /reference/events\n- Security-related Events\n- /components/event_dispatcher", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "forms.rst_sem_0", "source": "forms.rst", "text": "Forms :class: screencast Do you prefer video tutorials? Check out the `Symfony Forms screencast series`_. Creating and processing HTML forms is hard and repetitive. You need to deal with\nrendering HTML form fields, validating submitted data, mapping the form data\ninto objects and a lot more. Symfony includes a powerful form feature that\nprovides all these features and many more for truly complex scenarios. Installation In applications using Symfony Flex , run this command to\ninstall the form feature before using it: $ composer require symfony/form Usage The recommended workflow when working with Symfony forms is the following: #. **Build the form** in a Symfony controller or using a dedicated form class;\n#. **Render the form** in a template so the user can edit and submit it;\n#. **Process the form** to validate the submitted data, transform it into PHP\ndata and do something with it (e.g. persist it in a database). Each of these steps is explained in detail in the next sections. To make\nexamples easier to follow, all of them assume that you're building a small Todo\nlist application that displays \"tasks\". Users create and edit tasks using Symfony forms. Each task is an instance of the\nfollowing Task class:: // src/Entity/Task.php\nnamespace App\\Entity; class Task\n{\nprotected string $task; protected ?\\DateTimeInterface $dueDate; public function getTask(): string\n{\nreturn $this->task;\n} public function setTask(string $task): void\n{\n$this->task = $task;\n} public function getDueDate(): ?\\DateTimeInterface\n{\nreturn $this->dueDate;\n} public function setDueDate(?\\DateTimeInterface $dueDate): void\n{\n$this->dueDate = $dueDate;\n}\n} This class is a \"plain-old-PHP-object\" because, so far, it has nothing to do\nwith Symfony or any other library. It's a normal PHP object that directly solves\na problem inside *your* application (i.e. the need to represent a task in your\napplication). But you can also edit Doctrine entities in the\nsame way. Form Types Before creating your first Symfony form, it's important to understand the\nconcept of \"form type\". In other projects, it's common to differentiate between\n\"forms\" and \"form fields\". In Symfony, all of them are \"form types\": * a single <input type=\"text\"> form field is a \"form type\" (e.g. TextType);\n* a group of several HTML fields used to input a postal address is a \"form type\"\n(e.g. PostalAddressType);\n* an entire <form> with multiple fields to edit a user profile is a\n\"form type\" (e.g. UserProfileType). This may be confusing at first, but it will feel natural to you soon enough.\nBesides, it simplifies code and makes \"composing\" and \"embedding\" form fields\nmuch easier to implement. There are tens of form types provided by Symfony\nand you can also create your own form types . You can use the debug:form to list all the available types, type\nextensions and type guessers in your application: $ php bin/console debug:form", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_sem_1", "source": "forms.rst", "text": "# pass the form type FQCN to only show the options for that type, its parents and extensions.\n# For built-in types, you can pass the short classname instead of the FQCN\n$ php bin/console debug:form BirthdayType # pass also an option name to only display the full definition of that option\n$ php bin/console debug:form BirthdayType label_attr Building Forms Symfony provides a \"form builder\" object which allows you to describe the form\nfields using a fluent interface. Later, this builder creates the actual form\nobject used to render and process contents. Creating Forms in Controllers If your controller extends from the AbstractController ,\nuse the createFormBuilder() helper:: // src/Controller/TaskController.php\nnamespace App\\Controller; use App\\Entity\\Task;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response; class TaskController extends AbstractController\n{\npublic function new(Request $request): Response\n{\n// creates a task object and initializes some data for this example\n$task = new Task();\n$task->setTask('Write a blog post');\n$task->setDueDate(new \\DateTimeImmutable('tomorrow')); $form = $this->createFormBuilder($task)\n->add('task', TextType::class)\n->add('dueDate', DateType::class)\n->add('save', SubmitType::class, ['label' => 'Create Task'])\n->getForm(); // ...\n}\n} If your controller does not extend from AbstractController, you'll need to\nfetch services in your controller and\nuse the createBuilder() method of the form.factory service. In this example, you've added two fields to your form - task and dueDate\n- corresponding to the task and dueDate properties of the Task\nclass. You've also assigned each a form type (e.g. TextType\nand DateType), represented by its fully qualified class name. Finally, you\nadded a submit button with a custom label for submitting the form to the server. Creating Form Classes Symfony recommends putting as little logic as possible in controllers. That's why\nit's better to move complex forms to dedicated classes instead of defining them\nin controller actions. Besides, forms defined in classes can be reused in\nmultiple actions and services. Form classes are form types that implement\nSymfony\\\\Component\\\\Form\\\\FormTypeInterface. However, it's better to\nextend from Symfony\\\\Component\\\\Form\\\\AbstractType, which already\nimplements the interface and provides some utilities:: // src/Form/Type/TaskType.php\nnamespace App\\Form\\Type; use Symfony\\Component\\Form\\AbstractType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\nuse Symfony\\Component\\Form\\FormBuilderInterface; class TaskType extends AbstractType\n{\npublic function buildForm(FormBuilderInterface $builder, array $options): void\n{\n$builder\n->add('task', TextType::class)\n->add('dueDate', DateType::class)\n->add('save', SubmitType::class)\n;\n}\n} Install the `MakerBundle`_ in your project to generate form classes using\nthe make:form and make:registration-form commands. The form class contains all the directions needed to create the task form. In\ncontrollers extending from the AbstractController ,\nuse the createForm() helper (otherwise, use the create() method of the\nform.factory service):: // src/Controller/TaskController.php\nnamespace App\\Controller; use App\\Form\\Type\\TaskType;\n// ... class TaskController extends AbstractController\n{\npublic function new(): Response\n{\n// creates a task object and initializes some data for this example\n$task = new Task();\n$task->setTask('Write a blog post');\n$task->setDueDate(new \\DateTimeImmutable('tomorrow')); $form = $this->createForm(TaskType::class, $task); // ...\n}\n}", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_sem_2", "source": "forms.rst", "text": "Every form needs to know the name of the class that holds the underlying data\n(e.g. App\\Entity\\Task). Usually, this is just guessed based off of the\nobject passed to the second argument to createForm() (i.e. $task).\nLater, when you begin embedding forms , this will no\nlonger be sufficient. So, while not always necessary, it's generally a good idea to explicitly specify\nthe data_class option by adding the following to your form type class:: // src/Form/Type/TaskType.php\nnamespace App\\Form\\Type; use App\\Entity\\Task;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n// ... class TaskType extends AbstractType\n{\n// ... public function configureOptions(OptionsResolver $resolver): void\n{\n$resolver->setDefaults([\n'data_class' => Task::class,\n]);\n}\n} Rendering Forms Now that the form has been created, the next step is to render it:: // src/Controller/TaskController.php\nnamespace App\\Controller; use App\\Entity\\Task;\nuse App\\Form\\Type\\TaskType;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response; class TaskController extends AbstractController\n{\npublic function new(Request $request): Response\n{\n$task = new Task();\n// ... $form = $this->createForm(TaskType::class, $task); return $this->render('task/new.html.twig', [\n'form' => $form,\n]);\n}\n} Internally, the render() method calls $form->createView() to\ntransform the form into a *form view* instance. Then, use some form helper functions to\nrender the form contents: {# templates/task/new.html.twig #}\n{{ form(form) }} That's it! The form() function renders all\nfields *and* the <form> start and end tags. By default, the form method is\nPOST and the target URL is the same that displayed the form, but\nyou can change both . Notice how the rendered task input field has the value of the task\nproperty from the $task object (i.e. \"Write a blog post\"). This is the first\njob of a form: to take data from an object and translate it into a format that's\nsuitable for being rendered in an HTML form. The form system is smart enough to access the value of the protected\ntask property via the getTask() and setTask() methods on the\nTask class. Unless a property is public, it *must* have a \"getter\" and\n\"setter\" method so that Symfony can get and put data onto the property. For\na boolean property, you can use an \"isser\" or \"hasser\" method (e.g.\nisPublished() or hasReminder()) instead of a getter (e.g.\ngetPublished() or getReminder()). As short as this rendering is, it's not very flexible. Usually, you'll need more\ncontrol about how the entire form or some of its fields look. For example, thanks\nto the Bootstrap 5 integration with Symfony forms you\ncan set this option to generate forms compatible with the Bootstrap 5 CSS framework: # config/packages/twig.yaml\ntwig:\nform_themes: ['bootstrap_5_layout.html.twig'] <!-- config/packages/twig.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:twig=\"http://symfony.com/schema/dic/twig\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/twig\nhttps://symfony.com/schema/dic/twig/twig-1.0.xsd\"> <twig:config>\n<twig:form-theme>bootstrap_5_layout.html.twig</twig:form-theme>\n<!-- ... -->\n</twig:config>\n</container> // config/packages/twig.php\nuse Symfony\\Config\\TwigConfig; return static function (TwigConfig $twig): void {\n$twig->formThemes(['bootstrap_5_layout.html.twig']); // ...\n}; The built-in Symfony form themes include\nBootstrap 3, 4 and 5, Foundation 5 and 6, as well as Tailwind 2. You can also\ncreate your own Symfony form theme .", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_sem_3", "source": "forms.rst", "text": "In addition to form themes, Symfony allows you to\ncustomize the way fields are rendered with\nmultiple functions to render each field part separately (widgets, labels,\nerrors, help messages, etc.) Processing Forms The recommended way of processing forms is to\nuse a single action for both rendering the form and handling the form submit.\nYou can use separate actions, but using one action simplifies everything while\nkeeping the code concise and maintainable. Processing a form means to translate user-submitted data back to the properties\nof an object. To make this happen, the submitted data from the user must be\nwritten into the form object:: // src/Controller/TaskController.php // ...\nuse Symfony\\Component\\HttpFoundation\\Request; class TaskController extends AbstractController\n{\npublic function new(Request $request): Response\n{\n// just set up a fresh $task object (remove the example data)\n$task = new Task(); $form = $this->createForm(TaskType::class, $task); $form->handleRequest($request);\nif ($form->isSubmitted() && $form->isValid()) {\n// $form->getData() holds the submitted values\n// but, the original `$task` variable has also been updated\n$task = $form->getData(); // ... perform some action, such as saving the task to the database return $this->redirectToRoute('task_success');\n} return $this->render('task/new.html.twig', [\n'form' => $form,\n]);\n}\n} This controller follows a common pattern for handling forms and has three\npossible paths: #. When initially loading the page in a browser, the form hasn't been submitted\nyet and $form->isSubmitted() returns false. So, the form is created\nand rendered; #. When the user submits the form, Symfony\\\\Component\\\\Form\\\\FormInterface::handleRequest\nrecognizes this and immediately writes the submitted data back into the\ntask and dueDate properties of the $task object. Then this object\nis validated (validation is explained in the next section). If it is invalid,\nSymfony\\\\Component\\\\Form\\\\FormInterface::isValid returns\nfalse and the form is rendered again, but now with validation errors. By passing $form to the render() method (instead of\n$form->createView()), the response code is automatically set to\n`HTTP 422 Unprocessable Content`_. This ensures compatibility with tools\nrelying on the HTTP specification, like `Symfony UX Turbo`_; #. When the user submits the form with valid data, the submitted data is again\nwritten into the form, but this time Symfony\\\\Component\\\\Form\\\\FormInterface::isValid\nreturns true. Now you have the opportunity to perform some actions using\nthe $task object (e.g. persisting it to the database) before redirecting\nthe user to some other page (e.g. a \"thank you\" or \"success\" page); Redirecting a user after a successful form submission is a best practice\nthat prevents the user from being able to hit the \"Refresh\" button of\ntheir browser and re-post the data. If you need more control over exactly when your form is submitted or which\ndata is passed to it, you can\nuse the submit() method to handle form submissions . Validating Forms", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_sem_4", "source": "forms.rst", "text": "In the previous section, you learned how a form can be submitted with valid\nor invalid data. In Symfony, the question isn't whether the \"form\" is valid, but\nwhether or not the underlying object ($task in this example) is valid after\nthe form has applied the submitted data to it. Calling $form->isValid() is a\nshortcut that asks the $task object whether or not it has valid data. Before using validation, add support for it in your application: $ composer require symfony/validator Validation is done by adding a set of rules, called (validation) constraints,\nto a class. You can add them either to the entity class or by using the\nconstraints option of form types. To see the first approach - adding constraints to the entity - in action,\nadd the validation constraints, so that the task field cannot be empty,\nand the dueDate field cannot be empty, and must be a valid DateTimeImmutable\nobject. // src/Entity/Task.php\nnamespace App\\Entity; use Symfony\\Component\\Validator\\Constraints as Assert; class Task\n{\n#[Assert\\NotBlank]\npublic string $task; #[Assert\\NotBlank]\n#[Assert\\Type(\\DateTimeInterface::class)]\nprotected \\DateTimeInterface $dueDate;\n} # config/validator/validation.yaml\nApp\\Entity\\Task:\nproperties:\ntask:\n- NotBlank: ~\ndueDate:\n- NotBlank: ~\n- Type: \\DateTimeInterface <!-- config/validator/validation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\nhttps://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Task\">\n<property name=\"task\">\n<constraint name=\"NotBlank\"/>\n</property>\n<property name=\"dueDate\">\n<constraint name=\"NotBlank\"/>\n<constraint name=\"Type\">\\DateTimeInterface</constraint>\n</property>\n</class>\n</constraint-mapping> // src/Entity/Task.php\nnamespace App\\Entity; use Symfony\\Component\\Validator\\Constraints\\NotBlank;\nuse Symfony\\Component\\Validator\\Constraints\\Type;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Task\n{\n// ... public static function loadValidatorMetadata(ClassMetadata $metadata): void\n{\n$metadata->addPropertyConstraint('task', new NotBlank()); $metadata->addPropertyConstraint('dueDate', new NotBlank());\n$metadata->addPropertyConstraint(\n'dueDate',\nnew Type(\\DateTimeInterface::class)\n);\n}\n} That's it! If you re-submit the form with invalid data, you'll see the\ncorresponding errors printed out with the form. To see the second approach - adding constraints to the form - refer to\nthis section . Both approaches can be used together. Other Common Form Features Passing Options to Forms If you create forms in classes , when building\nthe form in the controller you can pass custom options to it as the third optional\nargument of createForm():: // src/Controller/TaskController.php\nnamespace App\\Controller; use App\\Form\\Type\\TaskType;\n// ... class TaskController extends AbstractController\n{\npublic function new(): Response\n{\n$task = new Task();\n// use some PHP logic to decide if this form field is required or not\n$dueDateIsRequired = ...; $form = $this->createForm(TaskType::class, $task, [\n'require_due_date' => $dueDateIsRequired,\n]); // ...\n}\n} If you try to use the form now, you'll see an error message: *The option\n\"require_due_date\" does not exist.* That's because forms must declare all the\noptions they accept using the configureOptions() method:: // src/Form/Type/TaskType.php\nnamespace App\\Form\\Type; use Symfony\\Component\\OptionsResolver\\OptionsResolver;\n// ... class TaskType extends AbstractType\n{\n// ... public function configureOptions(OptionsResolver $resolver): void\n{\n$resolver->setDefaults([\n// ...,\n'require_due_date' => false,\n]); // you can also define the allowed types, allowed values and\n// any other feature supported by the OptionsResolver component\n$resolver->setAllowedTypes('require_due_date', 'bool');\n}\n} Now you can use this new form option inside the buildForm() method:: // src/Form/Type/TaskType.php\nnamespace App\\Form\\Type; use Symfony\\Component\\Form\\AbstractType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\nuse Symfony\\Component\\Form\\FormBuilderInterface;", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_sem_5", "source": "forms.rst", "text": "class TaskType extends AbstractType\n{\npublic function buildForm(FormBuilderInterface $builder, array $options): void\n{\n$builder\n// ...\n->add('dueDate', DateType::class, [\n'required' => $options['require_due_date'],\n])\n;\n} // ...\n} Form Type Options Each form type has a number of options to configure it, as\nexplained in the Symfony form types reference .\nTwo commonly used options are required and label. The required Option\n....................... The most common option is the required option, which can be applied to any\nfield. By default, this option is set to true, meaning that HTML5-ready\nbrowsers will require you to fill in all fields before submitting the form. If you don't want this behavior, either\ndisable client-side validation for the\nentire form or set the required option to false on one or more fields:: ->add('dueDate', DateType::class, [\n'required' => false,\n]) The required option does not perform any server-side validation. If a user\nsubmits a blank value for the field (either with an old browser or a web\nservice, for example), it will be accepted as a valid value unless you also use\nSymfony's NotBlank or NotNull validation constraints. The label Option\n.................... By default, the label of form fields are the *humanized* version of the\nproperty name (user -> User; postalAddress -> Postal Address).\nSet the label option on fields to define their labels explicitly:: ->add('dueDate', DateType::class, [\n// set it to FALSE to not display the label for this field\n'label' => 'To Be Completed Before',\n]) By default, <label> tags of required fields are rendered with a\nrequired CSS class, so you can display an asterisk by applying a CSS style: label.required:before {\ncontent: \"*\";\n} Changing the Action and HTTP Method By default, the <form> tag is rendered with a method=\"post\" attribute,\nand no action attribute. This means that the form is submitted via an HTTP\nPOST request to the same URL under which it was rendered. When building the form,\nuse the setAction() and setMethod() methods to change this:: // src/Controller/TaskController.php\nnamespace App\\Controller; // ...\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; class TaskController extends AbstractController\n{\npublic function new(): Response\n{\n// ... $form = $this->createFormBuilder($task)\n->setAction($this->generateUrl('target_route'))\n->setMethod('GET')\n// ...\n->getForm(); // ...\n}\n} When building the form in a class, pass the action and method as form options:: // src/Controller/TaskController.php\nnamespace App\\Controller; use App\\Form\\TaskType;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n// ... class TaskController extends AbstractController\n{\npublic function new(): Response\n{\n// ... $form = $this->createForm(TaskType::class, $task, [\n'action' => $this->generateUrl('target_route'),\n'method' => 'GET',\n]); // ...\n}\n} Finally, you can override the action and method in the template by passing them\nto the form() or the form_start() helper functions: {# templates/task/new.html.twig #}\n{{ form_start(form, {'action': path('target_route'), 'method': 'GET'}) }}", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_sem_6", "source": "forms.rst", "text": "If the form's method is not GET or POST, but PUT, PATCH or\nDELETE, Symfony will insert a hidden field with the name _method\nthat stores this method. The form will be submitted in a normal POST\nrequest, but Symfony's routing is capable of detecting the\n_method parameter and will interpret it as a PUT, PATCH or\nDELETE request. The http_method_override\noption must be enabled for this to work. Changing the Form Name If you inspect the HTML contents of the rendered form, you'll see that the\n<form> name and the field names are generated from the type class name\n(e.g. <form name=\"task\" ...> and <select name=\"task[dueDate][date][month]\" ...>). If you want to modify this, use the Symfony\\\\Component\\\\Form\\\\FormFactoryInterface::createNamed\nmethod:: // src/Controller/TaskController.php\nnamespace App\\Controller; use App\\Form\\TaskType;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\Form\\FormFactoryInterface;\n// ... class TaskController extends AbstractController\n{\npublic function new(FormFactoryInterface $formFactory): Response\n{\n$task = ...;\n$form = $formFactory->createNamed('my_name', TaskType::class, $task); // ...\n}\n} You can even suppress the name completely by setting it to an empty string. Client-Side HTML Validation Thanks to HTML5, many browsers can natively enforce certain validation\nconstraints on the client side. The most common validation is activated by\nadding a required attribute on fields that are required. For browsers\nthat support HTML5, this will result in a native browser message being displayed\nif the user tries to submit the form with that field blank. Generated forms take full advantage of this new feature by adding sensible HTML\nattributes that trigger the validation. The client-side validation, however, can\nbe disabled by adding the novalidate attribute to the <form> tag or\nformnovalidate to the submit tag. This is especially useful when you want to\ntest your server-side validation constraints, but are being prevented by your\nbrowser from, for example, submitting blank fields. {# templates/task/new.html.twig #}\n{{ form_start(form, {'attr': {'novalidate': 'novalidate'}}) }}\n{{ form_widget(form) }}\n{{ form_end(form) }} Form Type Guessing If the object handled by the form includes validation constraints, Symfony can\nintrospect that metadata to guess the type of your field.\nIn the above example, Symfony can guess from the validation rules that the\ntask field is a normal TextType field and the dueDate field is a\nDateType field. To enable Symfony's \"guessing mechanism\", omit the second argument to the add() method, or\npass null to it:: // src/Form/Type/TaskType.php\nnamespace App\\Form\\Type; use Symfony\\Component\\Form\\AbstractType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\nuse Symfony\\Component\\Form\\FormBuilderInterface; class TaskType extends AbstractType\n{\npublic function buildForm(FormBuilderInterface $builder, array $options): void\n{\n$builder\n// if you don't define field options, you can omit the second argument\n->add('task')\n// if you define field options, pass NULL as second argument\n->add('dueDate', null, ['required' => false])\n->add('save', SubmitType::class)\n;\n}\n} When using a specific form validation group ,\nthe field type guesser will still consider *all* validation constraints when\nguessing your field types (including constraints that are not part of the\nvalidation group(s) being used). Form Type Options Guessing\n..........................", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_sem_7", "source": "forms.rst", "text": "When the guessing mechanism is enabled for some field, in addition to its form type,\nthe following options will be guessed too: required\nThe required option is guessed based on the validation rules (i.e. is\nthe field NotBlank or NotNull) or the Doctrine metadata (i.e. is the\nfield nullable). This is very useful, as your client-side validation will\nautomatically match your validation rules. maxlength\nIf the field is some sort of text field, then the maxlength option attribute\nis guessed from the validation constraints (if Length or Range is used)\nor from the Doctrine metadata (via the field's length). If you'd like to change one of the guessed values, override it in the options field array:: ->add('task', null, ['attr' => ['maxlength' => 4]]) Besides guessing the form type, Symfony also guesses validation constraints\nif you're using a Doctrine entity. Read automatic_object_validation\nguide for more information. Unmapped Fields When editing an object via a form, all form fields are considered properties of\nthe object. Any fields on the form that do not exist on the object will cause an\nexception to be thrown. If you need extra fields in the form that won't be stored in the object (for\nexample to add an *\"I agree with these terms\"* checkbox), set the mapped\noption to false in those fields:: // ...\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\CheckboxType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\nuse Symfony\\Component\\Form\\FormBuilderInterface; class TaskType extends AbstractType\n{\npublic function buildForm(FormBuilderInterface $builder, array $options): void\n{\n$builder\n->add('task')\n->add('dueDate')\n->add('agreeTerms', CheckboxType::class, ['mapped' => false])\n->add('save', SubmitType::class)\n;\n}\n} These \"unmapped fields\" can be set and accessed in a controller with:: $form->get('agreeTerms')->getData();\n$form->get('agreeTerms')->setData(true); Additionally, if there are any fields on the form that aren't included in\nthe submitted data, those fields will be explicitly set to null. Learn more When building forms, keep in mind that the first goal of a form is to translate\ndata from an object (Task) to an HTML form so that the user can modify that\ndata. The second goal of a form is to take the data submitted by the user and to\nre-apply it to the object. There's a lot more to learn and a lot of *powerful* tricks in the Symfony forms: Reference: :maxdepth: 1 /reference/forms/types Advanced Features: :maxdepth: 1 /controller/upload_file\n/security/csrf\n/form/create_custom_field_type\n/form/data_transformers\n/form/data_mappers\n/form/create_form_type_extension\n/form/type_guesser Form Themes and Customization: :maxdepth: 1 /form/bootstrap4\n/form/bootstrap5\n/form/tailwindcss\n/form/form_customization\n/form/form_themes Events: :maxdepth: 1 /form/events\n/form/dynamic_form_modification Validation: :maxdepth: 1 /form/validation_groups\n/form/disabling_validation Misc.: :maxdepth: 1 /form/direct_submit\n/form/embedded\n/form/form_collections\n/form/inherit_data_option\n/form/multiple_buttons\n/form/unit_testing\n/form/use_empty_data\n/form/without_class", "title": "Forms", "category": "forms"}
{"chunk_id": "http_cache.rst_sem_0", "source": "http_cache.rst", "text": "HTTP Cache The nature of rich web applications means that they're dynamic. No matter\nhow efficient your application, each request will always contain more overhead\nthan serving a static file. Usually, that's fine. But when you need your requests\nto be lightning fast, you need HTTP caching. Caching on the Shoulders of Giants With HTTP Caching, you cache the full output of a page (i.e. the response) and bypass\nyour application *entirely* on subsequent requests. Caching entire responses\nisn't always possible for highly dynamic sites, or is it? With\nEdge Side Includes (ESI) , you can use the power of HTTP caching\non only *fragments* of your site. The Symfony cache system is different because it relies on the simplicity\nand power of the HTTP cache as defined in `RFC 7234 - Caching`_. Instead of\nreinventing a caching methodology, Symfony embraces the standard that defines\nbasic communication on the Web. Once you understand the fundamental HTTP\nvalidation and expiration caching models, you'll be ready to understand the Symfony\ncache system. Since caching with HTTP isn't unique to Symfony, many articles already exist\non the topic. If you're new to HTTP caching, Ryan Tomayko's article\n`Things Caches Do`_ is *highly* recommended. Another in-depth resource is Mark\nNottingham's `Cache Tutorial`_. Caching with a Gateway Cache When caching with HTTP, the *cache* is separated from your application entirely\nand sits between your application and the client making the request. The job of the cache is to accept requests from the client and pass them\nback to your application. The cache will also receive responses back from\nyour application and forward them on to the client. The cache is the \"middle-man\"\nof the request-response communication between the client and your application. Along the way, the cache will store each response that is deemed \"cacheable\"\n(See http-cache-introduction). If the same resource is requested again,\nthe cache sends the cached response to the client, ignoring your application\nentirely. This type of cache is known as an HTTP gateway cache and many exist such\nas `Varnish`_, `Squid in reverse proxy mode`_, and the Symfony reverse proxy. Gateway caches are sometimes referred to as reverse proxy caches,\nsurrogate caches, or even HTTP accelerators. Symfony Reverse Proxy Symfony comes with a reverse proxy (i.e. gateway cache) written in PHP.\nIt's not a fully-featured reverse proxy cache like Varnish ,\nbut it is a great way to start. For details on setting up Varnish, see /http_cache/varnish. Use the framework.http_cache option to enable the proxy for the\nprod environment : # config/packages/framework.yaml\nwhen@prod:\nframework:\nhttp_cache: true <!-- config/packages/framework.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <when env=\"prod\">\n<framework:config>\n<!-- ... -->\n<framework:http-cache enabled=\"true\"/>\n</framework:config>\n</when>\n</container> // config/packages/framework.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework, string $env): void {\nif ('prod' === $env) {\n$framework->httpCache()->enabled(true);\n}\n}; The kernel will immediately act as a reverse proxy: caching responses\nfrom your application and returning them to the client.", "title": "HTTP Cache", "category": "http_cache"}
{"chunk_id": "http_cache.rst_sem_1", "source": "http_cache.rst", "text": "The proxy has a sensible default configuration, but it can be\nfinely tuned via a set of options . When in debug mode , Symfony automatically adds an\nX-Symfony-Cache header to the response. You can also use the trace_level\nconfig option and set it to either none, short or full to add this\ninformation. short will add the information for the main request only.\nIt's written in a concise way that makes it easy to record the\ninformation in your server log files. For example, in Apache you can\nuse %{X-Symfony-Cache}o in LogFormat format statements.\nThis information can be used to extract general information about\ncache efficiency of your routes. You can change the name of the header used for the trace\ninformation using the trace_header config option. The Symfony reverse proxy is a great tool to use when developing your\nwebsite or when you deploy your website to a shared host where you cannot\ninstall anything beyond PHP code. But being written in PHP, it cannot\nbe as fast as a proxy written in C. Fortunately, since all reverse proxies are effectively the same, you should\nbe able to switch to something more robust - like Varnish - without any problems.\nSee How to use Varnish Making your Responses HTTP Cacheable Once you've added a reverse proxy cache (e.g. like the Symfony reverse proxy or Varnish),\nyou're ready to cache your responses. To do that, you need to *communicate* to your\ncache *which* responses are cacheable and for how long. This is done by setting HTTP\ncache headers on the response. HTTP specifies four response cache headers that you can set to enable caching: * Cache-Control\n* Expires\n* ETag\n* Last-Modified These four headers are used to help cache your responses via *two* different models: #. Expiration Caching\nUsed to cache your entire response for a specific amount of time (e.g. 24 hours).\nSimple, but cache invalidation is more difficult. #. Validation Caching\nMore complex: used to cache your response, but allows you to dynamically invalidate\nit as soon as your content changes. All of the HTTP headers you'll read about are *not* invented by Symfony! They're\npart of an HTTP specification that's used by sites all over the web. To dig deeper\ninto HTTP Caching, check out the documents `RFC 7234 - Caching`_ and\n`RFC 7232 - Conditional Requests`_. As a web developer, you are strongly urged to read the specification. Its\nclarity and power - even more than fifteen years after its creation - is\ninvaluable. Don't be put-off by the appearance of the spec - its contents\nare much more beautiful than its cover! Expiration Caching The *easiest* way to cache a response is by caching it for a specific amount of time:: // src/Controller/BlogController.php\nuse Symfony\\Component\\HttpKernel\\Attribute\\Cache;\n// ... #[Cache(public: true, maxage: 3600, mustRevalidate: true)]\npublic function index(): Response\n{\nreturn $this->render('blog/index.html.twig', []);\n} // src/Controller/BlogController.php\nuse Symfony\\Component\\HttpFoundation\\Response;", "title": "HTTP Cache", "category": "http_cache"}
{"chunk_id": "http_cache.rst_sem_2", "source": "http_cache.rst", "text": "public function index(): Response\n{\n// somehow create a Response object, like by rendering a template\n$response = $this->render('blog/index.html.twig', []); // cache publicly for 3600 seconds\n$response->setPublic();\n$response->setMaxAge(3600); // (optional) set a custom Cache-Control directive\n$response->headers->addCacheControlDirective('must-revalidate', true); return $response;\n} Thanks to this new code, your HTTP response will have the following header: Cache-Control: public, maxage=3600, must-revalidate When both are used, the cache headers defined in the controller take\nprecedence over those configured with the #[Cache] attribute. This tells your HTTP reverse proxy to cache this response for 3600 seconds. If *anyone*\nrequests this URL again before 3600 seconds, your application *won't* be hit at all.\nIf you're using the Symfony reverse proxy, look at the X-Symfony-Cache header\nfor debugging information about cache hits and misses. The URI of the request is used as the cache key (unless you vary ). This provides great performance and is simple to use. But, cache *invalidation*\nis not supported. If your content change, you'll need to wait until your cache\nexpires for the page to update. Actually, you *can* manually invalidate your cache, but it's not part of the\nHTTP Caching spec. See http-cache-invalidation. If you need to set cache headers for many different controller actions, check out\n`FOSHttpCacheBundle`_. It provides a way to define cache headers based on the URL\npattern and other request properties. Finally, for more information about expiration caching, see /http_cache/expiration. Validation Caching With expiration caching, you say \"cache for 3600 seconds!\". But, when someone\nupdates cached content, you won't see that content on your site until the cache\nexpires. If you need to see updated content *immediately*, you either need to\ninvalidate your cache *or* use the validation\ncaching model. For details, see /http_cache/validation. Safe Methods: Only caching GET or HEAD requests HTTP caching only works for \"safe\" HTTP methods (like GET and HEAD). This means\nthree things: * Don't try to cache PUT or DELETE requests. It won't work and with good reason.\nThese methods are meant to be used when mutating the state of your application\n(e.g. deleting a blog post). Caching them would prevent certain requests from hitting\nand mutating your application. * POST requests are generally considered uncacheable, but `they can be cached`_\nwhen they include explicit freshness information. However, POST caching is not\nwidely implemented, so you should avoid it if possible. * You should *never* change the state of your application (e.g. update a blog post)\nwhen responding to a GET or HEAD request. If those requests are cached, future\nrequests may not actually hit your server. More Response Methods The Response class provides many more methods related to the cache. Here are\nthe most useful ones:: // marks the Response stale\n$response->expire(); // forces the response to return a proper 304 response with no content\n$response->setNotModified(); Additionally, most cache-related HTTP headers can be set via the single\nSymfony\\\\Component\\\\HttpFoundation\\\\Response::setCache method::", "title": "HTTP Cache", "category": "http_cache"}
{"chunk_id": "http_cache.rst_sem_3", "source": "http_cache.rst", "text": "// use this method to set several cache settings in one call\n// (this example lists all the available cache settings)\n$response->setCache([\n'must_revalidate' => false,\n'no_cache' => false,\n'no_store' => false,\n'no_transform' => false,\n'public' => true,\n'private' => false,\n'proxy_revalidate' => false,\n'max_age' => 600,\n's_maxage' => 600,\n'immutable' => true,\n'last_modified' => new \\DateTime(),\n'etag' => 'abcdef'\n]); All these options are also available when using the #[Cache] attribute. Cache Invalidation Cache invalidation is *not* part of the HTTP specification. Still, it can be really\nuseful to delete various HTTP cache entries as soon as some content on your site\nis updated. For details, see /http_cache/cache_invalidation. Using Edge Side Includes When pages contain dynamic parts, you may not be able to cache entire pages,\nbut only parts of it. Read /http_cache/esi to find out how to configure\ndifferent cache strategies for specific parts of your page. HTTP Caching and User Sessions Whenever the session is started during a request, Symfony turns the response\ninto a private non-cacheable response. This is the best default behavior to not\ncache private user information (e.g. a shopping cart, a user profile details,\netc.) and expose it to other visitors. However, even requests making use of the session can be cached under some\ncircumstances. For example, information related to some user group could be\ncached for all the users belonging to that group. Handling these advanced\ncaching scenarios is out of the scope of Symfony, but they can be solved with\nthe `FOSHttpCacheBundle`_. In order to disable the default Symfony behavior that makes requests using the\nsession uncacheable, add the following internal header to your response and\nSymfony won't modify it:: use Symfony\\Component\\HttpKernel\\EventListener\\AbstractSessionListener; $response->headers->set(AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER, 'true'); Summary Symfony was designed to follow the proven rules of the road: HTTP. Caching\nis no exception. Mastering the Symfony cache system means becoming familiar\nwith the HTTP cache models and using them effectively. This means that, instead\nof relying only on Symfony documentation and code examples, you have access\nto a world of knowledge related to HTTP caching and gateway caches such as\nVarnish. Learn more :maxdepth: 1\n:glob: http_cache/*", "title": "HTTP Cache", "category": "http_cache"}
{"chunk_id": "index.rst_sem_0", "source": "index.rst", "text": "Symfony Documentation Quick Tour Get started fast with the Symfony Quick Tour : * /quick_tour/the_big_picture\n* /quick_tour/flex_recipes\n* /quick_tour/the_architecture Getting Started :maxdepth: 2 getting_started/index Topics :maxdepth: 1 best_practices\nbundles\ncache\nconsole\ndoctrine\ndeployment\nevent_dispatcher\nforms\nfrontend\nhtml_sanitizer\nhttp_cache\nhttp_client\nlock\nlogging\nmailer\nmercure\nmessenger\nmigration\nnotifier\nperformance\nprofiler\nrate_limiter\nrouting\nsecurity\nsession\nsetup\nserializer\nservice_container\ntesting\ntranslation\nvalidation\nweb_link\nwebhook\nworkflow Components Read the Components documentation. Reference Documents Get answers quickly with reference documents: Contributing Contribute to Symfony: Create your Own Framework Want to create your own framework based on Symfony? :maxdepth: 2 create_framework/index", "title": "Symfony Documentation", "category": "index"}
{"chunk_id": "mailer.rst_sem_0", "source": "mailer.rst", "text": "Sending Emails with Mailer Installation Symfony's Mailer & Mime components form a *powerful* system\nfor creating and sending emails - complete with support for multipart messages, Twig\nintegration, CSS inlining, file attachments and a lot more. Get them installed with: $ composer require symfony/mailer Transport Setup Emails are delivered via a \"transport\". Out of the box, you can deliver emails\nover SMTP by configuring the DSN in your .env file (the user,\npass and port parameters are optional): # .env\nMAILER_DSN=smtp://user:pass@smtp.example.com:port # config/packages/mailer.yaml\nframework:\nmailer:\ndsn: '%env(MAILER_DSN)%' <!-- config/packages/mailer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:mailer dsn=\"%env(MAILER_DSN)%\"/>\n</framework:config>\n</container> // config/packages/mailer.php\nuse Symfony\\Config\\FrameworkConfig;\nuse function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env; return static function (FrameworkConfig $framework): void {\n$framework->mailer()->dsn(env('MAILER_DSN'));\n}; If the username, password or host contain any character considered special in a\nURI (such as : / ? # [ ] @ ! $ & ' ( ) * + , ; =), you must\nencode them. See `RFC 3986`_ for the full list of reserved characters or use the\nurlencode function to encode them. Using Built-in Transports ============ ======================================== ==============================================================\nDSN protocol Example Description\n============ ======================================== ==============================================================\nsmtp smtp://user:pass@smtp.example.com:25 Mailer uses an SMTP server to send emails\nsendmail sendmail://default Mailer uses the local sendmail binary to send emails\nnative native://default Mailer uses the sendmail binary and options configured\nin the sendmail_path setting of php.ini. On Windows\nhosts, Mailer fallbacks to smtp and smtp_port\nphp.ini settings when sendmail_path is not configured.\n============ ======================================== ============================================================== When using native://default, if php.ini uses the sendmail -t\ncommand, you won't have error reporting and Bcc headers won't be removed.\nIt's highly recommended to NOT use native://default as you cannot control\nhow sendmail is configured (prefer using sendmail://default if possible). Using a 3rd Party Transport Instead of using your own SMTP server or sendmail binary, you can send emails\nvia a third-party provider: ===================== =============================================== ===============\nService Install with Webhook support\n===================== =============================================== ===============\n`AhaSend`_ composer require symfony/aha-send-mailer yes\n`Amazon SES`_ composer require symfony/amazon-mailer\n`Azure`_ composer require symfony/azure-mailer\n`Brevo`_ composer require symfony/brevo-mailer yes\n`Infobip`_ composer require symfony/infobip-mailer\n`Mailgun`_ composer require symfony/mailgun-mailer yes\n`Mailjet`_ composer require symfony/mailjet-mailer yes\n`Mailomat`_ composer require symfony/mailomat-mailer yes\n`MailPace`_ composer require symfony/mail-pace-mailer\n`MailerSend`_ composer require symfony/mailer-send-mailer yes\n`Mailtrap`_ composer require symfony/mailtrap-mailer yes\n`Mandrill`_ composer require symfony/mailchimp-mailer yes\n`Postal`_ composer require symfony/postal-mailer\n`Postmark`_ composer require symfony/postmark-mailer yes\n`Resend`_ composer require symfony/resend-mailer yes\n`Scaleway`_ composer require symfony/scaleway-mailer\n`SendGrid`_ composer require symfony/sendgrid-mailer yes\n`Sweego`_ composer require symfony/sweego-mailer yes\n===================== =============================================== =============== The Azure and Resend integrations were introduced in Symfony 7.1. The Mailomat, Mailtrap, Postal and Sweego integrations were introduced in Symfony 7.2. The AhaSend integration was introduced in Symfony 7.3. As a convenience, Symfony also provides support for Gmail (composer\nrequire symfony/google-mailer), but this should not be used in\nproduction. In development, you should probably use an email catcher\ninstead. Note that most supported providers also offer a\nfree tier.", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_1", "source": "mailer.rst", "text": "Each library includes a Symfony Flex recipe that will add\na configuration example to your .env file. For example, suppose you want to\nuse SendGrid. First, install it: $ composer require symfony/sendgrid-mailer You'll now have a new line in your .env file that you can uncomment: # .env\nMAILER_DSN=sendgrid://KEY@default The MAILER_DSN isn't a *real* address: it's a convenient format that\noffloads most of the configuration work to mailer. The sendgrid scheme\nactivates the SendGrid provider that you installed, which knows all about\nhow to deliver messages via SendGrid. The *only* part you need to change is the\nKEY placeholder. Each provider has different environment variables that the Mailer uses to\nconfigure the *actual* protocol, address and authentication for delivery. Some\nalso have options that can be configured with query parameters at the end of the\nMAILER_DSN - like ?region= for Amazon SES, Mailgun or Scaleway. Some providers support\nsending via http, api or smtp. Symfony chooses the best available\ntransport, but you can force to use one: # .env\n# force to use SMTP instead of HTTP (which is the default)\nMAILER_DSN=sendgrid+smtp://$SENDGRID_KEY@default This table shows the full list of available DSN formats for each third\nparty provider:", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_2", "source": "mailer.rst", "text": "| Provider | Formats |\n| `AhaSend`_ | - SMTP ahasend+smtp://USERNAME:PASSWORD@default |\n| | - HTTP n/a |\n| | - API ahasend+api://KEY@default |\n| `Amazon SES`_ | - SMTP ses+smtp://USERNAME:PASSWORD@default |\n| | - HTTP ses+https://ACCESS_KEY:SECRET_KEY@default |\n| | - API ses+api://ACCESS_KEY:SECRET_KEY@default |\n| `Azure`_ | - API azure+api://ACS_RESOURCE_NAME:KEY@default |\n| `Brevo`_ | - SMTP brevo+smtp://USERNAME:PASSWORD@default |\n| | - HTTP n/a |\n| | - API brevo+api://KEY@default |\n| `Google Gmail`_ | - SMTP gmail+smtp://USERNAME:APP-PASSWORD@default |\n| | - HTTP n/a |\n| | - API n/a |\n| `Infobip`_ | - SMTP infobip+smtp://KEY@default |\n| | - HTTP n/a |\n| | - API infobip+api://KEY@BASE_URL |\n| `Mandrill`_ | - SMTP mandrill+smtp://USERNAME:PASSWORD@default |\n| | - HTTP mandrill+https://KEY@default |\n| | - API mandrill+api://KEY@default |\n| `MailerSend`_ | - SMTP mailersend+smtp://KEY@default |\n| | - HTTP n/a |\n| | - API mailersend+api://KEY@BASE_URL |\n| `Mailgun`_ | - SMTP mailgun+smtp://USERNAME:PASSWORD@default |\n| | - HTTP mailgun+https://KEY:DOMAIN@default |\n| | - API mailgun+api://KEY:DOMAIN@default |\n| `Mailjet`_ | - SMTP mailjet+smtp://ACCESS_KEY:SECRET_KEY@default |\n| | - HTTP n/a |\n| | - API mailjet+api://ACCESS_KEY:SECRET_KEY@default |\n| `Mailomat`_ | - SMTP mailomat+smtp://USERNAME:PASSWORD@default |\n| | - HTTP n/a |\n| | - API mailomat+api://KEY@default |\n| `MailPace`_ | - SMTP mailpace+api://API_TOKEN@default |\n| | - HTTP n/a |\n| | - API mailpace+api://API_TOKEN@default |\n| `Mailtrap`_ | - SMTP mailtrap+smtp://PASSWORD@default |\n| | - HTTP n/a |\n| | - API mailtrap+api://API_TOKEN@default |\n| `Postal`_ | - SMTP n/a |\n| | - HTTP n/a |\n| | - API postal+api://API_KEY@BASE_URL |\n| `Postmark`_ | - SMTP postmark+smtp://ID@default |\n| | - HTTP n/a |\n| | - API postmark+api://KEY@default |\n| `Resend`_ | - SMTP resend+smtp://resend:API_KEY@default |\n| | - HTTP n/a |\n| | - API resend+api://API_KEY@default |\n| `Scaleway`_ | - SMTP scaleway+smtp://PROJECT_ID:API_KEY@default |\n| | - HTTP n/a |\n| | - API scaleway+api://PROJECT_ID:API_KEY@default |\n| `Sendgrid`_ | - SMTP sendgrid+smtp://KEY@default |\n| | - HTTP n/a |\n| | - API sendgrid+api://KEY@default |\n| `Sweego`_ | - SMTP sweego+smtp://LOGIN:PASSWORD@HOST:PORT |\n| | - HTTP n/a |\n| | - API sweego+api://API_KEY@default | If your credentials contain special characters, you must URL-encode them.\nFor example, the DSN ses+smtp://ABC1234:abc+12/345@default should be\nconfigured as ses+smtp://ABC1234:abc%2B12%2F345@default If you want to use the ses+smtp transport together with Messenger\nto send messages in background ,\nyou need to add the ping_threshold parameter to your MAILER_DSN with\na value lower than 10: ses+smtp://USERNAME:PASSWORD@default?ping_threshold=9 When using SMTP, the default timeout for sending a message before throwing an\nexception is the value defined in the `default_socket_timeout`_ PHP.ini option. Besides SMTP, many 3rd party transports offer a web API to send emails.\nTo do so, you have to install (additionally to the bridge)\nthe HttpClient component via composer require symfony/http-client.", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_3", "source": "mailer.rst", "text": "To use Google Gmail, you must have a Google Account with 2-Step-Verification (2FA)\nenabled and you must use `App Password`_ to authenticate. Also note that Google\nrevokes your App Passwords when you change your Google Account password and then\nyou need to generate a new one.\nUsing other methods (like XOAUTH2 or the Gmail API) are not supported currently.\nYou should use Gmail for testing purposes only and use a real provider in production. If you want to override the default host for a provider (to debug an issue using\na service like requestbin.com), change default by your host: # .env\nMAILER_DSN=mailgun+https://KEY:DOMAIN@requestbin.com Note that the protocol is *always* HTTPs and cannot be changed. The specific transports, e.g. mailgun+smtp are designed to work without any manual configuration.\nChanging the port by appending it to your DSN is not supported for any of these <provider>+smtp transports.\nIf you need to change the port, use the smtp transport instead, like so: # .env\nMAILER_DSN=smtp://KEY:DOMAIN@smtp.eu.mailgun.org.com:25 Some third party mailers, when using the API, support status callbacks\nvia webhooks. See the Webhook documentation for more\ndetails. High Availability Symfony's mailer supports `high availability`_ via a technique called \"failover\"\nto ensure that emails are sent even if one mailer server fails. A failover transport is configured with two or more transports and the\nfailover keyword: MAILER_DSN=\"failover(postmark+api://ID@default sendgrid+smtp://KEY@default)\" The failover-transport starts using the first transport and if it fails, it\nwill retry the same delivery with the next transports until one of them succeeds\n(or until all of them fail). By default, delivery is retried 60 seconds after a failed attempt. You can adjust\nthe retry period by setting the retry_period option in the DSN: MAILER_DSN=\"failover(postmark+api://ID@default sendgrid+smtp://KEY@default)?retry_period=15\" The retry_period option was introduced in Symfony 7.3. Load Balancing Symfony's mailer supports `load balancing`_ via a technique called \"round-robin\"\nto distribute the mailing workload across multiple transports. A round-robin transport is configured with two or more transports and the\nroundrobin keyword: MAILER_DSN=\"roundrobin(postmark+api://ID@default sendgrid+smtp://KEY@default)\" The round-robin transport starts with a *randomly* selected transport and\nthen switches to the next available transport for each subsequent email. As with the failover transport, round-robin retries deliveries until\na transport succeeds (or all fail). In contrast to the failover transport,\nit *spreads* the load across all its transports. By default, delivery is retried 60 seconds after a failed attempt. You can adjust\nthe retry period by setting the retry_period option in the DSN: MAILER_DSN=\"roundrobin(postmark+api://ID@default sendgrid+smtp://KEY@default)?retry_period=15\" The retry_period option was introduced in Symfony 7.3. TLS Peer Verification By default, SMTP transports perform TLS peer verification. This behavior is\nconfigurable with the verify_peer option. Although it's not recommended to\ndisable this verification for security reasons, it can be useful while developing\nthe application or when using a self-signed certificate:: $dsn = 'smtp://user:pass@smtp.example.com?verify_peer=0'; TLS Peer Fingerprint Verification Additional fingerprint verification can be enforced with the peer_fingerprint\noption. This is especially useful when a self-signed certificate is used and\ndisabling verify_peer is needed, but security is still desired. Fingerprint\nmay be specified as SHA1 or MD5 hash::", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_4", "source": "mailer.rst", "text": "$dsn = 'smtp://user:pass@smtp.example.com?peer_fingerprint=6A1CF3B08D175A284C30BC10DE19162307C7286E'; Disabling Automatic TLS The option to disable automatic TLS was introduced in Symfony 7.1. By default, the Mailer component will use encryption when the OpenSSL extension\nis enabled and the SMTP server supports STARTTLS. This behavior can be turned\noff by calling setAutoTls(false) on the EsmtpTransport instance, or by\nsetting the auto_tls option to false in the DSN:: $dsn = 'smtp://user:pass@10.0.0.25?auto_tls=false'; It's not recommended to disable TLS while connecting to an SMTP server over\nthe Internet, but it can be useful when both the application and the SMTP\nserver are in a secured network, where there is no need for additional encryption. This setting only works when the smtp:// protocol is used. Ensure TLS You may want to ensure that TLS is used (either directly or via STARTTLS)\nwhen sending mail over SMTP, regardless of other options or SMTP server support.\nTo require TLS, call setRequireTls(true) on the EsmtpTransport instance,\nor set the require_tls option to true in the DSN:: $dsn = 'smtp://user:pass@10.0.0.25?require_tls=true'; When TLS is required, a Symfony\\\\Component\\\\Mailer\\\\Exception\\\\TransportException\nis thrown if a TLS connection cannot be established during the initial communication\nwith the SMTP server. This setting only applies when using the smtp:// protocol. The require_tls option was introduced in Symfony 7.3. Binding to IPv4 or IPv6 The option to bind to IPv4, or IPv6, or a specific IP address was introduced in Symfony 7.3. By default, the underlying SocketStream will bind to IPv4 or IPv6 based on the\navailable interfaces. You can enforce binding to a specific protocol or IP address\nby using the source_ip option. To bind to IPv4, use:: $dsn = 'smtp://smtp.example.com?source_ip=0.0.0.0'; As per RFC2732, IPv6 addresses must be enclosed in square brackets. To bind to IPv6, use:: $dsn = 'smtp://smtp.example.com?source_ip=[::]'; This option only works when using the smtp:// protocol. Overriding default SMTP authenticators By default, SMTP transports will try to login using all authentication methods\navailable on the SMTP server, one after the other. In some cases, it may be\nuseful to redefine the supported authentication methods to ensure that the\npreferred method will be used first. This can be done from EsmtpTransport constructor or using the\nsetAuthenticators() method:: use Symfony\\Component\\Mailer\\Transport\\Smtp\\Auth\\XOAuth2Authenticator;\nuse Symfony\\Component\\Mailer\\Transport\\Smtp\\EsmtpTransport; // Choose one of these two options: // Option 1: pass the authenticators to the constructor\n$transport = new EsmtpTransport(\nhost: 'oauth-smtp.domain.tld',\nauthenticators: [new XOAuth2Authenticator()]\n); // Option 2: call a method to redefine the authenticators\n$transport->setAuthenticators([new XOAuth2Authenticator()]); Other Options command\nCommand to be executed by sendmail transport:: $dsn = 'sendmail://default?command=/usr/sbin/sendmail%20-oi%20-t' local_domain\nThe domain name to use in HELO command:: $dsn = 'smtps://smtp.example.com?local_domain=example.org' restart_threshold\nThe maximum number of messages to send before re-starting the transport. It\ncan be used together with restart_threshold_sleep:: $dsn = 'smtps://smtp.example.com?restart_threshold=10&restart_threshold_sleep=1' restart_threshold_sleep\nThe number of seconds to sleep between stopping and re-starting the transport.\nIt's common to combine it with restart_threshold:: $dsn = 'smtps://smtp.example.com?restart_threshold=10&restart_threshold_sleep=1' ping_threshold\nThe minimum number of seconds between two messages required to ping the server:: $dsn = 'smtps://smtp.example.com?ping_threshold=200' max_per_second\nThe number of messages to send per second (0 to disable this limitation)::", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_5", "source": "mailer.rst", "text": "$dsn = 'smtps://smtp.example.com?max_per_second=2' Custom Transport Factories If you want to support your own custom DSN (acme://...), you can create a\ncustom transport factory. To do so, create a class that implements\nSymfony\\\\Component\\\\Mailer\\\\Transport\\\\TransportFactoryInterface or, if\nyou prefer, extend the Symfony\\\\Component\\\\Mailer\\\\Transport\\\\AbstractTransportFactory\nclass to save some boilerplate code:: // src/Mailer/AcmeTransportFactory.php\nfinal class AcmeTransportFactory extends AbstractTransportFactory\n{\npublic function create(Dsn $dsn): TransportInterface\n{\n// parse the given DSN, extract data/credentials from it\n// and then, create and return the transport\n} protected function getSupportedSchemes(): array\n{\n// this supports DSN starting with `acme://`\nreturn ['acme'];\n}\n} After creating the custom transport class, register it as a service in your\napplication and tag it with the\nmailer.transport_factory tag. Creating & Sending Messages To send an email, get a Symfony\\\\Component\\\\Mailer\\\\Mailer\ninstance by type-hinting Symfony\\\\Component\\\\Mailer\\\\MailerInterface\nand create an Symfony\\\\Component\\\\Mime\\\\Email object:: // src/Controller/MailerController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Mailer\\MailerInterface;\nuse Symfony\\Component\\Mime\\Email;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class MailerController extends AbstractController\n{\n#[Route('/email')]\npublic function sendEmail(MailerInterface $mailer): Response\n{\n$email = (new Email())\n->from('hello@example.com')\n->to('you@example.com')\n//->cc('cc@example.com')\n//->bcc('bcc@example.com')\n//->replyTo('fabien@example.com')\n//->priority(Email::PRIORITY_HIGH)\n->subject('Time for Symfony Mailer!')\n->text('Sending emails is fun again!')\n->html('<p>See Twig integration for better HTML integration!</p>'); $mailer->send($email); // ...\n}\n} That's it! The message will be sent immediately via the transport you configured.\nIf you prefer to send emails asynchronously to improve performance, read the\nSending Messages Async section. Also, if\nyour application has the Messenger component installed, all\nemails will be sent asynchronously by default\n(but you can change that ). Email Addresses All the methods that require email addresses (from(), to(), etc.) accept\nboth strings or address objects:: // ...\nuse Symfony\\Component\\Mime\\Address; $email = (new Email())\n// email address as a simple string\n->from('fabien@example.com') // non-ASCII characters are supported both in the local part and the domain;\n// if the SMTP server doesn't support this feature, you'll see an exception\n->from('jânë.dœ@ëxãmplę.com') // email address as an object\n->from(new Address('fabien@example.com')) // defining the email address and name as an object\n// (email clients will display the name)\n->from(new Address('fabien@example.com', 'Fabien')) // defining the email address and name as a string\n// (the format must match: 'Name <email@example.com>')\n->from(Address::create('Fabien Potencier <fabien@example.com>')) // ...\n; Instead of calling ->from() *every* time you create a new email, you can\nconfigure emails globally to set the\nsame From email to all messages. Support for non-ASCII email addresses (e.g. jânë.dœ@ëxãmplę.com)\nwas introduced in Symfony 7.2. The local part of the address (what goes before the @) can include UTF-8\ncharacters, except for the sender address (to avoid issues with bounced emails).\nFor example: föóbàr@example.com, 用户@example.com, θσερ@example.com, etc. Use addTo(), addCc(), or addBcc() methods to add more addresses:: $email = (new Email())\n->to('foo@example.com')\n->addTo('bar@example.com')\n->cc('cc@example.com')\n->addCc('cc2@example.com') // ...\n; Alternatively, you can pass multiple addresses to each method:: $toAddresses = ['foo@example.com', new Address('bar@example.com')]; $email = (new Email())\n->to(...$toAddresses)\n->cc('cc1@example.com', 'cc2@example.com') // ...\n; Message Headers", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_6", "source": "mailer.rst", "text": "Messages include a number of header fields to describe their contents. Symfony\nsets all the required headers automatically, but you can set your own headers\ntoo. There are different types of headers (Id header, Mailbox header, Date\nheader, etc.) but most of the times you'll set text headers:: $email = (new Email())\n->getHeaders()\n// this non-standard header tells compliant autoresponders (\"email holiday mode\")\n// to not reply to this message because it's an automated email\n->addTextHeader('X-Auto-Response-Suppress', 'OOF, DR, RN, NRN, AutoReply') // use an array if you want to add a header with multiple values\n// (for example in the \"References\" or \"In-Reply-To\" header)\n->addIdHeader('References', ['123@example.com', '456@example.com']) // ...\n; Instead of calling ->addTextHeader() *every* time you create a new email, you can\nconfigure emails globally to set the same\nheaders to all sent emails. Message Contents The text and HTML contents of the email messages can be strings (usually the\nresult of rendering some template) or PHP resources:: $email = (new Email())\n// ...\n// simple contents defined as a string\n->text('Lorem ipsum...')\n->html('<p>Lorem ipsum...</p>') // attach a file stream\n->text(fopen('/path/to/emails/user_signup.txt', 'r'))\n->html(fopen('/path/to/emails/user_signup.html', 'r'))\n; You can also use Twig templates to render the HTML and text contents. Read\nthe `Twig: HTML & CSS`_ section later in this article to\nlearn more. File Attachments Use the addPart() method with a File to add files that exist on your\nfile system:: use Symfony\\Component\\Mime\\Part\\DataPart;\nuse Symfony\\Component\\Mime\\Part\\File;\n// ... $email = (new Email())\n// ...\n->addPart(new DataPart(new File('/path/to/documents/terms-of-use.pdf')))\n// optionally you can tell email clients to display a custom name for the file\n->addPart(new DataPart(new File('/path/to/documents/privacy.pdf'), 'Privacy Policy'))\n// optionally you can provide an explicit MIME type (otherwise it's guessed)\n->addPart(new DataPart(new File('/path/to/documents/contract.doc'), 'Contract', 'application/msword'))\n; Alternatively you can attach contents from a stream by passing it directly to\nthe DataPart:: $email = (new Email())\n// ...\n->addPart(new DataPart(fopen('/path/to/documents/contract.doc', 'r')))\n; Embedding Images If you want to display images inside your email, you must embed them\ninstead of adding them as attachments. When using Twig to render the email\ncontents, as explained later in this article ,\nthe images are embedded automatically. Otherwise, you need to embed them manually. First, use the addPart() method to add an image from a\nfile or stream:: $email = (new Email())\n// ...\n// get the image contents from a PHP resource\n->addPart((new DataPart(fopen('/path/to/images/logo.png', 'r'), 'logo', 'image/png'))->asInline())\n// get the image contents from an existing file\n->addPart((new DataPart(new File('/path/to/images/signature.gif'), 'footer-signature', 'image/gif'))->asInline())\n; Use the asInline() method to embed the content instead of attaching it. The second optional argument of both methods is the image name (\"Content-ID\" in\nthe MIME standard). Its value is an arbitrary string that must be unique in each\nemail message and is used later to reference the images inside the HTML contents:: $email = (new Email())\n// ...\n->addPart((new DataPart(fopen('/path/to/images/logo.png', 'r'), 'logo', 'image/png'))->asInline())\n->addPart((new DataPart(new File('/path/to/images/signature.gif'), 'footer-signature', 'image/gif'))->asInline()) // reference images using the syntax 'cid:' + \"image embed name\"\n->html('<img src=\"cid:logo\"> ... <img src=\"cid:footer-signature\"> ...')", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_7", "source": "mailer.rst", "text": "// use the same syntax for images included as HTML background images\n->html('... <div background=\"cid:footer-signature\"> ... </div> ...')\n; The actual Content-ID value present in the e-mail source will be randomly generated by Symfony.\nYou can also use the DataPart::setContentId()\nmethod to define a custom Content-ID for the image and use it as its cid reference:: $part = new DataPart(new File('/path/to/images/signature.gif'));\n// according to the spec, the Content-ID value must include at least one '@' character\n$part->setContentId('footer-signature@my-app'); $email = (new Email())\n// ...\n->addPart($part->asInline())\n->html('... <img src=\"cid:footer-signature@my-app\"> ...')\n; Configuring Emails Globally Instead of calling ->from() on each Email you create, you can configure this\nvalue globally so that it is set on all sent emails. The same is true with ->to()\nand headers. # config/packages/mailer.yaml\nframework:\nmailer:\nenvelope:\nsender: 'fabien@example.com'\nrecipients: ['foo@example.com', 'bar@example.com']\nheaders:\nFrom: 'Fabien <fabien@example.com>'\nBcc: 'baz@example.com'\nX-Custom-Header: 'foobar' <!-- config/packages/mailer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... -->\n<framework:config>\n<framework:mailer>\n<framework:envelope>\n<framework:sender>fabien@example.com</framework:sender>\n<framework:recipients>foo@example.com</framework:recipients>\n<framework:recipients>bar@example.com</framework:recipients>\n</framework:envelope>\n<framework:header name=\"From\">Fabien &lt;fabien@example.com&gt;</framework:header>\n<framework:header name=\"Bcc\">baz@example.com</framework:header>\n<framework:header name=\"X-Custom-Header\">foobar</framework:header>\n</framework:mailer>\n</framework:config>\n</container> // config/packages/mailer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$mailer = $framework->mailer();\n$mailer\n->envelope()\n->sender('fabien@example.com')\n->recipients(['foo@example.com', 'bar@example.com'])\n; $mailer->header('From')->value('Fabien <fabien@example.com>');\n$mailer->header('Bcc')->value('baz@example.com');\n$mailer->header('X-Custom-Header')->value('foobar');\n}; Some third-party providers don't support the usage of keywords like from\nin the headers. Check out your provider's documentation before setting\nany global header. Handling Sending Failures Symfony Mailer considers that sending was successful when your transport (SMTP\nserver or third-party provider) accepts the mail for further delivery. The message\ncan later be lost or not delivered because of some problem in your provider, but\nthat's out of reach for your Symfony application. If there's an error when handing over the email to your transport, Symfony throws\na Symfony\\\\Component\\\\Mailer\\\\Exception\\\\TransportExceptionInterface.\nCatch that exception to recover from the error or to display some message:: use Symfony\\Component\\Mailer\\Exception\\TransportExceptionInterface; $email = new Email();\n// ...\ntry {\n$mailer->send($email);\n} catch (TransportExceptionInterface $e) {\n// some error prevented the email sending; display an\n// error message or try to resend the message\n} Debugging Emails The send() method of the mailer service injected when using MailerInterface\ndoesn't return anything, so you can't access the sent email information. This is because\nit sends email messages **asynchronously** when the Messenger component\nis used in the application. To access information about the sent email, update your code to replace the\nSymfony\\\\Component\\\\Mailer\\\\MailerInterface with\nSymfony\\\\Component\\\\Mailer\\\\Transport\\\\TransportInterface: -use Symfony\\Component\\Mailer\\MailerInterface;\n+use Symfony\\Component\\Mailer\\Transport\\TransportInterface;\n// ... class MailerController extends AbstractController\n{\n#[Route('/email')]\n- public function sendEmail(MailerInterface $mailer): Response\n+ public function sendEmail(TransportInterface $mailer): Response\n{\n$email = (new Email())\n// ... $sentEmail = $mailer->send($email); // ...\n}\n} The send() method of TransportInterface returns an object of type\nSymfony\\\\Component\\\\Mailer\\\\SentMessage. This is because it always sends\nthe emails **synchronously**, even if your application uses the Messenger component. The SentMessage object provides access to the original message\n(getOriginalMessage()) and to some debug information (getDebug()) such\nas the HTTP calls done by the HTTP transports, which is useful to debug errors.", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_8", "source": "mailer.rst", "text": "You can also access the Symfony\\\\Component\\\\Mailer\\\\SentMessage object\nby listening to the SentMessageEvent , and retrieve\ngetDebug() by listening to the FailedMessageEvent . Some mailer providers change the Message-Id when sending the email. The\ngetMessageId() method from SentMessage always returns the final ID\nof the message - whether it's the original random ID generated by Symfony or\na new one generated by the provider. Exceptions related to mailer transports (those implementing\nSymfony\\\\Component\\\\Mailer\\\\Exception\\\\TransportException) also provide\nthis debug information via the getDebug() method. Twig: HTML & CSS The Mime component integrates with the Twig template engine\nto provide advanced features such as CSS style inlining and support for HTML/CSS\nframeworks to create complex HTML email messages. First, make sure Twig is installed: $ composer require symfony/twig-bundle # or if you're using the component in a non-Symfony app:\n# composer require symfony/twig-bridge HTML Content To define the contents of your email with Twig, use the\nSymfony\\\\Bridge\\\\Twig\\\\Mime\\\\TemplatedEmail class. This class extends\nthe normal Symfony\\\\Component\\\\Mime\\\\Email class but adds some new methods\nfor Twig templates:: use Symfony\\Bridge\\Twig\\Mime\\TemplatedEmail; $email = (new TemplatedEmail())\n->from('fabien@example.com')\n->to(new Address('ryan@example.com'))\n->subject('Thanks for signing up!') // path of the Twig template to render\n->htmlTemplate('emails/signup.html.twig') // change locale used in the template, e.g. to match user's locale\n->locale('de') // pass variables (name => value) to the template\n->context([\n'expiration_date' => new \\DateTime('+7 days'),\n'username' => 'foo',\n])\n; Then, create the template: {# templates/emails/signup.html.twig #}\n<h1>Welcome {{ email.toName }}!</h1> <p>\nYou signed up as {{ username }} the following email:\n</p>\n<p><code>{{ email.to[0].address }}</code></p> <p>\n<a href=\"#\">Activate your account</a>\n(this link is valid until {{ expiration_date|date('F jS') }})\n</p> The Twig template has access to any of the parameters passed in the context()\nmethod of the TemplatedEmail class and also to a special variable called\nemail, which is an instance of\nSymfony\\\\Bridge\\\\Twig\\\\Mime\\\\WrappedTemplatedEmail. Text Content When the text content of a TemplatedEmail is not explicitly defined, it is\nautomatically generated from the HTML contents. Symfony uses the following strategy when generating the text version of an\nemail: * If an explicit HTML to text converter has been configured (see\ntwig.mailer.html_to_text_converter\n), it calls it; * If not, and if you have `league/html-to-markdown`_ installed in your\napplication, it uses it to turn HTML into Markdown (so the text email has\nsome visual appeal); * Otherwise, it applies the strip_tags PHP function to the\noriginal HTML contents. If you want to define the text content yourself, use the text() method\nexplained in the previous sections or the textTemplate() method provided by\nthe TemplatedEmail class: +use Symfony\\Bridge\\Twig\\Mime\\TemplatedEmail; $email = (new TemplatedEmail())\n// ... ->htmlTemplate('emails/signup.html.twig')\n+ ->textTemplate('emails/signup.txt.twig')\n// ...\n; Embedding Images Instead of dealing with the <img src=\"cid: ...\"> syntax explained in the\nprevious sections, when using Twig to render email contents you can refer to\nimage files as usual. First, to simplify things, define a Twig namespace called\nimages that points to whatever directory your images are stored in: # config/packages/twig.yaml\ntwig:\n# ... paths:\n# point this wherever your images live\n'%kernel.project_dir%/assets/images': images", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_9", "source": "mailer.rst", "text": "<!-- config/packages/twig.xml -->\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:twig=\"http://symfony.com/schema/dic/twig\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\"> <twig:config>\n<!-- ... --> <!-- point this wherever your images live -->\n<twig:path namespace=\"images\">%kernel.project_dir%/assets/images</twig:path>\n</twig:config>\n</container> // config/packages/twig.php\nuse Symfony\\Config\\TwigConfig; return static function (TwigConfig $twig): void {\n// ... // point this wherever your images live\n$twig->path('%kernel.project_dir%/assets/images', 'images');\n}; Now, use the special email.image() Twig helper to embed the images inside\nthe email contents: {# '@images/' refers to the Twig namespace defined earlier #}\n<img src=\"{{ email.image('@images/logo.png') }}\" alt=\"Logo\"> <h1>Welcome {{ email.toName }}!</h1>\n{# ... #} By default this will create an attachment using the file path as file name:\nContent-Disposition: inline; name=\"cid...\"; filename=\"@images/logo.png\".\nThis behavior can be overridden by passing a custom file name as the third argument: <img src=\"{{ email.image('@images/logo.png', 'image/png', 'logo-acme.png') }}\" alt=\"ACME Logo\"> The third argument of email.image() was introduced in Symfony 7.3. Inlining CSS Styles Designing the HTML contents of an email is very different from designing a\nnormal HTML page. For starters, most email clients only support a subset of all\nCSS features. In addition, popular email clients like Gmail don't support\ndefining styles inside <style> ... </style> sections and you must **inline\nall the CSS styles**. CSS inlining means that every HTML tag must define a style attribute with\nall its CSS styles. This can make organizing your CSS a mess. That's why Twig\nprovides a CssInlinerExtension that automates everything for you. Install\nit with: $ composer require twig/extra-bundle twig/cssinliner-extra The extension is enabled automatically. To use it, wrap the entire template\nwith the inline_css filter: {% apply inline_css %}\n<style>\n{# here, define your CSS styles as usual #}\nh1 {\ncolor: #333;\n}\n</style> <h1>Welcome {{ email.toName }}!</h1>\n{# ... #}\n{% endapply %} Using External CSS Files\n........................ You can also define CSS styles in external files and pass them as\narguments to the filter: {% apply inline_css(source('@styles/email.css')) %}\n<h1>Welcome {{ username }}!</h1>\n{# ... #}\n{% endapply %} You can pass unlimited number of arguments to inline_css() to load multiple\nCSS files. For this example to work, you also need to define a new Twig namespace\ncalled styles that points to the directory where email.css lives: # config/packages/twig.yaml\ntwig:\n# ... paths:\n# point this wherever your css files live\n'%kernel.project_dir%/assets/styles': styles <!-- config/packages/twig.xml -->\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:twig=\"http://symfony.com/schema/dic/twig\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\"> <twig:config>\n<!-- ... --> <!-- point this wherever your css files live -->\n<twig:path namespace=\"styles\">%kernel.project_dir%/assets/styles</twig:path>\n</twig:config>\n</container> // config/packages/twig.php\nuse Symfony\\Config\\TwigConfig; return static function (TwigConfig $twig): void {\n// ... // point this wherever your css files live\n$twig->path('%kernel.project_dir%/assets/styles', 'styles');\n}; Rendering Markdown Content Twig provides another extension called MarkdownExtension that lets you\ndefine the email contents using `Markdown syntax`_. To use this, install the\nextension and a Markdown conversion library (the extension is compatible with\nseveral popular libraries): # instead of league/commonmark, you can also use erusev/parsedown or michelf/php-markdown\n$ composer require twig/extra-bundle twig/markdown-extra league/commonmark", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_10", "source": "mailer.rst", "text": "The extension adds a markdown_to_html filter, which you can use to convert parts or\nthe entire email contents from Markdown to HTML: {% apply markdown_to_html %}\nWelcome {{ email.toName }}! You signed up to our site using the following email:\n`{{ email.to[0].address }}` [Activate your account]({{ url('...') }})\n{% endapply %} Inky Email Templating Language Symfony recommends Inky, but you can also use `MJML`_, a more actively\nmaintained alternative for responsive email templates. Creating beautifully designed emails that work on every email client is so\ncomplex that there are HTML/CSS frameworks dedicated to that. One of the most\npopular frameworks is called `Inky`_. It defines a syntax based on some HTML-like\ntags which are later transformed into the real HTML code sent to users: <!-- a simplified example of the Inky syntax -->\n<container>\n<row>\n<columns>This is a column.</columns>\n</row>\n</container> Twig provides integration with Inky via the InkyExtension. First, install\nthe extension in your application: $ composer require twig/extra-bundle twig/inky-extra The extension adds an inky_to_html filter, which can be used to convert\nparts or the entire email contents from Inky to HTML: {% apply inky_to_html %}\n<container>\n<row class=\"header\">\n<columns>\n<spacer size=\"16\"></spacer>\n<h1 class=\"text-center\">Welcome {{ email.toName }}!</h1>\n</columns> {# ... #}\n</row>\n</container>\n{% endapply %} You can combine all filters to create complex email messages: {% apply inky_to_html|inline_css(source('@styles/foundation-emails.css')) %}\n{# ... #}\n{% endapply %} This makes use of the styles Twig namespace we created\nearlier. You could, for example, `download the foundation-emails.css file`_\ndirectly from GitHub and save it in assets/styles. Signing and Encrypting Messages It's possible to sign and/or encrypt email messages to increase their\nintegrity/security. Both options can be combined to encrypt a signed message\nand/or to sign an encrypted message. Before signing/encrypting messages, make sure to have: * The `OpenSSL PHP extension`_ properly installed and configured;\n* A valid `S/MIME`_ security certificate. When using OpenSSL to generate certificates, make sure to add the\n-addtrust emailProtection command option. Signing and encrypting messages require their contents to be fully rendered.\nFor example, the content of templated emails is rendered\nby a Symfony\\\\Component\\\\Mailer\\\\EventListener\\\\MessageListener.\nSo, if you want to sign and/or encrypt such a message, you need to do it in\na MessageEvent listener run after it (you need to set\na negative priority to your listener). Signing Messages When signing a message, a cryptographic hash is generated for the entire content\nof the message (including attachments). This hash is added as an attachment so\nthe recipient can validate the integrity of the received message. However, the\ncontents of the original message are still readable for mailing agents not\nsupporting signed messages, so you must also encrypt the message if you want to\nhide its contents.", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_11", "source": "mailer.rst", "text": "You can sign messages using either S/MIME or DKIM. In both cases, the\ncertificate and private key must be `PEM encoded`_, and can be either created\nusing for example OpenSSL or obtained at an official Certificate Authority (CA).\nThe email recipient must have the CA certificate in the list of trusted issuers\nin order to verify the signature. If you use message signature, sending to Bcc will be removed from the\nmessage. If you need to send a message to multiple recipients, you need\nto compute a new signature for each recipient. S/MIME Signer\n............. `S/MIME`_ is a standard for public key encryption and signing of MIME data. It\nrequires using both a certificate and a private key:: use Symfony\\Component\\Mime\\Crypto\\SMimeSigner;\nuse Symfony\\Component\\Mime\\Email; $email = (new Email())\n->from('hello@example.com')\n// ...\n->html('...'); $signer = new SMimeSigner('/path/to/certificate.crt', '/path/to/certificate-private-key.key');\n// if the private key has a passphrase, pass it as the third argument\n// new SMimeSigner('/path/to/certificate.crt', '/path/to/certificate-private-key.key', 'the-passphrase'); $signedEmail = $signer->sign($email);\n// now use the Mailer component to send this $signedEmail instead of the original email The SMimeSigner class defines other optional arguments to pass\nintermediate certificates and to configure the signing process using a\nbitwise operator options for openssl_pkcs7_sign PHP function. DKIM Signer\n........... `DKIM`_ is an email authentication method that affixes a digital signature,\nlinked to a domain name, to each outgoing email messages. It requires a private\nkey but not a certificate:: use Symfony\\Component\\Mime\\Crypto\\DkimSigner;\nuse Symfony\\Component\\Mime\\Email; $email = (new Email())\n->from('hello@example.com')\n// ...\n->html('...'); // first argument: same as openssl_pkey_get_private(), either a string with the\n// contents of the private key or the absolute path to it (prefixed with 'file://')\n// second and third arguments: the domain name and \"selector\" used to perform a DNS lookup\n// (the selector is a string used to point to a specific DKIM public key record in your DNS)\n$signer = new DkimSigner('file:///path/to/private-key.key', 'example.com', 'sf');\n// if the private key has a passphrase, pass it as the fifth argument\n// new DkimSigner('file:///path/to/private-key.key', 'example.com', 'sf', [], 'the-passphrase'); $signedEmail = $signer->sign($email);\n// now use the Mailer component to send this $signedEmail instead of the original email // DKIM signer provides many config options and a helper object to configure them\nuse Symfony\\Component\\Mime\\Crypto\\DkimOptions; $signedEmail = $signer->sign($email, (new DkimOptions())\n->bodyCanon('relaxed')\n->headerCanon('relaxed')\n->headersToIgnore(['Message-ID'])\n->toArray()\n); Signing Messages Globally\n......................... Instead of creating a signer instance for each email, you can configure a global\nsigner that automatically applies to all outgoing messages. This approach\nminimizes repetition and centralizes your configuration for DKIM and S/MIME signing. # config/packages/mailer.yaml\nframework:\nmailer:\ndkim_signer:\nkey: 'file://%kernel.project_dir%/var/certificates/dkim.pem'\ndomain: 'symfony.com'\nselect: 's1'\nsmime_signer:\nkey: '%kernel.project_dir%/var/certificates/smime.key'\ncertificate: '%kernel.project_dir%/var/certificates/smime.crt'\npassphrase: '' <!-- config/packages/mailer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... -->\n<framework:config>\n<framework:mailer>\n<framework:dkim-signer>\n<framework:key>file://%kernel.project_dir%/var/certificates/dkim.pem</framework:key>\n<framework:domain>symfony.com</framework:domain>\n<framework:select>s1</framework:select>\n</framework:dkim-signer>\n<framework:smime-signer>\n<framework:key>%kernel.project_dir%/var/certificates/smime.pem</framework:key>\n<framework:certificate>%kernel.project_dir%/var/certificates/smime.crt</framework:certificate>\n<framework:passphrase></framework:passphrase>\n</framework:smime-signer>\n</framework:mailer>\n</framework:config>\n</container> // config/packages/mailer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$mailer = $framework->mailer();\n$mailer->dsn('%env(MAILER_DSN)%');\n$mailer->dkimSigner()\n->key('file://%kernel.project_dir%/var/certificates/dkim.pem')\n->domain('symfony.com')\n->select('s1'); $mailer->smimeSigner()\n->key('%kernel.project_dir%/var/certificates/smime.key')\n->certificate('%kernel.project_dir%/var/certificates/smime.crt')\n->passphrase('')\n;\n}; Global message signing was introduced in Symfony 7.3. Encrypting Messages", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_12", "source": "mailer.rst", "text": "When encrypting a message, the entire message (including attachments) is\nencrypted using a certificate. Therefore, only the recipients that have the\ncorresponding private key can read the original message contents:: use Symfony\\Component\\Mime\\Crypto\\SMimeEncrypter;\nuse Symfony\\Component\\Mime\\Email; $email = (new Email())\n->from('hello@example.com')\n// ...\n->html('...'); $encrypter = new SMimeEncrypter('/path/to/certificate.crt');\n$encryptedEmail = $encrypter->encrypt($email);\n// now use the Mailer component to send this $encryptedEmail instead of the original email You can pass more than one certificate to the SMimeEncrypter constructor\nand it will select the appropriate certificate depending on the To option:: $firstEmail = (new Email())\n// ...\n->to('jane@example.com'); $secondEmail = (new Email())\n// ...\n->to('john@example.com'); // the second optional argument of SMimeEncrypter defines which encryption algorithm is used\n// (it must be one of these constants: https://www.php.net/manual/en/openssl.ciphers.php)\n$encrypter = new SMimeEncrypter([\n// key = email recipient; value = path to the certificate file\n'jane@example.com' => '/path/to/first-certificate.crt',\n'john@example.com' => '/path/to/second-certificate.crt',\n]); $firstEncryptedEmail = $encrypter->encrypt($firstEmail);\n$secondEncryptedEmail = $encrypter->encrypt($secondEmail); Encrypting Messages Globally\n............................ Instead of creating a new encrypter for each email, you can configure a global S/MIME\nencrypter that automatically applies to all outgoing messages: # config/packages/mailer.yaml\nframework:\nmailer:\nsmime_encrypter:\nrepository: App\\Security\\LocalFileCertificateRepository <!-- config/packages/mailer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... -->\n<framework:config>\n<framework:mailer>\n<framework:smime-encrypter>\n<framework:repository>App\\Security\\LocalFileCertificateRepository</framework:repository>\n</framework:smime-encrypter>\n</framework:mailer>\n</framework:config>\n</container> // config/packages/mailer.php\nuse App\\Security\\LocalFileCertificateRepository;\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$mailer = $framework->mailer();\n$mailer->smimeEncrypter()\n->repository(LocalFileCertificateRepository::class)\n;\n}; The repository option is the ID of a service that implements\nSymfony\\\\Component\\\\Mailer\\\\EventListener\\\\SmimeCertificateRepositoryInterface.\nThis interface requires only one method: findCertificatePathFor(), which must\nreturn the file path to the certificate associated with the given email address:: namespace App\\Security; use Symfony\\Component\\DependencyInjection\\Attribute\\Autowire;\nuse Symfony\\Component\\Mailer\\EventListener\\SmimeCertificateRepositoryInterface; class LocalFileCertificateRepository implements SmimeCertificateRepositoryInterface\n{\npublic function __construct(\n#[Autowire(param: 'kernel.project_dir')]\nprivate readonly string $projectDir\n){} public function findCertificatePathFor(string $email): ?string\n{\n$hash = hash('sha256', strtolower(trim($email)));\n$path = sprintf('%s/storage/%s.crt', $this->projectDir, $hash); return file_exists($path) ? $path : null;\n}\n} Global message encryption configuration was introduced in Symfony 7.3. Multiple Email Transports You may want to use more than one mailer transport for delivery of your messages.\nThis can be configured by replacing the dsn configuration entry with a\ntransports entry, like: # config/packages/mailer.yaml\nframework:\nmailer:\ntransports:\nmain: '%env(MAILER_DSN)%'\nalternative: '%env(MAILER_DSN_IMPORTANT)%' <!-- config/packages/mailer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... -->\n<framework:config>\n<framework:mailer>\n<framework:transport name=\"main\">%env(MAILER_DSN)%</framework:transport>\n<framework:transport name=\"alternative\">%env(MAILER_DSN_IMPORTANT)%</framework:transport>\n</framework:mailer>\n</framework:config>\n</container> // config/packages/mailer.php\nuse Symfony\\Config\\FrameworkConfig;\nuse function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env; return static function (FrameworkConfig $framework): void {\n$framework->mailer()\n->transport('main', env('MAILER_DSN'))\n->transport('alternative', env('MAILER_DSN_IMPORTANT'))\n;\n}; By default the first transport is used. The other transports can be selected by\nadding an X-Transport header (which Mailer will remove automatically from\nthe final email):: // Send using first transport (\"main\"):\n$mailer->send($email); // ... or use the transport \"alternative\":\n$email->getHeaders()->addTextHeader('X-Transport', 'alternative');\n$mailer->send($email); Sending Messages Async When you call $mailer->send($email), the email is sent to the transport immediately.\nTo improve performance, you can leverage Messenger to send\nthe messages later via a Messenger transport.", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_13", "source": "mailer.rst", "text": "Start by following the Messenger documentation and configuring\na transport. Once everything is set up, when you call $mailer->send(), a\nSymfony\\\\Component\\\\Mailer\\\\Messenger\\\\SendEmailMessage message will\nbe dispatched through the default message bus (messenger.default_bus). Assuming\nyou have a transport called async, you can route the message there: # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nasync: \"%env(MESSENGER_TRANSPORT_DSN)%\" routing:\n'Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage': async <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:transport name=\"async\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport>\n<framework:routing message-class=\"Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage\">\n<framework:sender service=\"async\"/>\n</framework:routing>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->messenger()\n->transport('async')->dsn(env('MESSENGER_TRANSPORT_DSN')); $framework->messenger()\n->routing('Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage')\n->senders(['async']);\n}; Thanks to this, instead of being delivered immediately, messages will be sent\nto the transport to be handled later (see messenger-worker). Note that\nthe \"rendering\" of the email (computed headers, body rendering, ...) is also\ndeferred and will only happen just before the email is sent by the Messenger\nhandler. When sending an email asynchronously, its instance must be serializable.\nThis is always the case for Symfony\\\\Component\\\\Mailer\\\\Mailer\ninstances, but when sending a\nSymfony\\\\Bridge\\\\Twig\\\\Mime\\\\TemplatedEmail, you must ensure that\nthe context is serializable. If you have non-serializable variables,\nlike Doctrine entities, either replace them with more specific variables or\nrender the email before calling $mailer->send($email):: use Symfony\\Component\\Mailer\\MailerInterface;\nuse Symfony\\Component\\Mime\\BodyRendererInterface; public function action(MailerInterface $mailer, BodyRendererInterface $bodyRenderer): void\n{\n$email = (new TemplatedEmail())\n->htmlTemplate($template)\n->context($context)\n;\n$bodyRenderer->render($email); $mailer->send($email);\n} You can configure which bus is used to dispatch the message using the message_bus option.\nYou can also set this to false to call the Mailer transport directly and\ndisable asynchronous delivery. # config/packages/mailer.yaml\nframework:\nmailer:\nmessage_bus: app.another_bus <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:mailer\nmessage_bus=\"app.another_bus\"\n>\n</framework:mailer>\n</framework:config>\n</container> // config/packages/mailer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->mailer()\n->messageBus('app.another_bus');\n}; In cases of long-running scripts, and when Mailer uses the\nSymfony\\\\Component\\\\Mailer\\\\Transport\\\\Smtp\\\\SmtpTransport\nyou may manually disconnect from the SMTP server to avoid keeping\nan open connection to the SMTP server in between sending emails.\nYou can do so by using the stop() method. You can also select the transport by adding an X-Bus-Transport header (which\nwill be removed automatically from the final message):: // Use the bus transport \"app.another_bus\":\n$email->getHeaders()->addTextHeader('X-Bus-Transport', 'app.another_bus');\n$mailer->send($email); Adding Tags and Metadata to Emails Certain 3rd party transports support email *tags* and *metadata*, which can be used\nfor grouping, tracking and workflows. You can add those by using the\nSymfony\\\\Component\\\\Mailer\\\\Header\\\\TagHeader and\nSymfony\\\\Component\\\\Mailer\\\\Header\\\\MetadataHeader classes. If your transport\nsupports headers, it will convert them to their appropriate format:: use Symfony\\Component\\Mailer\\Header\\MetadataHeader;\nuse Symfony\\Component\\Mailer\\Header\\TagHeader; $email->getHeaders()->add(new TagHeader('password-reset'));\n$email->getHeaders()->add(new MetadataHeader('Color', 'blue'));\n$email->getHeaders()->add(new MetadataHeader('Client-ID', '12345')); If your transport does not support tags and metadata, they will be added as custom headers: X-Tag: password-reset\nX-Metadata-Color: blue\nX-Metadata-Client-ID: 12345 The following transports currently support tags and metadata: * Brevo\n* Mailgun\n* Mailtrap\n* Mandrill\n* Postmark\n* Sendgrid The following transports only support tags: * MailPace\n* Resend The following transports only support metadata:", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_14", "source": "mailer.rst", "text": "* Amazon SES (note that Amazon refers to this feature as \"tags\", but Symfony\ncalls it \"metadata\" because it contains a key and a value) Draft Emails Symfony\\\\Component\\\\Mime\\\\DraftEmail is a special instance of\nSymfony\\\\Component\\\\Mime\\\\Email. Its purpose is to build up an email\n(with body, attachments, etc) and make available to download as an .eml with\nthe X-Unsent header. Many email clients can open these files and interpret\nthem as *draft emails*. You can use these to create advanced mailto: links. Here's an example of making one available to download:: // src/Controller/DownloadEmailController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\Mime\\DraftEmail;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class DownloadEmailController extends AbstractController\n{\n#[Route('/download-email')]\npublic function __invoke(): Response\n{\n$message = (new DraftEmail())\n->html($this->renderView(/* ... */))\n->addPart(/* ... */)\n; $response = new Response($message->toString());\n$contentDisposition = $response->headers->makeDisposition(\nResponseHeaderBag::DISPOSITION_ATTACHMENT,\n'download.eml'\n);\n$response->headers->set('Content-Type', 'message/rfc822');\n$response->headers->set('Content-Disposition', $contentDisposition); return $response;\n}\n} As it's possible for Symfony\\\\Component\\\\Mime\\\\DraftEmail's to be created\nwithout a To/From they cannot be sent with the mailer. Mailer Events MessageEvent **Event Class**: Symfony\\\\Component\\\\Mailer\\\\Event\\\\MessageEvent MessageEvent allows to change the Mailer message and the envelope before\nthe email is sent:: use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Mailer\\Event\\MessageEvent;\nuse Symfony\\Component\\Mime\\Email; public function onMessage(MessageEvent $event): void\n{\n$message = $event->getMessage();\nif (!$message instanceof Email) {\nreturn;\n}\n// do something with the message (logging, ...) // and/or add some Messenger stamps\n$event->addStamp(new SomeMessengerStamp());\n} If you want to stop the Message from being sent, call reject() (it will\nalso stop the event propagation):: use Symfony\\Component\\Mailer\\Event\\MessageEvent; public function onMessage(MessageEvent $event): void\n{\n$event->reject();\n} Execute this command to find out which listeners are registered for this event\nand their priorities: $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\MessageEvent\" SentMessageEvent **Event Class**: Symfony\\\\Component\\\\Mailer\\\\Event\\\\SentMessageEvent SentMessageEvent allows you to act on the Symfony\\\\Component\\\\Mailer\\\\SentMessage\nclass to access the original message (getOriginalMessage()) and some\ndebugging information (getDebug()) such as\nthe HTTP calls made by the HTTP transports, which is useful for debugging errors:: use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Mailer\\Event\\SentMessageEvent; public function onMessage(SentMessageEvent $event): void\n{\n$message = $event->getMessage(); // do something with the message (e.g. get its id)\n} Execute this command to find out which listeners are registered for this event\nand their priorities: $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\SentMessageEvent\" FailedMessageEvent **Event Class**: Symfony\\\\Component\\\\Mailer\\\\Event\\\\FailedMessageEvent FailedMessageEvent allows acting on the initial message in case of a failure\nand some debugging information (getDebug())\nsuch as the HTTP calls made by the HTTP transports, which is useful for debugging errors:: use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Mailer\\Event\\FailedMessageEvent;\nuse Symfony\\Component\\Mailer\\Exception\\TransportExceptionInterface; public function onMessage(FailedMessageEvent $event): void\n{\n// e.g you can get more information on this error when sending an email\n$error = $event->getError();\nif ($error instanceof TransportExceptionInterface) {\n$error->getDebug();\n} // do something with the message\n} Execute this command to find out which listeners are registered for this event\nand their priorities: $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\FailedMessageEvent\" Development & Debugging Enabling an Email Catcher", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_15", "source": "mailer.rst", "text": "When developing locally, it is recommended to use an email catcher. If you have\nenabled Docker support via Symfony recipes, an email catcher is automatically\nconfigured. In addition, if you are using the Symfony CLI\ntool, the mailer DSN is automatically exposed via the\nsymfony binary Docker integration . Sending Test Emails Symfony provides a command to send emails, which is useful during development\nto test if sending emails works correctly: # the only mandatory argument is the recipient address\n# (check the command help to learn about its options)\n$ php bin/console mailer:test someone@example.com This command bypasses the Messenger bus , if configured, to\nease testing emails even when the Messenger consumer is not running. Disabling Delivery While developing (or testing), you may want to disable delivery of messages\nentirely. You can do this by using null://null as the mailer DSN, either in\nyour .env configuration files or in\nthe mailer configuration file (e.g. in the dev or test environments): # config/packages/mailer.yaml\nwhen@dev:\nframework:\nmailer:\ndsn: 'null://null' <!-- config/packages/mailer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... -->\n<framework:config>\n<framework:mailer dsn=\"null://null\"/>\n</framework:config>\n</container> // config/packages/mailer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n// ...\n$framework->mailer()\n->dsn('null://null');\n}; If you're using Messenger and routing to a transport, the message will *still*\nbe sent to that transport. Always Send to the same Address Instead of disabling delivery entirely, you might want to *always* send emails to\na specific address, instead of the *real* address: # config/packages/mailer.yaml\nwhen@dev:\nframework:\nmailer:\nenvelope:\nrecipients: ['youremail@example.com'] <!-- config/packages/mailer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... -->\n<framework:config>\n<framework:mailer>\n<framework:envelope>\n<framework:recipient>youremail@example.com</framework:recipient>\n</framework:envelope>\n</framework:mailer>\n</framework:config>\n</container> // config/packages/mailer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n// ...\n$framework->mailer()\n->envelope()\n->recipients(['youremail@example.com'])\n;\n}; Use the allowed_recipients option to define specific addresses that should\nstill receive their original emails. These messages will also be sent to the\naddress(es) defined in recipients, as with all other emails: # config/packages/mailer.yaml\nwhen@dev:\nframework:\nmailer:\nenvelope:\nrecipients: ['youremail@example.com']\nallowed_recipients:\n- 'internal@example.com'\n# you can also use regular expression to define allowed recipients\n- 'internal-.*@example.(com|fr)' <!-- config/packages/mailer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... -->\n<framework:config>\n<framework:mailer>\n<framework:envelope>\n<framework:recipient>youremail@example.com</framework:recipient>\n<framework:allowed-recipient>internal@example.com</framework:allowed-recipient>\n<!-- you can also use regular expression to define allowed recipients -->\n<framework:allowed-recipient>internal-.*@example.(com|fr)</framework:allowed-recipient>\n</framework:envelope>\n</framework:mailer>\n</framework:config>\n</container> // config/packages/mailer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n// ...\n$framework->mailer()\n->envelope()\n->recipients(['youremail@example.com'])\n->allowedRecipients([\n'internal@example.com',\n// you can also use regular expression to define allowed recipients\n'internal-.*@example.(com|fr)',\n])\n;\n}; With this configuration, all emails will be sent to youremail@example.com.\nAdditionally, emails sent to internal@example.com, internal-monitoring@example.fr,\netc., will also be delivered to those addresses. The allowed_recipients option was introduced in Symfony 7.1. Write a Functional Test", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_sem_16", "source": "mailer.rst", "text": "Symfony provides lots of built-in mailer assertions\nto functionally test that an email was sent, its contents or headers, etc.\nThey are available in test classes extending\nSymfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\KernelTestCase or when using\nthe Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\MailerAssertionsTrait:: // tests/Controller/MailControllerTest.php\nnamespace App\\Tests\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase; class MailControllerTest extends WebTestCase\n{\npublic function testMailIsSentAndContentIsOk(): void\n{\n$client = static::createClient();\n$client->request('GET', '/mail/send');\n$this->assertResponseIsSuccessful(); $this->assertEmailCount(1); // use assertQueuedEmailCount() when using Messenger $email = $this->getMailerMessage(); $this->assertEmailHtmlBodyContains($email, 'Welcome');\n$this->assertEmailTextBodyContains($email, 'Welcome');\n}\n} If your controller returns a redirect response after sending the email, make\nsure to have your client *not* follow redirects. The kernel is rebooted after\nfollowing the redirection and the message will be lost from the mailer event\nhandler.", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "messenger.rst_sem_0", "source": "messenger.rst", "text": "Messenger: Sync & Queued Message Handling Messenger provides a message bus with the ability to send messages and then\nhandle them immediately in your application or send them through transports\n(e.g. queues) to be handled later. To learn more about it, read the\nMessenger component docs . Installation In applications using Symfony Flex , run this command to\ninstall messenger: $ composer require symfony/messenger Creating a Message & Handler Messenger centers around two different classes that you'll create: (1) a message\nclass that holds data and (2) a handler(s) class that will be called when that\nmessage is dispatched. The handler class will read the message class and perform\none or more tasks. There are no specific requirements for a message class, except that it can be\nserialized:: // src/Message/SmsNotification.php\nnamespace App\\Message; class SmsNotification\n{\npublic function __construct(\nprivate string $content,\n) {\n} public function getContent(): string\n{\nreturn $this->content;\n}\n} A message handler is a PHP callable, the recommended way to create it is to\ncreate a class that has the Symfony\\\\Component\\\\Messenger\\\\Attribute\\\\AsMessageHandler\nattribute and has an __invoke() method that's type-hinted with the\nmessage class (or a message interface):: // src/MessageHandler/SmsNotificationHandler.php\nnamespace App\\MessageHandler; use App\\Message\\SmsNotification;\nuse Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler; #[AsMessageHandler]\nclass SmsNotificationHandler\n{\npublic function __invoke(SmsNotification $message)\n{\n// ... do some work - like sending an SMS message!\n}\n} You can also use the #[AsMessageHandler] attribute on individual class\nmethods. You may use the attribute on as many methods in a single class as you\nlike, allowing you to group the handling of multiple related types of messages. Thanks to autoconfiguration and the SmsNotification\ntype-hint, Symfony knows that this handler should be called when an SmsNotification\nmessage is dispatched. Most of the time, this is all you need to do. But you can\nalso manually configure message handlers . To\nsee all the configured handlers, run: $ php bin/console debug:messenger Dispatching the Message You're ready! To dispatch the message (and call the handler), inject the\nmessenger.default_bus service (via the MessageBusInterface), like in a controller:: // src/Controller/DefaultController.php\nnamespace App\\Controller; use App\\Message\\SmsNotification;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Messenger\\MessageBusInterface; class DefaultController extends AbstractController\n{\npublic function index(MessageBusInterface $bus): Response\n{\n// will cause the SmsNotificationHandler to be called\n$bus->dispatch(new SmsNotification('Look! I created a message!')); // ...\n}\n} Transports: Async/Queued Messages By default, messages are handled as soon as they are dispatched. If you want\nto handle a message asynchronously, you can configure a transport. A transport\nis capable of sending messages (e.g. to a queueing system) and then\nreceiving them via a worker . Messenger supports\nmultiple transports . If you want to use a transport that's not supported, check out the\n`Enqueue's transport`_, which backs services like Kafka and Google\nPub/Sub. A transport is registered using a \"DSN\". Thanks to Messenger's Flex recipe, your\n.env file already has a few examples. # MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages\n# MESSENGER_TRANSPORT_DSN=doctrine://default\n# MESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages Uncomment whichever transport you want (or set it in .env.local). See\nmessenger-transports-config for more details.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_1", "source": "messenger.rst", "text": "Next, in config/packages/messenger.yaml, let's define a transport called async\nthat uses this configuration: # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nasync: \"%env(MESSENGER_TRANSPORT_DSN)%\" # or expanded to configure more options\n#async:\n# dsn: \"%env(MESSENGER_TRANSPORT_DSN)%\"\n# options: [] <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:transport name=\"async\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport> <!-- or expanded to configure more options -->\n<framework:transport name=\"async\"\ndsn=\"%env(MESSENGER_TRANSPORT_DSN)%\"\n>\n<option key=\"...\">...</option>\n</framework:transport>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->messenger()\n->transport('async')\n->dsn(env('MESSENGER_TRANSPORT_DSN'))\n; $framework->messenger()\n->transport('async')\n->dsn(env('MESSENGER_TRANSPORT_DSN'))\n->options([])\n;\n}; Routing Messages to a Transport Now that you have a transport configured, instead of handling a message immediately,\nyou can configure them to be sent to a transport: // src/Message/SmsNotification.php\nnamespace App\\Message; use Symfony\\Component\\Messenger\\Attribute\\AsMessage; #[AsMessage('async')]\nclass SmsNotification\n{\n// ...\n} # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nasync: \"%env(MESSENGER_TRANSPORT_DSN)%\" routing:\n# async is whatever name you gave your transport above\n'App\\Message\\SmsNotification': async <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:routing message-class=\"App\\Message\\SmsNotification\">\n<!-- async is whatever name you gave your transport above -->\n<framework:sender service=\"async\"/>\n</framework:routing>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->messenger()\n// async is whatever name you gave your transport above\n->routing('App\\Message\\SmsNotification')->senders(['async'])\n;\n}; The #[AsMessage] attribute was introduced in Symfony 7.2. Thanks to this, the App\\Message\\SmsNotification will be sent to the async\ntransport and its handler(s) will *not* be called immediately. Any messages not\nmatched under routing will still be handled immediately, i.e. synchronously. If you configure routing with both YAML/XML/PHP configuration files and\nPHP attributes, the configuration always takes precedence over the class\nattribute. This behavior allows you to override routing on a per-environment basis. When configuring the routing in separate YAML/XML/PHP files, you can use a partial\nPHP namespace like 'App\\Message\\*' to match all the messages within the\nmatching namespace. The only requirement is that the '*' wildcard has to\nbe placed at the end of the namespace. You may use '*' as the message class. This will act as a default routing\nrule for any message not matched under routing. This is useful to ensure\nno message is handled synchronously by default. The only drawback is that '*' will also apply to the emails sent with the\nSymfony Mailer (which uses SendEmailMessage when Messenger is available).\nThis could cause issues if your emails are not serializable (e.g. if they include\nfile attachments as PHP resources/streams). You can also route classes by their parent class or interface. Or send messages\nto multiple transports: // src/Message/SmsNotification.php\nnamespace App\\Message; use Symfony\\Component\\Messenger\\Attribute\\AsMessage; #[AsMessage(['async', 'audit'])]\nclass SmsNotification\n{\n// ...\n} // if you prefer, you can also apply multiple attributes to the message class\n#[AsMessage('async')]\n#[AsMessage('audit')]\nclass SmsNotification\n{\n// ...\n} # config/packages/messenger.yaml\nframework:\nmessenger:\nrouting:\n# route all messages that extend this example base class or interface\n'App\\Message\\AbstractAsyncMessage': async\n'App\\Message\\AsyncMessageInterface': async 'My\\Message\\ToBeSentToTwoSenders': [async, audit]", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_2", "source": "messenger.rst", "text": "<!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<!-- route all messages that extend this example base class or interface -->\n<framework:routing message-class=\"App\\Message\\AbstractAsyncMessage\">\n<framework:sender service=\"async\"/>\n</framework:routing>\n<framework:routing message-class=\"App\\Message\\AsyncMessageInterface\">\n<framework:sender service=\"async\"/>\n</framework:routing>\n<framework:routing message-class=\"My\\Message\\ToBeSentToTwoSenders\">\n<framework:sender service=\"async\"/>\n<framework:sender service=\"audit\"/>\n</framework:routing>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger();\n// route all messages that extend this example base class or interface\n$messenger->routing('App\\Message\\AbstractAsyncMessage')->senders(['async']);\n$messenger->routing('App\\Message\\AsyncMessageInterface')->senders(['async']);\n$messenger->routing('My\\Message\\ToBeSentToTwoSenders')->senders(['async', 'audit']);\n}; If you configure routing for both a child and parent class, both rules\nare used. E.g. if you have an SmsNotification object that extends\nfrom Notification, both the routing for Notification and\nSmsNotification will be used. You can define and override the transport that a message is using at\nruntime by using the\nSymfony\\\\Component\\\\Messenger\\\\Stamp\\\\TransportNamesStamp on\nthe envelope of the message. This stamp takes an array of transport\nname as its only argument. For more information about stamps, see\n`Envelopes & Stamps`_. Doctrine Entities in Messages If you need to pass a Doctrine entity in a message, it's better to pass the entity's\nprimary key (or whatever relevant information the handler actually needs, like email,\netc.) instead of the object (otherwise you might see errors related to the Entity Manager):: // src/Message/NewUserWelcomeEmail.php\nnamespace App\\Message; class NewUserWelcomeEmail\n{\npublic function __construct(\nprivate int $userId,\n) {\n} public function getUserId(): int\n{\nreturn $this->userId;\n}\n} Then, in your handler, you can query for a fresh object:: // src/MessageHandler/NewUserWelcomeEmailHandler.php\nnamespace App\\MessageHandler; use App\\Message\\NewUserWelcomeEmail;\nuse App\\Repository\\UserRepository;\nuse Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler; #[AsMessageHandler]\nclass NewUserWelcomeEmailHandler\n{\npublic function __construct(\nprivate UserRepository $userRepository,\n) {\n} public function __invoke(NewUserWelcomeEmail $welcomeEmail): void\n{\n$user = $this->userRepository->find($welcomeEmail->getUserId()); // ... send an email!\n}\n} This guarantees the entity contains fresh data. Handling Messages Synchronously If a message doesn't match any routing rules , it won't\nbe sent to any transport and will be handled immediately. In some cases (like\nwhen `binding handlers to different transports`_),\nit's easier or more flexible to handle this explicitly: by creating a sync\ntransport and \"sending\" messages there to be handled immediately: # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\n# ... other transports sync: 'sync://' routing:\nApp\\Message\\SmsNotification: sync <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<!-- ... other transports --> <framework:transport name=\"sync\" dsn=\"sync://\"/> <framework:routing message-class=\"App\\Message\\SmsNotification\">\n<framework:sender service=\"sync\"/>\n</framework:routing>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); // ... other transports $messenger->transport('sync')->dsn('sync://');\n$messenger->routing('App\\Message\\SmsNotification')->senders(['sync']);\n}; Creating your Own Transport You can also create your own transport if you need to send or receive messages\nfrom something that is not supported. See /messenger/custom-transport. Consuming Messages (Running the Worker) Once your messages have been routed, in most cases, you'll need to \"consume\" them.\nYou can do this with the messenger:consume command: $ php bin/console messenger:consume async # use -vv to see details about what's happening\n$ php bin/console messenger:consume async -vv", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_3", "source": "messenger.rst", "text": "The first argument is the receiver's name (or service id if you routed to a\ncustom service). By default, the command will run forever: looking for new messages\non your transport and handling them. This command is called your \"worker\". If you want to consume messages from all available receivers, you can use the\ncommand with the --all option: $ php bin/console messenger:consume --all The --all option was introduced in Symfony 7.1. Messages that take a long time to process may be redelivered prematurely because\nsome transports assume that an unacknowledged message is lost. To prevent this\nissue, use the --keepalive command option to specify an interval (in seconds;\ndefault value = 5) at which the message is marked as \"in progress\". This prevents\nthe message from being redelivered until the worker completes processing it: $ php bin/console messenger:consume --keepalive This option is only available for the following transports: Beanstalkd, AmazonSQS, Doctrine and Redis. The --keepalive option was introduced in Symfony 7.2. In a development environment and if you're using the Symfony CLI tool,\nyou can configure workers to be automatically run along with the webserver.\nYou can find more information in the\nSymfony CLI Workers documentation. To properly stop a worker, throw an instance of\nSymfony\\\\Component\\\\Messenger\\\\Exception\\\\StopWorkerException. Deploying to Production On production, there are a few important things to think about: **Use a Process Manager like Supervisor or systemd to keep your worker(s) running**\nYou'll want one or more \"workers\" running at all times. To do that, use a\nprocess control system like Supervisor\nor systemd . **Don't Let Workers Run Forever**\nSome services (like Doctrine's EntityManager) will consume more memory\nover time. So, instead of allowing your worker to run forever, use a flag\nlike messenger:consume --limit=10 to tell your worker to only handle 10\nmessages before exiting (then the process manager will create a new process). There\nare also other options like --memory-limit=128M and --time-limit=3600. **Stopping Workers That Encounter Errors**\nIf a worker dependency like your database server is down, or timeout is reached,\nyou can try to add reconnect logic , or just quit\nthe worker if it receives too many errors with the --failure-limit option of\nthe messenger:consume command. **Restart Workers on Deploy**\nEach time you deploy, you'll need to restart all your worker processes so\nthat they see the newly deployed code. To do this, run messenger:stop-workers\non deployment. This will signal to each worker that it should finish the message\nit's currently handling and should shut down gracefully. Then, the process manager\nwill create new worker processes. The command uses the app\ncache internally - so make sure this is configured to use an adapter you like.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_4", "source": "messenger.rst", "text": "**Use the Same Cache Between Deploys**\nIf your deploy strategy involves the creation of new target directories, you\nshould set a value for the cache.prefix_seed\nconfiguration option in order to use the same cache namespace between deployments.\nOtherwise, the cache.app pool will use the value of the kernel.project_dir\nparameter as base for the namespace, which will lead to different namespaces\neach time a new deployment is made. Prioritized Transports Sometimes certain types of messages should have a higher priority and be handled\nbefore others. To make this possible, you can create multiple transports and route\ndifferent messages to them. For example: # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nasync_priority_high:\ndsn: '%env(MESSENGER_TRANSPORT_DSN)%'\noptions:\n# queue_name is specific to the doctrine transport\nqueue_name: high # for AMQP send to a separate exchange then queue\n#exchange:\n# name: high\n#queues:\n# messages_high: ~\n# for redis try \"group\"\nasync_priority_low:\ndsn: '%env(MESSENGER_TRANSPORT_DSN)%'\noptions:\nqueue_name: low routing:\n'App\\Message\\SmsNotification': async_priority_low\n'App\\Message\\NewUserWelcomeEmail': async_priority_high <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\">\n<framework:options>\n<framework:queue>\n<framework:name>Queue</framework:name>\n</framework:queue>\n</framework:options>\n</framework:transport>\n<framework:transport name=\"async_priority_low\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\">\n<option key=\"queue_name\">low</option>\n</framework:transport> <framework:routing message-class=\"App\\Message\\SmsNotification\">\n<framework:sender service=\"async_priority_low\"/>\n</framework:routing>\n<framework:routing message-class=\"App\\Message\\NewUserWelcomeEmail\">\n<framework:sender service=\"async_priority_high\"/>\n</framework:routing>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); $messenger->transport('async_priority_high')\n->dsn(env('MESSENGER_TRANSPORT_DSN'))\n->options(['queue_name' => 'high']); $messenger->transport('async_priority_low')\n->dsn(env('MESSENGER_TRANSPORT_DSN'))\n->options(['queue_name' => 'low']); $messenger->routing('App\\Message\\SmsNotification')->senders(['async_priority_low']);\n$messenger->routing('App\\Message\\NewUserWelcomeEmail')->senders(['async_priority_high']);\n}; You can then run individual workers for each transport or instruct one worker\nto handle messages in a priority order: $ php bin/console messenger:consume async_priority_high async_priority_low The worker will always first look for messages waiting on async_priority_high. If\nthere are none, *then* it will consume messages from async_priority_low. Limit Consuming to Specific Queues Some transports (notably AMQP) have the concept of exchanges and queues. A Symfony\ntransport is always bound to an exchange. By default, the worker consumes from all\nqueues attached to the exchange of the specified transport. However, there are use\ncases to want a worker to only consume from specific queues. You can limit the worker to only process messages from specific queue(s): $ php bin/console messenger:consume my_transport --queues=fasttrack # you can pass the --queues option more than once to process multiple queues\n$ php bin/console messenger:consume my_transport --queues=fasttrack1 --queues=fasttrack2 To allow using the queues option, the receiver must implement the\nSymfony\\\\Component\\\\Messenger\\\\Transport\\\\Receiver\\\\QueueReceiverInterface. Checking the Number of Queued Messages Per Transport Run the messenger:stats command to know how many messages are in the \"queues\"\nof some or all transports: # displays the number of queued messages in all transports\n$ php bin/console messenger:stats # shows stats only for some transports\n$ php bin/console messenger:stats my_transport_name other_transport_name # you can also output the stats in JSON format\n$ php bin/console messenger:stats --format=json\n$ php bin/console messenger:stats my_transport_name other_transport_name --format=json The format option was introduced in Symfony 7.2. In order for this command to work, the configured transport's receiver must implement\nSymfony\\\\Component\\\\Messenger\\\\Transport\\\\Receiver\\\\MessageCountAwareInterface. Supervisor Configuration", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_5", "source": "messenger.rst", "text": "Supervisor is a great tool to guarantee that your worker process(es) is\n*always* running (even if it closes due to failure, hitting a message limit\nor thanks to messenger:stop-workers). You can install it on Ubuntu, for\nexample, via: $ sudo apt-get install supervisor Supervisor configuration files typically live in a /etc/supervisor/conf.d\ndirectory. For example, you can create a new messenger-worker.conf file\nthere to make sure that 2 instances of messenger:consume are running at all\ntimes: ;/etc/supervisor/conf.d/messenger-worker.conf\n[program:messenger-consume]\ncommand=php /path/to/your/app/bin/console messenger:consume async --time-limit=3600\nuser=ubuntu\nnumprocs=2\nstartsecs=0\nautostart=true\nautorestart=true\nstartretries=10\nprocess_name=%(program_name)s_%(process_num)02d Change the async argument to use the name of your transport (or transports)\nand user to the Unix user on your server. During a deployment, something might be unavailable (e.g. the\ndatabase) causing the consumer to fail to start. In this situation,\nSupervisor will try startretries number of times to restart the\ncommand. Make sure to change this setting to avoid getting the command\nin a FATAL state, which will never restart again. Each restart, Supervisor increases the delay by 1 second. For instance, if\nthe value is 10, it will wait 1 sec, 2 sec, 3 sec, etc. This gives the\nservice a total of 55 seconds to become available again. Increase the\nstartretries setting to cover the maximum expected downtime. If you use the Redis Transport, note that each worker needs a unique consumer\nname to avoid the same message being handled by multiple workers. One way to\nachieve this is to set an environment variable in the Supervisor configuration\nfile, which you can then refer to in messenger.yaml\n(see the Redis section below): environment=MESSENGER_CONSUMER_NAME=%(program_name)s_%(process_num)02d Next, tell Supervisor to read your config and start your workers: $ sudo supervisorctl reread $ sudo supervisorctl update $ sudo supervisorctl start messenger-consume:* # If you deploy an update of your code, don't forget to restart your workers\n# to run the new code\n$ sudo supervisorctl restart messenger-consume:* See the `Supervisor docs`_ for more details. Graceful Shutdown\n................. If you install the `PCNTL`_ PHP extension in your project, workers will handle\nthe SIGTERM or SIGINT POSIX signals to finish processing their current\nmessage before terminating. However, you might prefer to use different POSIX signals for graceful shutdown.\nYou can override default ones by setting the framework.messenger.stop_worker_on_signals\nconfiguration option: # config/packages/messenger.yaml\nframework:\nmessenger:\nstop_worker_on_signals:\n- SIGTERM\n- SIGINT\n- SIGUSR1 <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<!-- ... -->\n<framework:stop-worker-on-signal>SIGTERM</framework:stop-worker-on-signal>\n<framework:stop-worker-on-signal>SIGINT</framework:stop-worker-on-signal>\n<framework:stop-worker-on-signal>SIGUSR1</framework:stop-worker-on-signal>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->messenger()\n->stopWorkerOnSignals(['SIGTERM', 'SIGINT', 'SIGUSR1']);\n}; Support for signals plain names in configuration was introduced in Symfony 7.3.\nPreviously, you had to use the numeric values of signals as defined by the\npcntl extension's `predefined constants`_.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_6", "source": "messenger.rst", "text": "In some cases the SIGTERM signal is sent by Supervisor itself (e.g. stopping\na Docker container having Supervisor as its entrypoint). In these cases you\nneed to add a stopwaitsecs key to the program configuration (with a value\nof the desired grace period in seconds) in order to perform a graceful shutdown: [program:x]\nstopwaitsecs=20 Systemd Configuration While Supervisor is a great tool, it has the disadvantage that you need system\naccess to run it. Systemd has become the standard on most Linux distributions,\nand has a good alternative called *user services*. Systemd user service configuration files typically live in a ~/.config/systemd/user\ndirectory. For example, you can create a new messenger-worker.service file. Or a\nmessenger-worker@.service file if you want more instances running at the same time: [Unit]\nDescription=Symfony messenger-consume %i [Service]\nExecStart=php /path/to/your/app/bin/console messenger:consume async --time-limit=3600\n# for Redis, set a custom consumer name for each instance\nEnvironment=\"MESSENGER_CONSUMER_NAME=symfony-%n-%i\"\nRestart=always\nRestartSec=30 [Install]\nWantedBy=default.target Now, tell systemd to enable and start one worker: $ systemctl --user enable messenger-worker@1.service\n$ systemctl --user start messenger-worker@1.service # to enable and start 20 workers\n$ systemctl --user enable messenger-worker@{1..20}.service\n$ systemctl --user start messenger-worker@{1..20}.service If you change your service config file, you need to reload the daemon: $ systemctl --user daemon-reload To restart all your consumers: $ systemctl --user restart messenger-consume@*.service The systemd user instance is only started after the first login of the\nparticular user. Consumer often need to start on system boot instead.\nEnable lingering on the user to activate that behavior: $ loginctl enable-linger <your-username> Logs are managed by journald and can be worked with using the journalctl\ncommand: # follow logs of consumer nr 11\n$ journalctl -f --user-unit messenger-consume@11.service # follow logs of all consumers\n$ journalctl -f --user-unit messenger-consume@* # follow all logs from your user services\n$ journalctl -f _UID=$UID See the `systemd docs`_ for more details. You either need elevated privileges for the journalctl command, or add\nyour user to the systemd-journal group: $ sudo usermod -a -G systemd-journal <your-username> Stateless Worker PHP is designed to be stateless, there are no shared resources across different\nrequests. In HTTP context PHP cleans everything after sending the response, so\nyou can decide to not take care of services that may leak memory. On the other hand, it's common for workers to process messages sequentially in\nlong-running CLI processes which don't finish after processing a single message.\nBeware about service states to prevent information and/or memory leakage as\nSymfony will inject the same instance of a service in all messages, preserving\nthe internal state of the services. However, certain Symfony services, such as the Monolog\nfingers crossed handler , leak by design.\nSymfony provides a **service reset** feature to solve this problem. When resetting\nthe container automatically between two messages, Symfony looks for any services\nimplementing Symfony\\\\Contracts\\\\Service\\\\ResetInterface (including your\nown services) and calls their reset() method so they can clean their internal state.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_7", "source": "messenger.rst", "text": "If a service is not stateless and you want to reset its properties after each message, then\nthe service must implement Symfony\\\\Contracts\\\\Service\\\\ResetInterface where you can reset the\nproperties in the reset() method. If you don't want to reset the container, add the --no-reset option when\nrunning the messenger:consume command. Rate Limited Transport Sometimes you might need to rate limit your message worker. You can configure a\nrate limiter on a transport (requires the RateLimiter component )\nby setting its rate_limiter option: # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nasync:\nrate_limiter: your_rate_limiter_name <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:transport name=\"async\">\n<option key=\"rate_limiter\">your_rate_limiter_name</option>\n</framework:transport>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework) {\n$framework->messenger()\n->transport('async')\n->options(['rate_limiter' => 'your_rate_limiter_name'])\n;\n}; When a rate limiter is configured on a transport, it will block the whole\nworker when the limit is hit. You should make sure you configure a dedicated\nworker for a rate limited transport to avoid other transports to be blocked. Retries & Failures If an exception is thrown while consuming a message from a transport it will\nautomatically be re-sent to the transport to be tried again. By default, a message\nwill be retried 3 times before being discarded or\nsent to the failure transport . Each retry\nwill also be delayed, in case the failure was due to a temporary issue. All of\nthis is configurable for each transport: # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nasync_priority_high:\ndsn: '%env(MESSENGER_TRANSPORT_DSN)%' # default configuration\nretry_strategy:\nmax_retries: 3\n# milliseconds delay\ndelay: 1000\n# causes the delay to be higher before each retry\n# e.g. 1 second delay, 2 seconds, 4 seconds\nmultiplier: 2\nmax_delay: 0\n# applies randomness to the delay that can prevent the thundering herd effect\n# the value (between 0 and 1.0) is the percentage of 'delay' that will be added/subtracted\njitter: 0.1\n# override all of this with a service that\n# implements Symfony\\Component\\Messenger\\Retry\\RetryStrategyInterface\n# service: null <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%?queue_name=high_priority\">\n<framework:retry-strategy max-retries=\"3\" delay=\"1000\" multiplier=\"2\" max-delay=\"0\" jitter=\"0.1\"/>\n</framework:transport>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); $messenger->transport('async_priority_high')\n->dsn(env('MESSENGER_TRANSPORT_DSN'))\n// default configuration\n->retryStrategy()\n->maxRetries(3)\n// milliseconds delay\n->delay(1000)\n// causes the delay to be higher before each retry\n// e.g. 1 second delay, 2 seconds, 4 seconds\n->multiplier(2)\n->maxDelay(0)\n// applies randomness to the delay that can prevent the thundering herd effect\n// the value (between 0 and 1.0) is the percentage of 'delay' that will be added/subtracted\n->jitter(0.1)\n// override all of this with a service that\n// implements Symfony\\Component\\Messenger\\Retry\\RetryStrategyInterface\n->service(null)\n;\n}; The jitter option was introduced in Symfony 7.1. Symfony triggers a Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageRetriedEvent\nwhen a message is retried so you can run your own logic. Thanks to Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\SerializedMessageStamp,\nthe serialized form of the message is saved, which prevents to serialize it\nagain if the message is later retried. Avoiding Retrying", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_8", "source": "messenger.rst", "text": "Sometimes handling a message might fail in a way that you *know* is permanent\nand should not be retried. If you throw\nSymfony\\\\Component\\\\Messenger\\\\Exception\\\\UnrecoverableMessageHandlingException,\nthe message will not be retried. Messages that will not be retried, will still show up in the configured failure transport.\nIf you want to avoid that, consider handling the error yourself and let the handler\nsuccessfully end. Forcing Retrying Sometimes handling a message must fail in a way that you *know* is temporary\nand must be retried. If you throw\nSymfony\\\\Component\\\\Messenger\\\\Exception\\\\RecoverableMessageHandlingException,\nthe message will always be retried infinitely and max_retries setting will be ignored. You can define a custom retry delay in milliseconds (e.g., to use the value from\nthe Retry-After header in an HTTP response) by setting the retryDelay\nargument in the constructor of the RecoverableMessageHandlingException. The retryDelay argument and the getRetryDelay() method were introduced\nin Symfony 7.2. Saving & Retrying Failed Messages If a message fails it is retried multiple times (max_retries) and then will\nbe discarded. To avoid this happening, you can instead configure a failure_transport: # config/packages/messenger.yaml\nframework:\nmessenger:\n# after retrying, messages will be sent to the \"failed\" transport\nfailure_transport: failed transports:\n# ... other transports failed: 'doctrine://default?queue_name=failed' <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<!-- after retrying, messages will be sent to the \"failed\" transport -->\n<framework:messenger failure-transport=\"failed\">\n<!-- ... other transports --> <framework:transport name=\"failed\" dsn=\"doctrine://default?queue_name=failed\"/>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); // after retrying, messages will be sent to the \"failed\" transport\n$messenger->failureTransport('failed'); // ... other transports $messenger->transport('failed')\n->dsn('doctrine://default?queue_name=failed');\n}; In this example, if handling a message fails 3 times (default max_retries),\nit will then be sent to the failed transport. While you *can* use\nmessenger:consume failed to consume this like a normal transport, you'll\nusually want to manually view the messages in the failure transport and choose\nto retry them: # see all messages in the failure transport with a default limit of 50\n$ php bin/console messenger:failed:show # see the 10 first messages\n$ php bin/console messenger:failed:show --max=10 # see only App\\Message\\MyMessage messages\n$ php bin/console messenger:failed:show --class-filter='App\\Message\\MyMessage' # see the number of messages by message class\n$ php bin/console messenger:failed:show --stats # see details about a specific failure\n$ php bin/console messenger:failed:show 20 -vv # for each message, this command asks whether to retry, skip, or delete\n$ php bin/console messenger:failed:retry -vv # retry specific messages\n$ php bin/console messenger:failed:retry 20 30 --force # remove a message without retrying it\n$ php bin/console messenger:failed:remove 20 # remove messages without retrying them and show each message before removing it\n$ php bin/console messenger:failed:remove 20 30 --show-messages # remove all messages in the failure transport\n$ php bin/console messenger:failed:remove --all # remove only App\\Message\\MyMessage messages\n$ php bin/console messenger:failed:remove --class-filter='App\\Message\\MyMessage'", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_9", "source": "messenger.rst", "text": "If the message fails again, it will be re-sent back to the failure transport\ndue to the normal retry rules . Once the max\nretry has been hit, the message will be discarded permanently. The option to skip a message in the messenger:failed:retry command was\nintroduced in Symfony 7.2 The option to filter by a message class in the messenger:failed:remove command was\nintroduced in Symfony 7.3 Multiple Failed Transports Sometimes it is not enough to have a single, global failed transport configured\nbecause some messages are more important than others. In those cases, you can\noverride the failure transport for only specific transports: # config/packages/messenger.yaml\nframework:\nmessenger:\n# after retrying, messages will be sent to the \"failed\" transport\n# by default if no \"failed_transport\" is configured inside a transport\nfailure_transport: failed_default transports:\nasync_priority_high:\ndsn: '%env(MESSENGER_TRANSPORT_DSN)%'\nfailure_transport: failed_high_priority # since no failed transport is configured, the one used will be\n# the global \"failure_transport\" set\nasync_priority_low:\ndsn: 'doctrine://default?queue_name=async_priority_low' failed_default: 'doctrine://default?queue_name=failed_default'\nfailed_high_priority: 'doctrine://default?queue_name=failed_high_priority' <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<!-- after retrying, messages will be sent to the \"failed\" transport\nby default if no \"failed-transport\" is configured inside a transport -->\n<framework:messenger failure-transport=\"failed_default\">\n<framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\" failure-transport=\"failed_high_priority\"/>\n<!-- since no \"failed_transport\" is configured, the one used will be\nthe global \"failed_transport\" set -->\n<framework:transport name=\"async_priority_low\" dsn=\"doctrine://default?queue_name=async_priority_low\"/> <framework:transport name=\"failed_default\" dsn=\"doctrine://default?queue_name=failed_default\"/>\n<framework:transport name=\"failed_high_priority\" dsn=\"doctrine://default?queue_name=failed_high_priority\"/>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); // after retrying, messages will be sent to the \"failed\" transport\n// by default if no \"failure_transport\" is configured inside a transport\n$messenger->failureTransport('failed_default'); $messenger->transport('async_priority_high')\n->dsn(env('MESSENGER_TRANSPORT_DSN'))\n->failureTransport('failed_high_priority'); // since no failed transport is configured, the one used will be\n// the global failure_transport set\n$messenger->transport('async_priority_low')\n->dsn('doctrine://default?queue_name=async_priority_low'); $messenger->transport('failed_default')\n->dsn('doctrine://default?queue_name=failed_default'); $messenger->transport('failed_high_priority')\n->dsn('doctrine://default?queue_name=failed_high_priority');\n}; If there is no failure_transport defined globally or on the transport level,\nthe messages will be discarded after the number of retries. The failed commands have an optional option --transport to specify\nthe failure_transport configured at the transport level. # see all messages in \"failure_transport\" transport\n$ php bin/console messenger:failed:show --transport=failure_transport # retry specific messages from \"failure_transport\"\n$ php bin/console messenger:failed:retry 20 30 --transport=failure_transport --force # remove a message without retrying it from \"failure_transport\"\n$ php bin/console messenger:failed:remove 20 --transport=failure_transport Transport Configuration Messenger supports a number of different transport types, each with their own\noptions. Options can be passed to the transport via a DSN string or configuration. # .env\nMESSENGER_TRANSPORT_DSN=amqp://localhost/%2f/messages?auto_setup=false # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nmy_transport:\ndsn: \"%env(MESSENGER_TRANSPORT_DSN)%\"\noptions:\nauto_setup: false <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:transport name=\"my_transport\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\">\n<framework:options auto-setup=\"false\"/>\n</framework:transport>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); $messenger->transport('my_transport')\n->dsn(env('MESSENGER_TRANSPORT_DSN'))\n->options(['auto_setup' => false]);\n}; Options defined under options take precedence over ones defined in the DSN. AMQP Transport The AMQP transport uses the AMQP PHP extension to send messages to queues like\nRabbitMQ. Install it by running:", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_10", "source": "messenger.rst", "text": "$ composer require symfony/amqp-messenger The AMQP transport DSN may look like this: # .env\nMESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages # or use the AMQPS protocol\nMESSENGER_TRANSPORT_DSN=amqps://guest:guest@localhost/%2f/messages If you want to use TLS/SSL encrypted AMQP, you must also provide a CA certificate.\nDefine the certificate path in the amqp.cacert PHP.ini setting\n(e.g. amqp.cacert = /etc/ssl/certs) or in the cacert parameter of the\nDSN (e.g amqps://localhost?cacert=/etc/ssl/certs/). The default port used by TLS/SSL encrypted AMQP is 5671, but you can overwrite\nit in the port parameter of the DSN (e.g. amqps://localhost?cacert=/etc/ssl/certs/&port=12345). By default, the transport will automatically create any exchanges, queues and\nbinding keys that are needed. That can be disabled, but some functionality\nmay not work correctly (like delayed queues).\nTo not autocreate any queues, you can configure a transport with queues: []. You can limit the consumer of an AMQP transport to only process messages\nfrom some queues of an exchange. See messenger-limit-queues. The transport has a number of other options, including ways to configure\nthe exchange, queues binding keys and more. See the documentation on\nSymfony\\\\Component\\\\Messenger\\\\Bridge\\\\Amqp\\\\Transport\\\\Connection. The transport has a number of options: auto_setup (default: true)\nWhether the exchanges and queues should be created automatically during\nsend / get. cacert\nPath to the CA cert file in PEM format. cert\nPath to the client certificate in PEM format. channel_max\nSpecifies highest channel number that the server permits. 0 means standard\nextension limit confirm_timeout\nTimeout in seconds for confirmation; if none specified, transport will not\nwait for message confirmation. Note: 0 or greater seconds. May be\nfractional. connect_timeout\nConnection timeout. Note: 0 or greater seconds. May be fractional. frame_max\nThe largest frame size that the server proposes for the connection,\nincluding frame header and end-byte. 0 means standard extension limit\n(depends on librabbimq default frame size limit) heartbeat\nThe delay, in seconds, of the connection heartbeat that the server wants. 0\nmeans the server does not want a heartbeat. Note, librabbitmq has limited\nheartbeat support, which means heartbeats checked only during blocking\ncalls. host\nHostname of the AMQP service key\nPath to the client key in PEM format. login\nUsername to use to connect the AMQP service password\nPassword to use to connect to the AMQP service persistent (default: 'false')\nWhether the connection is persistent port\nPort of the AMQP service read_timeout\nTimeout in for income activity. Note: 0 or greater seconds. May be\nfractional. retry\n(no description available) sasl_method\n(no description available) connection_name\nFor custom connection names (requires at least version 1.10 of the PHP AMQP\nextension) verify\nEnable or disable peer verification. If peer verification is enabled then\nthe common name in the server certificate must match the server name. Peer\nverification is enabled by default. vhost\nVirtual Host to use with the AMQP service write_timeout\nTimeout in for outcome activity. Note: 0 or greater seconds. May be\nfractional. delay[queue_name_pattern] (default: delay_%exchange_name%_%routing_key%_%delay%)\nPattern to use to create the queues delay[exchange_name] (default: delays)\nName of the exchange to be used for the delayed/retried messages queues[name][arguments]\nExtra arguments", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_11", "source": "messenger.rst", "text": "queues[name][binding_arguments]\nArguments to be used while binding the queue. queues[name][binding_keys]\nThe binding keys (if any) to bind to this queue queues[name][flags] (default: AMQP_DURABLE)\nQueue flags exchange[arguments]\nExtra arguments for the exchange (e.g. alternate-exchange) exchange[default_publish_routing_key]\nRouting key to use when publishing, if none is specified on the message exchange[flags] (default: AMQP_DURABLE)\nExchange flags exchange[name]\nName of the exchange. Use an empty string to use the default exchange. exchange[type] (default: fanout)\nType of exchange Empty string support for exchange[name] was introduced in Symfony 7.3. You can also configure AMQP-specific settings on your message by adding\nSymfony\\\\Component\\\\Messenger\\\\Bridge\\\\Amqp\\\\Transport\\\\AmqpStamp to\nyour Envelope:: use Symfony\\Component\\Messenger\\Bridge\\Amqp\\Transport\\AmqpStamp;\n// ... $attributes = [];\n$bus->dispatch(new SmsNotification(), [\nnew AmqpStamp('custom-routing-key', AMQP_NOPARAM, $attributes),\n]); The consumers do not show up in an admin panel as this transport does not rely on\n\\AmqpQueue::consume() which is blocking. Having a blocking receiver makes\nthe --time-limit/--memory-limit options of the messenger:consume command as well as\nthe messenger:stop-workers command inefficient, as they all rely on the fact that\nthe receiver returns immediately no matter if it finds a message or not. The consume\nworker is responsible for iterating until it receives a message to handle and/or until one\nof the stop conditions is reached. Thus, the worker's stop logic cannot be reached if it\nis stuck in a blocking call. If your application faces socket exceptions or `high connection churn`_\n(shown by the rapid creation and deletion of connections), consider using\n`AMQProxy`_. This tool works as a gateway between Symfony Messenger and AMQP server,\nmaintaining stable connections and minimizing overheads (which also improves\nthe overall performance). Doctrine Transport The Doctrine transport can be used to store messages in a database table.\nInstall it by running: $ composer require symfony/doctrine-messenger The Doctrine transport DSN may look like this: # .env\nMESSENGER_TRANSPORT_DSN=doctrine://default The format is doctrine://<connection_name>, in case you have multiple connections\nand want to use one other than the \"default\". The transport will automatically create\na table named messenger_messages. If you want to change the default table name, pass a custom table name in the\nDSN by using the table_name option: # .env\nMESSENGER_TRANSPORT_DSN=doctrine://default?table_name=your_custom_table_name Or, to create the table yourself, set the auto_setup option to false and\ngenerate a migration . The transport has a number of options: table_name (default: messenger_messages)\nName of the table queue_name (default: default)\nName of the queue (a column in the table, to use one table for multiple\ntransports) redeliver_timeout (default: 3600)\nTimeout before retrying a message that's in the queue but in the \"handling\"\nstate (if a worker stopped for some reason, this will occur, eventually you\nshould retry the message) - in seconds. Set redeliver_timeout to a greater value than your longest message\nduration. Otherwise, some messages will start a second time while the\nfirst one is still being handled. auto_setup\nWhether the table should be created automatically during send / get.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_12", "source": "messenger.rst", "text": "When using PostgreSQL, you have access to the following options to leverage\nthe `LISTEN/NOTIFY`_ feature. This allow for a more performant approach\nthan the default polling behavior of the Doctrine transport because\nPostgreSQL will directly notify the workers when a new message is inserted\nin the table. use_notify (default: true)\nWhether to use LISTEN/NOTIFY. check_delayed_interval (default: 60000)\nThe interval to check for delayed messages, in milliseconds. Set to 0 to\ndisable checks. get_notify_timeout (default: 0)\nThe length of time to wait for a response when calling\nPDO::pgsqlGetNotify, in milliseconds. The Doctrine transport supports the --keepalive option by periodically updating\nthe delivered_at timestamp to prevent the message from being redelivered. Keepalive support was introduced in Symfony 7.3. Beanstalkd Transport The Beanstalkd transport sends messages directly to a Beanstalkd work queue. Install\nit by running: $ composer require symfony/beanstalkd-messenger The Beanstalkd transport DSN may looks like this: # .env\nMESSENGER_TRANSPORT_DSN=beanstalkd://localhost:11300?tube_name=foo&timeout=4&ttr=120 # If no port, it will default to 11300\nMESSENGER_TRANSPORT_DSN=beanstalkd://localhost The transport has a number of options: bury_on_reject (default: false)\nWhen set to true, rejected messages are placed into a \"buried\" state\nin Beanstalkd instead of being deleted. The bury_on_reject option was introduced in Symfony 7.3. timeout (default: 0)\nMessage reservation timeout - in seconds. 0 will cause the server to\nimmediately return either a response or a TransportException will be thrown. ttr (default: 90)\nThe message time to run before it is put back in the ready queue - in\nseconds. tube_name (default: default)\nName of the queue The Beanstalkd transport supports the --keepalive option by using Beanstalkd's\ntouch command to periodically reset the job's ttr. Keepalive support was introduced in Symfony 7.2. The Beanstalkd transport lets you set the priority of the messages being dispatched.\nUse the Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\Beanstalkd\\\\Transport\\\\BeanstalkdPriorityStamp\nand pass a number to specify the priority (default = 1024; lower numbers mean higher priority):: use App\\Message\\SomeMessage;\nuse Symfony\\Component\\Messenger\\Stamp\\BeanstalkdPriorityStamp; $this->bus->dispatch(new SomeMessage('some data'), [\n// 0 = highest priority\n// 2**32 - 1 = lowest priority\nnew BeanstalkdPriorityStamp(0),\n]); BeanstalkdPriorityStamp support was introduced in Symfony 7.3. Redis Transport The Redis transport uses `streams`_ to queue messages. This transport requires\nthe Redis PHP extension (>=4.3) and a running Redis server (^5.0). Install it by\nrunning: $ composer require symfony/redis-messenger The Redis transport DSN may looks like this: # .env\nMESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages\n# Full DSN Example\nMESSENGER_TRANSPORT_DSN=redis://password@localhost:6379/messages/symfony/consumer?auto_setup=true&serializer=1&stream_max_entries=0&dbindex=0\n# Redis Cluster Example\nMESSENGER_TRANSPORT_DSN=redis://host-01:6379,redis://host-02:6379,redis://host-03:6379,redis://host-04:6379\n# Unix Socket Example\nMESSENGER_TRANSPORT_DSN=redis:///var/run/redis.sock\n# TLS Example\nMESSENGER_TRANSPORT_DSN=rediss://localhost:6379/messages\n# Multiple Redis Sentinel Hosts Example\nMESSENGER_TRANSPORT_DSN=redis:?host[redis1:26379]&host[redis2:26379]&host[redis3:26379]&sentinel_master=db A number of options can be configured via the DSN or via the options key\nunder the transport in messenger.yaml: stream (default: messages)\nThe Redis stream name group (default: symfony)\nThe Redis consumer group name consumer (default: consumer)\nConsumer name used in Redis. Allows setting an explicit consumer name identifier.\nRecommended in environments with multiple workers to prevent duplicate message\nprocessing. Typically set via an environment variable: # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nredis:\ndsn: '%env(MESSENGER_TRANSPORT_DSN)%'\noptions:\nconsumer: '%env(MESSENGER_CONSUMER_NAME)%' auto_setup (default: true)\nWhether to create the Redis group automatically auth\nThe Redis password", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_13", "source": "messenger.rst", "text": "delete_after_ack (default: true)\nIf true, messages are deleted automatically after processing them delete_after_reject (default: true)\nIf true, messages are deleted automatically if they are rejected lazy (default: false)\nConnect only when a connection is really needed serializer (default: Redis::SERIALIZER_PHP)\nHow to serialize the final payload in Redis (the Redis::OPT_SERIALIZER option) stream_max_entries (default: 0)\nThe maximum number of entries which the stream will be trimmed to. Set it to\na large enough number to avoid losing pending messages redeliver_timeout (default: 3600)\nTimeout (in seconds) before retrying a pending message which is owned by an abandoned consumer\n(if a worker died for some reason, this will occur, eventually you should retry the message). claim_interval (default: 60000)\nInterval on which pending/abandoned messages should be checked for to claim - in milliseconds persistent_id (default: null)\nString, if null connection is non-persistent. retry_interval (default: 0)\nInt, value in milliseconds read_timeout (default: 0)\nFloat, value in seconds default indicates unlimited timeout (default: 0)\nConnection timeout. Float, value in seconds default indicates unlimited sentinel_master (default: null)\nString, if null or empty Sentinel support is disabled redis_sentinel (default: null)\nAn alias of the sentinel_master option The redis_sentinel option was introduced in Symfony 7.1. ssl (default: null)\nMap of `SSL context options`_ for the TLS channel. This is useful for example\nto change the requirements for the TLS channel in tests: # config/packages/test/messenger.yaml\nframework:\nmessenger:\ntransports:\nredis:\ndsn: \"rediss://localhost\"\noptions:\nssl:\nallow_self_signed: true\ncapture_peer_cert: true\ncapture_peer_cert_chain: true\ndisable_compression: true\nSNI_enabled: true\nverify_peer: true\nverify_peer_name: true There should never be more than one messenger:consume command running with the same\ncombination of stream, group and consumer, or messages could end up being\nhandled more than once. If you run multiple queue workers, consumer can be set to an\nenvironment variable, like %env(MESSENGER_CONSUMER_NAME)%, set by Supervisor\n(example below) or any other service used to manage the worker processes.\nIn a container environment, the HOSTNAME can be used as the consumer name, since\nthere is only one worker per container/host. If using Kubernetes to orchestrate the\ncontainers, consider using a StatefulSet to have stable names. Set delete_after_ack to true (if you use a single group) or define\nstream_max_entries (if you can estimate how many max entries is acceptable\nin your case) to avoid memory leaks. Otherwise, all messages will remain\nforever in Redis. The Redis transport supports the --keepalive option by using Redis's XCLAIM\ncommand to periodically reset the message's idle time to zero. Keepalive support was introduced in Symfony 7.3. In Memory Transport The in-memory transport does not actually deliver messages. Instead, it\nholds them in memory during the request, which can be useful for testing.\nFor example, if you have an async_priority_normal transport, you could\noverride it in the test environment to use this transport: # config/packages/test/messenger.yaml\nframework:\nmessenger:\ntransports:\nasync_priority_normal: 'in-memory://' <!-- config/packages/test/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:transport name=\"async_priority_normal\" dsn=\"in-memory://\"/>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/test/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger();", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_14", "source": "messenger.rst", "text": "$messenger->transport('async_priority_normal')\n->dsn('in-memory://');\n}; Then, while testing, messages will *not* be delivered to the real transport.\nEven better, in a test, you can check that exactly one message was sent\nduring a request:: // tests/Controller/DefaultControllerTest.php\nnamespace App\\Tests\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase;\nuse Symfony\\Component\\Messenger\\Transport\\InMemory\\InMemoryTransport; class DefaultControllerTest extends WebTestCase\n{\npublic function testSomething(): void\n{\n$client = static::createClient();\n// ... $this->assertSame(200, $client->getResponse()->getStatusCode()); /** @var InMemoryTransport $transport */\n$transport = $this->getContainer()->get('messenger.transport.async_priority_normal');\n$this->assertCount(1, $transport->getSent());\n}\n} The transport has a number of options: serialize (boolean, default: false)\nWhether to serialize messages or not. This is useful to test an additional\nlayer, especially when you use your own message serializer. All in-memory transports will be reset automatically after each test **in**\ntest classes extending\nSymfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\KernelTestCase\nor Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\WebTestCase. Amazon SQS The Amazon SQS transport is perfect for applications hosted on AWS. Install it by\nrunning: $ composer require symfony/amazon-sqs-messenger The SQS transport DSN may looks like this: # .env\nMESSENGER_TRANSPORT_DSN=https://sqs.eu-west-3.amazonaws.com/123456789012/messages?access_key=AKIAIOSFODNN7EXAMPLE&secret_key=j17M97ffSVoKI0briFoo9a\nMESSENGER_TRANSPORT_DSN=sqs://localhost:9494/messages?sslmode=disable The transport will automatically create queues that are needed. This\ncan be disabled by setting the auto_setup option to false. Before sending or receiving a message, Symfony needs to convert the queue\nname into an AWS queue URL by calling the GetQueueUrl API in AWS. This\nextra API call can be avoided by providing a DSN which is the queue URL. The transport has a number of options: access_key\nAWS access key (must be urlencoded) account (default: The owner of the credentials)\nIdentifier of the AWS account auto_setup (default: true)\nWhether the queue should be created automatically during send / get. buffer_size (default: 9)\nNumber of messages to prefetch debug (default: false)\nIf true it logs all HTTP requests and responses (it impacts performance) endpoint (default: https://sqs.eu-west-1.amazonaws.com)\nAbsolute URL to the SQS service poll_timeout (default: 0.1)\nWait for new message duration in seconds queue_name (default: messages)\nName of the queue queue_attributes\nAttributes of a queue as per `SQS CreateQueue API`_. Array of strings indexed by keys of AsyncAws\\Sqs\\Enum\\QueueAttributeName. queue_tags\nCost allocation tags of a queue as per `SQS CreateQueue API`_. Array of strings indexed by strings. region (default: eu-west-1)\nName of the AWS region secret_key\nAWS secret key (must be urlencoded) session_token\nAWS session token visibility_timeout (default: Queue's configuration)\nAmount of seconds the message will not be visible (`Visibility Timeout`_) wait_time (default: 20)\n`Long polling`_ duration in seconds The queue_attributes and queue_tags options were introduced in Symfony 7.3. The wait_time parameter defines the maximum duration Amazon SQS should\nwait until a message is available in a queue before sending a response.\nIt helps reducing the cost of using Amazon SQS by eliminating the number\nof empty responses. The poll_timeout parameter defines the duration the receiver should wait\nbefore returning null. It avoids blocking other receivers from being called. If the queue name is suffixed by .fifo, AWS will create a `FIFO queue`_.\nUse the stamp Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Transport\\\\AmazonSqsFifoStamp\nto define the Message group ID and the Message deduplication ID.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_15", "source": "messenger.rst", "text": "Another possibility is to enable the\nSymfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Middleware\\\\AddFifoStampMiddleware.\nIf your message implements\nSymfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\MessageDeduplicationAwareInterface,\nthe middleware will automatically add the\nSymfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Transport\\\\AmazonSqsFifoStamp\nand set the Message deduplication ID. Additionally, if your message implements the\nSymfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\MessageGroupAwareInterface,\nthe middleware will automatically set the Message group ID of the stamp. You can learn more about middlewares in\nthe dedicated section . FIFO queues don't support setting a delay per message, a value of delay: 0\nis required in the retry strategy settings. The SQS transport supports the --keepalive option by using the ChangeMessageVisibility\naction to periodically update the VisibilityTimeout of the message. Keepalive support was introduced in Symfony 7.2. Serializing Messages When messages are sent to (and received from) a transport, they're serialized\nusing PHP's native serialize() & unserialize() functions. You can change\nthis globally (or for each transport) to a service that implements\nSymfony\\\\Component\\\\Messenger\\\\Transport\\\\Serialization\\\\SerializerInterface: # config/packages/messenger.yaml\nframework:\nmessenger:\nserializer:\ndefault_serializer: messenger.transport.symfony_serializer\nsymfony_serializer:\nformat: json\ncontext: { } transports:\nasync_priority_normal:\ndsn: # ...\nserializer: messenger.transport.symfony_serializer <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:serializer default-serializer=\"messenger.transport.symfony_serializer\">\n<framework:symfony-serializer format=\"json\">\n<framework:context/>\n</framework:symfony-serializer>\n</framework:serializer> <framework:transport name=\"async_priority_normal\" dsn=\"...\" serializer=\"messenger.transport.symfony_serializer\"/>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); $messenger->serializer()\n->defaultSerializer('messenger.transport.symfony_serializer')\n->symfonySerializer()\n->format('json')\n->context('foo', 'bar'); $messenger->transport('async_priority_normal')\n->dsn('...')\n->serializer('messenger.transport.symfony_serializer');\n}; The messenger.transport.symfony_serializer is a built-in service that uses\nthe Serializer component and can be configured in a few ways.\nIf you *do* choose to use the Symfony serializer, you can control the context\non a case-by-case basis via the Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\SerializerStamp\n(see `Envelopes & Stamps`_). When sending/receiving messages to/from another application, you may need\nmore control over the serialization process. Using a custom serializer\nprovides that control. See `SymfonyCasts' message serializer tutorial`_ for\ndetails. Closing Connections When using a transport that requires a connection, you can close it by calling the\nSymfony\\\\Component\\\\Messenger\\\\Transport\\\\CloseableTransportInterface::close\nmethod to free up resources in long-running processes. This interface is implemented by the following transports: AmazonSqs, Amqp, and Redis.\nIf you need to close a Doctrine connection, you can do so\nusing middleware . The CloseableTransportInterface and its close() method were introduced\nin Symfony 7.3. Running Commands And External Processes Trigger a Command It is possible to trigger any command by dispatching a\nSymfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandMessage. Symfony\nwill take care of handling this message and execute the command passed\nto the message parameter:: use Symfony\\Component\\Console\\Messenger\\RunCommandMessage;\nuse Symfony\\Component\\Messenger\\MessageBusInterface; class CleanUpService\n{\npublic function __construct(private readonly MessageBusInterface $bus)\n{\n} public function cleanUp(): void\n{\n// Long task with some caching... // Once finished, dispatch some clean up commands\n$this->bus->dispatch(new RunCommandMessage('app:my-cache:clean-up --dir=var/temp'));\n$this->bus->dispatch(new RunCommandMessage('cache:clear'));\n}\n} You can configure the behavior in the case of something going wrong during command\nexecution. To do so, you can use the throwOnFailure and catchExceptions\nparameters when creating your instance of\nSymfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandMessage. Once handled, the handler will return a\nSymfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandContext which\ncontains many useful information such as the exit code or the output of the\nprocess. You can refer to the page dedicated on\nhandler results for more information.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_16", "source": "messenger.rst", "text": "Trigger An External Process Messenger comes with a handy helper to run external processes by\ndispatching a message. This takes advantages of the\nProcess component . By dispatching a\nSymfony\\\\Component\\\\Process\\\\Messenger\\\\RunProcessMessage, Messenger\nwill take care of creating a new process with the parameters you passed:: use Symfony\\Component\\Messenger\\MessageBusInterface;\nuse Symfony\\Component\\Process\\Messenger\\RunProcessMessage; class CleanUpService\n{\npublic function __construct(\nprivate readonly MessageBusInterface $bus,\n) {\n} public function cleanUp(): void\n{\n$this->bus->dispatch(new RunProcessMessage(['rm', '-rf', 'var/log/temp/*'], cwd: '/my/custom/working-dir')); // ...\n}\n} If you want to use shell features such as redirections or pipes, use the static\nSymfony\\\\Component\\\\Process\\\\Messenger\\\\RunProcessMessage::fromShellCommandline factory method:: use Symfony\\Component\\Messenger\\MessageBusInterface;\nuse Symfony\\Component\\Process\\Messenger\\RunProcessMessage; class CleanUpService\n{\npublic function __construct(\nprivate readonly MessageBusInterface $bus,\n) {\n} public function cleanUp(): void\n{\n$this->bus->dispatch(RunProcessMessage::fromShellCommandline('echo \"Hello World\" > var/log/hello.txt')); // ...\n}\n} For more information, read the documentation about\nusing features from the OS shell . The RunProcessMessage::fromShellCommandline() method was introduced in Symfony 7.3. Once handled, the handler will return a\nSymfony\\\\Component\\\\Process\\\\Messenger\\\\RunProcessContext which\ncontains many useful information such as the exit code or the output of the\nprocess. You can refer to the page dedicated on\nhandler results for more information. Pinging A Webservice Sometimes, you may need to regularly ping a webservice to get its status, e.g.\nis it up or down. It is possible to do so by dispatching a\nSymfony\\\\Component\\\\HttpClient\\\\Messenger\\\\PingWebhookMessage:: use Symfony\\Component\\HttpClient\\Messenger\\PingWebhookMessage;\nuse Symfony\\Component\\Messenger\\MessageBusInterface; class LivenessService\n{\npublic function __construct(private readonly MessageBusInterface $bus)\n{\n} public function ping(): void\n{\n// An HttpExceptionInterface is thrown on 3xx/4xx/5xx\n$this->bus->dispatch(new PingWebhookMessage('GET', 'https://example.com/status')); // Ping, but does not throw on 3xx/4xx/5xx\n$this->bus->dispatch(new PingWebhookMessage('GET', 'https://example.com/status', throw: false)); // Any valid HttpClientInterface option can be used\n$this->bus->dispatch(new PingWebhookMessage('POST', 'https://example.com/status', [\n'headers' => [\n'Authorization' => 'Bearer ...'\n],\n'json' => [\n'data' => 'some-data',\n],\n]));\n}\n} The handler will return a\nSymfony\\\\Contracts\\\\HttpClient\\\\ResponseInterface, allowing you to\ngather and process information returned by the HTTP request. Getting Results from your Handlers When a message is handled, the Symfony\\\\Component\\\\Messenger\\\\Middleware\\\\HandleMessageMiddleware\nadds a Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\HandledStamp for each object that handled the message.\nYou can use this to get the value returned by the handler(s):: use Symfony\\Component\\Messenger\\MessageBusInterface;\nuse Symfony\\Component\\Messenger\\Stamp\\HandledStamp; $envelope = $messageBus->dispatch(new SomeMessage()); // get the value that was returned by the last message handler\n$handledStamp = $envelope->last(HandledStamp::class);\n$handledStamp->getResult(); // or get info about all of handlers\n$handledStamps = $envelope->all(HandledStamp::class); Getting Results when Working with Command & Query Buses The Messenger component can be used in CQRS architectures where command & query\nbuses are central pieces of the application. Read Martin Fowler's\n`article about CQRS`_ to learn more and\nhow to configure multiple buses . As queries are usually synchronous and expected to be handled once,\ngetting the result from the handler is a common need. A Symfony\\\\Component\\\\Messenger\\\\HandleTrait exists to get the result\nof the handler when processing synchronously. It also ensures that exactly one\nhandler is registered. The HandleTrait can be used in any class that has a\n$messageBus property:: // src/Action/ListItems.php\nnamespace App\\Action; use App\\Message\\ListItemsQuery;\nuse App\\MessageHandler\\ListItemsQueryResult;\nuse Symfony\\Component\\Messenger\\HandleTrait;\nuse Symfony\\Component\\Messenger\\MessageBusInterface; class ListItems\n{\nuse HandleTrait;", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_17", "source": "messenger.rst", "text": "public function __construct(\nprivate MessageBusInterface $messageBus,\n) {\n} public function __invoke(): void\n{\n$result = $this->query(new ListItemsQuery(/* ... */)); // Do something with the result\n// ...\n} // Creating such a method is optional, but allows type-hinting the result\nprivate function query(ListItemsQuery $query): ListItemsQueryResult\n{\nreturn $this->handle($query);\n}\n} Hence, you can use the trait to create command & query bus classes.\nFor example, you could create a special QueryBus class and inject it\nwherever you need a query bus behavior instead of the MessageBusInterface:: // src/MessageBus/QueryBus.php\nnamespace App\\MessageBus; use Symfony\\Component\\Messenger\\Envelope;\nuse Symfony\\Component\\Messenger\\HandleTrait;\nuse Symfony\\Component\\Messenger\\MessageBusInterface; class QueryBus\n{\nuse HandleTrait; public function __construct(\nprivate MessageBusInterface $messageBus,\n) {\n} /**\n* @param object|Envelope $query\n*\n* @return mixed The handler returned value\n*/\npublic function query($query): mixed\n{\nreturn $this->handle($query);\n}\n} You can also add new stamps when handling a message; they will be appended\nto the existing ones:: $this->handle(new SomeMessage($data), [new SomeStamp(), new AnotherStamp()]); The $stamps parameter of the handle() method was introduced in Symfony 7.3. Customizing Handlers Manually Configuring Handlers Symfony will normally find and register your handler automatically .\nBut, you can also configure a handler manually - and pass it some extra config -\nwhile using #AsMessageHandler attribute or tagging the handler service\nwith messenger.message_handler. // src/MessageHandler/SmsNotificationHandler.php\nnamespace App\\MessageHandler; use App\\Message\\OtherSmsNotification;\nuse App\\Message\\SmsNotification;\nuse Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler; #[AsMessageHandler(fromTransport: 'async', priority: 10)]\nclass SmsNotificationHandler\n{\npublic function __invoke(SmsNotification $message): void\n{\n// ...\n}\n} # config/services.yaml\nservices:\nApp\\MessageHandler\\SmsNotificationHandler:\ntags: [messenger.message_handler] # or configure with options\ntags:\n-\nname: messenger.message_handler\n# only needed if can't be guessed by type-hint\nhandles: App\\Message\\SmsNotification <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<service id=\"App\\MessageHandler\\SmsNotificationHandler\">\n<!-- handles is only needed if it can't be guessed by type-hint -->\n<tag name=\"messenger.message_handler\"\nhandles=\"App\\Message\\SmsNotification\"/>\n</service>\n</services>\n</container> // config/services.php\nuse App\\Message\\SmsNotification;\nuse App\\MessageHandler\\SmsNotificationHandler; $container->register(SmsNotificationHandler::class)\n->addTag('messenger.message_handler', [\n// only needed if can't be guessed by type-hint\n'handles' => SmsNotification::class,\n]); Possible options to configure with tags are: bus\nName of the bus from which the handler can receive messages, by default all buses. from_transport\nName of the transport from which the handler can receive messages, by default\nall transports. handles\nType of messages (FQCN) that can be processed by the handler, only needed if\ncan't be guessed by type-hint. method\nName of the method that will process the message. priority\nDefines the order in which the handler is executed when multiple handlers\ncan process the same message; those with higher priority run first. Handling Multiple Messages A single handler class can handle multiple messages. For that add the\n#AsMessageHandler attribute to all the handling methods:: // src/MessageHandler/SmsNotificationHandler.php\nnamespace App\\MessageHandler; use App\\Message\\OtherSmsNotification;\nuse App\\Message\\SmsNotification; class SmsNotificationHandler\n{\n#[AsMessageHandler]\npublic function handleSmsNotification(SmsNotification $message): void\n{\n// ...\n} #[AsMessageHandler]\npublic function handleOtherSmsNotification(OtherSmsNotification $message): void\n{\n// ...\n}\n} Transactional Messages: Handle New Messages After Handling is Done", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_18", "source": "messenger.rst", "text": "A message handler can dispatch new messages while handling others, to either\nthe same or a different bus (if the application has\nmultiple buses ). Any errors or exceptions that\noccur during this process can have unintended consequences, such as: #. If using the DoctrineTransactionMiddleware and a dispatched message throws\nan exception, then any database transactions in the original handler will be\nrolled back.\n#. If the message is dispatched to a different bus, then the dispatched message\nwill be handled even if some code later in the current handler throws an exception. An Example RegisterUser Process\n................................... Consider an application with both a *command* and an *event* bus. The application\ndispatches a command named RegisterUser to the command bus. The command is\nhandled by the RegisterUserHandler which creates a User object, stores\nthat object to a database and dispatches a UserRegistered message to the event bus. There are many handlers to the UserRegistered message, one handler may send\na welcome email to the new user. We are using the DoctrineTransactionMiddleware\nto wrap all database queries in one database transaction. **Problem 1:** If an exception is thrown when sending the welcome email, then\nthe user will not be created because the DoctrineTransactionMiddleware will\nrollback the Doctrine transaction, in which the user has been created. **Problem 2:** If an exception is thrown when saving the user to the database,\nthe welcome email is still sent because it is handled asynchronously. DispatchAfterCurrentBusMiddleware Middleware\n............................................ For many applications, the desired behavior is to *only* handle messages that\nare dispatched by a handler once that handler has fully finished. This can be done by\nusing the DispatchAfterCurrentBusMiddleware and adding a\nDispatchAfterCurrentBusStamp stamp to the message Envelope :: // src/Messenger/CommandHandler/RegisterUserHandler.php\nnamespace App\\Messenger\\CommandHandler; use App\\Entity\\User;\nuse App\\Messenger\\Command\\RegisterUser;\nuse App\\Messenger\\Event\\UserRegistered;\nuse Doctrine\\ORM\\EntityManagerInterface;\nuse Symfony\\Component\\Messenger\\Envelope;\nuse Symfony\\Component\\Messenger\\MessageBusInterface;\nuse Symfony\\Component\\Messenger\\Stamp\\DispatchAfterCurrentBusStamp; class RegisterUserHandler\n{\npublic function __construct(\nprivate MessageBusInterface $eventBus,\nprivate EntityManagerInterface $em,\n) {\n} public function __invoke(RegisterUser $command): void\n{\n$user = new User($command->getUuid(), $command->getName(), $command->getEmail());\n$this->em->persist($user); // The DispatchAfterCurrentBusStamp marks the event message to be handled\n// only if this handler does not throw an exception. $event = new UserRegistered($command->getUuid());\n$this->eventBus->dispatch(\n(new Envelope($event))\n->with(new DispatchAfterCurrentBusStamp())\n); // ...\n}\n} // src/Messenger/EventSubscriber/WhenUserRegisteredThenSendWelcomeEmail.php\nnamespace App\\Messenger\\EventSubscriber; use App\\Entity\\User;\nuse App\\Messenger\\Event\\UserRegistered;\nuse Doctrine\\ORM\\EntityManagerInterface;\nuse Symfony\\Component\\Mailer\\MailerInterface;\nuse Symfony\\Component\\Mime\\RawMessage; class WhenUserRegisteredThenSendWelcomeEmail\n{\npublic function __construct(\nprivate MailerInterface $mailer,\nprivate EntityManagerInterface $em,\n) {\n} public function __invoke(UserRegistered $event): void\n{\n$user = $this->em->getRepository(User::class)->find($event->getUuid()); $this->mailer->send(new RawMessage('Welcome '.$user->getFirstName()));\n}\n} This means that the UserRegistered message would not be handled until\n*after* the RegisterUserHandler had completed and the new User was\npersisted to the database. If the RegisterUserHandler encounters an\nexception, the UserRegistered event will never be handled. And if an\nexception is thrown while sending the welcome email, the Doctrine transaction\nwill not be rolled back. If WhenUserRegisteredThenSendWelcomeEmail throws an exception, that\nexception will be wrapped into a DelayedMessageHandlingException. Using\nDelayedMessageHandlingException::getWrappedExceptions will give you all\nexceptions that are thrown while handling a message with the\nDispatchAfterCurrentBusStamp.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_19", "source": "messenger.rst", "text": "The dispatch_after_current_bus middleware is enabled by default. If you're\nconfiguring your middleware manually, be sure to register\ndispatch_after_current_bus before doctrine_transaction in the middleware\nchain. Also, the dispatch_after_current_bus middleware must be loaded for\n*all* of the buses being used. Binding Handlers to Different Transports Each message can have multiple handlers, and when a message is consumed\n*all* of its handlers are called. But you can also configure a handler to only\nbe called when it's received from a *specific* transport. This allows you to\nhave a single message where each handler is called by a different \"worker\"\nthat's consuming a different transport. Suppose you have an UploadedImage message with two handlers: * ThumbnailUploadedImageHandler: you want this to be handled by\na transport called image_transport * NotifyAboutNewUploadedImageHandler: you want this to be handled\nby a transport called async_priority_normal To do this, add the from_transport option to each handler. For example:: // src/MessageHandler/ThumbnailUploadedImageHandler.php\nnamespace App\\MessageHandler; use App\\Message\\UploadedImage; #[AsMessageHandler(fromTransport: 'image_transport')]\nclass ThumbnailUploadedImageHandler\n{\npublic function __invoke(UploadedImage $uploadedImage): void\n{\n// do some thumbnailing\n}\n} And similarly:: // src/MessageHandler/NotifyAboutNewUploadedImageHandler.php\n// ... #[AsMessageHandler(fromTransport: 'async_priority_normal')]\nclass NotifyAboutNewUploadedImageHandler\n{\n// ...\n} Then, make sure to \"route\" your message to *both* transports: # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nasync_priority_normal: # ...\nimage_transport: # ... routing:\n# ...\n'App\\Message\\UploadedImage': [image_transport, async_priority_normal] <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:transport name=\"async_priority_normal\" dsn=\"...\"/>\n<framework:transport name=\"image_transport\" dsn=\"...\"/> <framework:routing message-class=\"App\\Message\\UploadedImage\">\n<framework:sender service=\"image_transport\"/>\n<framework:sender service=\"async_priority_normal\"/>\n</framework:routing>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); $messenger->transport('async_priority_normal')->dsn('...');\n$messenger->transport('image_transport')->dsn('...'); $messenger->routing('App\\Message\\UploadedImage')\n->senders(['image_transport', 'async_priority_normal']);\n}; That's it! You can now consume each transport: # will only call ThumbnailUploadedImageHandler when handling the message\n$ php bin/console messenger:consume image_transport -vv $ php bin/console messenger:consume async_priority_normal -vv If a handler does *not* have from_transport config, it will be executed\non *every* transport that the message is received from. Process Messages by Batches You can declare \"special\" handlers which will process messages by batch.\nBy doing so, the handler will wait for a certain amount of messages to be\npending before processing them. The declaration of a batch handler is done\nby implementing\nSymfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerInterface. The\nSymfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerTrait is also\nprovided in order to ease the declaration of these special handlers:: use Symfony\\Component\\Messenger\\Handler\\Acknowledger;\nuse Symfony\\Component\\Messenger\\Handler\\BatchHandlerInterface;\nuse Symfony\\Component\\Messenger\\Handler\\BatchHandlerTrait; class MyBatchHandler implements BatchHandlerInterface\n{\nuse BatchHandlerTrait; public function __invoke(MyMessage $message, ?Acknowledger $ack = null): mixed\n{\nreturn $this->handle($message, $ack);\n} private function process(array $jobs): void\n{\nforeach ($jobs as [$message, $ack]) {\ntry {\n// Compute $result from $message... // Acknowledge the processing of the message\n$ack->ack($result);\n} catch (\\Throwable $e) {\n$ack->nack($e);\n}\n}\n} // Optionally, you can override some of the trait methods, such as the\n// `getBatchSize()` method, to specify your own batch size...\nprivate function getBatchSize(): int\n{\nreturn 100;\n}\n}", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_20", "source": "messenger.rst", "text": "When the $ack argument of __invoke() is null, the message is\nexpected to be handled synchronously. Otherwise, __invoke() is\nexpected to return the number of pending messages. The\nSymfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerTrait handles\nthis for you. By default, pending batches are flushed when the worker is idle as well\nas when it is stopped. Extending Messenger Envelopes & Stamps A message can be any PHP object. Sometimes, you may need to configure something\nextra about the message - like the way it should be handled inside AMQP or adding\na delay before the message should be handled. You can do that by adding a \"stamp\"\nto your message:: use Symfony\\Component\\Messenger\\Envelope;\nuse Symfony\\Component\\Messenger\\MessageBusInterface;\nuse Symfony\\Component\\Messenger\\Stamp\\DelayStamp; public function index(MessageBusInterface $bus): void\n{\n// wait 5 seconds before processing\n$bus->dispatch(new SmsNotification('...'), [\nnew DelayStamp(5000),\n]); // or explicitly create an Envelope\n$bus->dispatch(new Envelope(new SmsNotification('...'), [\nnew DelayStamp(5000),\n])); // ...\n} Internally, each message is wrapped in an Envelope, which holds the message\nand stamps. You can create this manually or allow the message bus to do it. There\nare a variety of different stamps for different purposes and they're used internally\nto track information about a message - like the message bus that's handling it\nor if it's being retried after failure. Middleware What happens when you dispatch a message to a message bus depends on its\ncollection of middleware and their order. By default, the middleware configured\nfor each bus looks like this: #. add_bus_name_stamp_middleware - adds a stamp to record which bus this\nmessage was dispatched into; #. dispatch_after_current_bus- see messenger-transactional-messages; #. failed_message_processing_middleware - processes messages that are being\nretried via the failure transport to make\nthem properly function as if they were being received from their original transport; #. Your own collection of middleware_; #. send_message - if routing is configured for the transport, this sends\nmessages to that transport and stops the middleware chain; #. handle_message - calls the message handler(s) for the given message. These middleware names are actually shortcut names. The real service ids\nare prefixed with messenger.middleware. (e.g. messenger.middleware.handle_message). The middleware are executed when the message is dispatched but *also* again when\na message is received via the worker (for messages that were sent to a transport\nto be handled asynchronously). Keep this in mind if you create your own middleware. You can add your own middleware to this list, or completely disable the default\nmiddleware and *only* include your own. If a middleware service is abstract, you can configure its constructor's arguments\nand a different instance will be created per bus. # config/packages/messenger.yaml\nframework:\nmessenger:\nbuses:\nmessenger.bus.default:\n# disable the default middleware\ndefault_middleware: false middleware:\n# use and configure parts of the default middleware you want\n- 'add_bus_name_stamp_middleware': ['messenger.bus.default'] # add your own services that implement Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface\n- 'App\\Middleware\\MyMiddleware'\n- 'App\\Middleware\\AnotherMiddleware' <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<!-- default-middleware: disable the default middleware -->\n<framework:bus name=\"messenger.bus.default\" default-middleware=\"false\">", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_21", "source": "messenger.rst", "text": "<!-- use and configure parts of the default middleware you want -->\n<framework:middleware id=\"add_bus_name_stamp_middleware\">\n<framework:argument>messenger.bus.default</framework:argument>\n</framework:middleware> <!-- add your own services that implement Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface -->\n<framework:middleware id=\"App\\Middleware\\MyMiddleware\"/>\n<framework:middleware id=\"App\\Middleware\\AnotherMiddleware\"/>\n</framework:bus>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); $bus = $messenger->bus('messenger.bus.default')\n->defaultMiddleware(false); // disable the default middleware // use and configure parts of the default middleware you want\n$bus->middleware()->id('add_bus_name_stamp_middleware')->arguments(['messenger.bus.default']); // add your own services that implement Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface\n$bus->middleware()->id('App\\Middleware\\MyMiddleware');\n$bus->middleware()->id('App\\Middleware\\AnotherMiddleware');\n}; If you have installed the MakerBundle, you can use the make:messenger-middleware\ncommand to bootstrap the creation of your own messenger middleware. Middleware for Doctrine If you use Doctrine in your app, a number of optional middleware exist that you\nmay want to use: # config/packages/messenger.yaml\nframework:\nmessenger:\nbuses:\ncommand_bus:\nmiddleware:\n# each time a message is handled, the Doctrine connection\n# is \"pinged\" and reconnected if it's closed. Useful\n# if your workers run for a long time and the database\n# connection is sometimes lost\n- doctrine_ping_connection # After handling, the Doctrine connection is closed,\n# which can free up database connections in a worker,\n# instead of keeping them open forever\n- doctrine_close_connection # logs an error when a Doctrine transaction was opened but not closed\n- doctrine_open_transaction_logger # wraps all handlers in a single Doctrine transaction\n# handlers do not need to call flush() and an error\n# in any handler will cause a rollback\n- doctrine_transaction # or pass a different entity manager to any\n#- doctrine_transaction: ['custom'] <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:bus name=\"command_bus\">\n<framework:middleware id=\"doctrine_transaction\"/>\n<framework:middleware id=\"doctrine_ping_connection\"/>\n<framework:middleware id=\"doctrine_close_connection\"/>\n<framework:middleware id=\"doctrine_open_transaction_logger\"/> <!-- or pass a different entity manager to any -->\n<!--\n<framework:middleware id=\"doctrine_transaction\">\n<framework:argument>custom</framework:argument>\n</framework:middleware>\n-->\n</framework:bus>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); $bus = $messenger->bus('command_bus');\n$bus->middleware()->id('doctrine_transaction');\n$bus->middleware()->id('doctrine_ping_connection');\n$bus->middleware()->id('doctrine_close_connection');\n$bus->middleware()->id('doctrine_open_transaction_logger');\n// Using another entity manager\n$bus->middleware()->id('doctrine_transaction')\n->arguments(['custom']);\n}; Other Middlewares Add the router_context middleware if you need to generate absolute URLs in\nthe consumer (e.g. render a template with links). This middleware stores the\noriginal request context (i.e. the host, the HTTP port, etc.) which is needed\nwhen building absolute URLs. Add the validation middleware if you need to validate the message\nobject using the Validator component before handling it.\nIf validation fails, a ValidationFailedException will be thrown. The\nSymfony\\\\Component\\\\Messenger\\\\Stamp\\\\ValidationStamp can be used\nto configure the validation groups. # config/packages/messenger.yaml\nframework:\nmessenger:\nbuses:\ncommand_bus:\nmiddleware:\n- router_context\n- validation <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:bus name=\"command_bus\">\n<framework:middleware id=\"router_context\"/>\n<framework:middleware id=\"validation\"/>\n</framework:bus>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); $bus = $messenger->bus('command_bus');\n$bus->middleware()->id('router_context');\n$bus->middleware()->id('validation');\n}; Messenger Events In addition to middleware, Messenger also dispatches several events. You can\ncreate an event listener to hook into various parts\nof the process. For each, the event class is the event name:", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_22", "source": "messenger.rst", "text": "* Symfony\\\\Component\\\\Messenger\\\\Event\\\\SendMessageToTransportsEvent\n* Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageFailedEvent\n* Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageHandledEvent\n* Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageReceivedEvent\n* Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageRetriedEvent\n* Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerRateLimitedEvent\n* Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerRunningEvent\n* Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerStartedEvent\n* Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerStoppedEvent Additional Handler Arguments It's possible to have messenger pass additional data to the message handler\nusing the Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\HandlerArgumentsStamp.\nAdd this stamp to the envelope in a middleware and fill it with any additional\ndata you want to have available in the handler:: // src/Messenger/AdditionalArgumentMiddleware.php\nnamespace App\\Messenger; use Symfony\\Component\\Messenger\\Envelope;\nuse Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface;\nuse Symfony\\Component\\Messenger\\Middleware\\StackInterface;\nuse Symfony\\Component\\Messenger\\Stamp\\HandlerArgumentsStamp; final class AdditionalArgumentMiddleware implements MiddlewareInterface\n{\npublic function handle(Envelope $envelope, StackInterface $stack): Envelope\n{\n$envelope = $envelope->with(new HandlerArgumentsStamp([\n$this->resolveAdditionalArgument($envelope->getMessage()),\n])); return $stack->next()->handle($envelope, $stack);\n} private function resolveAdditionalArgument(object $message): mixed\n{\n// ...\n}\n} Then your handler will look like this:: // src/MessageHandler/SmsNotificationHandler.php\nnamespace App\\MessageHandler; use App\\Message\\SmsNotification; final class SmsNotificationHandler\n{\npublic function __invoke(SmsNotification $message, mixed $additionalArgument)\n{\n// ...\n}\n} Message Serializer For Custom Data Formats If you receive messages from other applications, it's possible that they are not\nexactly in the format you need. Not all applications will return a JSON message\nwith body and headers fields. In those cases, you'll need to create a\nnew message serializer implementing the\nSymfony\\\\Component\\\\Messenger\\\\Transport\\\\Serialization\\\\SerializerInterface.\nLet's say you want to create a message decoder:: namespace App\\Messenger\\Serializer; use Symfony\\Component\\Messenger\\Envelope;\nuse Symfony\\Component\\Messenger\\Transport\\Serialization\\SerializerInterface; class MessageWithTokenDecoder implements SerializerInterface\n{\npublic function decode(array $encodedEnvelope): Envelope\n{\ntry {\n// parse the data you received with your custom fields\n$data = $encodedEnvelope['data'];\n$data['token'] = $encodedEnvelope['token']; // other operations like getting information from stamps\n} catch (\\Throwable $throwable) {\n// wrap any exception that may occur in the envelope to send it to the failure transport\nreturn new Envelope($throwable);\n} return new Envelope($data);\n} public function encode(Envelope $envelope): array\n{\n// this decoder does not encode messages, but you can implement it by returning\n// an array with serialized stamps if you need to send messages in a custom format\nthrow new \\LogicException('This serializer is only used for decoding messages.');\n}\n} The next step is to tell Symfony to use this serializer in one or more of your\ntransports: # config/packages/messenger.yaml\nframework:\nmessenger:\ntransports:\nmy_transport:\ndsn: '%env(MY_TRANSPORT_DSN)%'\nserializer: 'App\\Messenger\\Serializer\\MessageWithTokenDecoder' <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:messenger>\n<framework:transport name=\"my_transport\" dsn=\"%env(MY_TRANSPORT_DSN)%\" serializer=\"App\\Messenger\\Serializer\\MessageWithTokenDecoder\">\n<!-- ... -->\n</framework:transport>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse App\\Messenger\\Serializer\\MessageWithTokenDecoder;\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$messenger = $framework->messenger(); $messenger->transport('my_transport')\n->dsn('%env(MY_TRANSPORT_DSN)%')\n->serializer(MessageWithTokenDecoder::class);\n}; Multiple Buses, Command & Event Buses Messenger gives you a single message bus service by default. But, you can configure\nas many as you want, creating \"command\", \"query\" or \"event\" buses and controlling\ntheir middleware. A common architecture when building applications is to separate commands from\nqueries. Commands are actions that do something and queries fetch data. This\nis called CQRS (Command Query Responsibility Segregation). See Martin Fowler's\n`article about CQRS`_ to learn more. This architecture could be used together\nwith the Messenger component by defining multiple buses.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_23", "source": "messenger.rst", "text": "A **command bus** is a little different from a **query bus**. For example, command\nbuses usually don't provide any results and query buses are rarely asynchronous.\nYou can configure these buses and their rules by using middleware. It might also be a good idea to separate actions from reactions by introducing\nan **event bus**. The event bus could have zero or more subscribers. framework:\nmessenger:\n# The bus that is going to be injected when injecting MessageBusInterface\ndefault_bus: command.bus\nbuses:\ncommand.bus:\nmiddleware:\n- validation\n- doctrine_transaction\nquery.bus:\nmiddleware:\n- validation\nevent.bus:\ndefault_middleware:\nenabled: true\n# set \"allow_no_handlers\" to true (default is false) to allow having\n# no handler configured for this bus without throwing an exception\nallow_no_handlers: false\n# set \"allow_no_senders\" to false (default is true) to throw an exception\n# if no sender is configured for this bus\nallow_no_senders: true\nmiddleware:\n- validation <!-- config/packages/messenger.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<!-- The bus that is going to be injected when injecting MessageBusInterface -->\n<framework:messenger default-bus=\"command.bus\">\n<framework:bus name=\"command.bus\">\n<framework:middleware id=\"validation\"/>\n<framework:middleware id=\"doctrine_transaction\"/>\n</framework:bus>\n<framework:bus name=\"query.bus\">\n<framework:middleware id=\"validation\"/>\n</framework:bus>\n<framework:bus name=\"event.bus\">\n<!-- set \"allow-no-handlers\" to true (default is false) to allow having\nno handler configured for this bus without throwing an exception -->\n<!-- set \"allow-no-senders\" to false (default is true) to throw an exception\nif no sender is configured for this bus -->\n<framework:default-middleware enabled=\"true\" allow-no-handlers=\"false\" allow-no-senders=\"true\"/>\n<framework:middleware id=\"validation\"/>\n</framework:bus>\n</framework:messenger>\n</framework:config>\n</container> // config/packages/messenger.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n// The bus that is going to be injected when injecting MessageBusInterface\n$framework->messenger()->defaultBus('command.bus'); $commandBus = $framework->messenger()->bus('command.bus');\n$commandBus->middleware()->id('validation');\n$commandBus->middleware()->id('doctrine_transaction'); $queryBus = $framework->messenger()->bus('query.bus');\n$queryBus->middleware()->id('validation'); $eventBus = $framework->messenger()->bus('event.bus');\n$eventBus->defaultMiddleware()\n->enabled(true)\n// set \"allowNoHandlers\" to true (default is false) to allow having\n// no handler configured for this bus without throwing an exception\n->allowNoHandlers(false)\n// set \"allowNoSenders\" to false (default is true) to throw an exception\n// if no sender is configured for this bus\n->allowNoSenders(true)\n;\n$eventBus->middleware()->id('validation');\n}; This will create three new services: * command.bus: autowireable with the Symfony\\\\Component\\\\Messenger\\\\MessageBusInterface\ntype-hint (because this is the default_bus); * query.bus: autowireable with MessageBusInterface $queryBus; * event.bus: autowireable with MessageBusInterface $eventBus. Restrict Handlers per Bus By default, each handler will be available to handle messages on *all*\nof your buses. To prevent dispatching a message to the wrong bus without an error,\nyou can restrict each handler to a specific bus using the messenger.message_handler tag: # config/services.yaml\nservices:\nApp\\MessageHandler\\SomeCommandHandler:\ntags: [{ name: messenger.message_handler, bus: command.bus }] <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<service id=\"App\\MessageHandler\\SomeCommandHandler\">\n<tag name=\"messenger.message_handler\" bus=\"command.bus\"/>\n</service>\n</services>\n</container> // config/services.php\n$container->services()\n->set(App\\MessageHandler\\SomeCommandHandler::class)\n->tag('messenger.message_handler', ['bus' => 'command.bus']); This way, the App\\MessageHandler\\SomeCommandHandler handler will only be\nknown by the command.bus bus. You can also automatically add this tag to a number of classes by using\nthe _instanceof service configuration . Using this,\nyou can determine the message bus based on an implemented interface: # config/services.yaml\nservices:\n# ...", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_sem_24", "source": "messenger.rst", "text": "_instanceof:\n# all services implementing the CommandHandlerInterface\n# will be registered on the command.bus bus\nApp\\MessageHandler\\CommandHandlerInterface:\ntags:\n- { name: messenger.message_handler, bus: command.bus } # while those implementing QueryHandlerInterface will be\n# registered on the query.bus bus\nApp\\MessageHandler\\QueryHandlerInterface:\ntags:\n- { name: messenger.message_handler, bus: query.bus } <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... --> <!-- all services implementing the CommandHandlerInterface\nwill be registered on the command.bus bus -->\n<instanceof id=\"App\\MessageHandler\\CommandHandlerInterface\">\n<tag name=\"messenger.message_handler\" bus=\"command.bus\"/>\n</instanceof> <!-- while those implementing QueryHandlerInterface will be\nregistered on the query.bus bus -->\n<instanceof id=\"App\\MessageHandler\\QueryHandlerInterface\">\n<tag name=\"messenger.message_handler\" bus=\"query.bus\"/>\n</instanceof>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\MessageHandler\\CommandHandlerInterface;\nuse App\\MessageHandler\\QueryHandlerInterface; return function(ContainerConfigurator $container): void {\n$services = $container->services(); // ... // all services implementing the CommandHandlerInterface\n// will be registered on the command.bus bus\n$services->instanceof(CommandHandlerInterface::class)\n->tag('messenger.message_handler', ['bus' => 'command.bus']); // while those implementing QueryHandlerInterface will be\n// registered on the query.bus bus\n$services->instanceof(QueryHandlerInterface::class)\n->tag('messenger.message_handler', ['bus' => 'query.bus']);\n}; Debugging the Buses The debug:messenger command lists available messages & handlers per bus.\nYou can also restrict the list to a specific bus by providing its name as an argument. $ php bin/console debug:messenger Messenger command.bus The following messages can be dispatched: App\\Message\\DummyCommand\nhandled by App\\MessageHandler\\DummyCommandHandler\nApp\\Message\\MultipleBusesMessage\nhandled by App\\MessageHandler\\MultipleBusesMessageHandler query.bus The following messages can be dispatched: App\\Message\\DummyQuery\nhandled by App\\MessageHandler\\DummyQueryHandler\nApp\\Message\\MultipleBusesMessage\nhandled by App\\MessageHandler\\MultipleBusesMessageHandler The command will also show the PHPDoc description of the message and handler classes. Redispatching a Message If you want to redispatch a message (using the same transport and envelope), create\na new Symfony\\\\Component\\\\Messenger\\\\Message\\\\RedispatchMessage and dispatch\nit through your bus. Reusing the same SmsNotification example shown earlier:: // src/MessageHandler/SmsNotificationHandler.php\nnamespace App\\MessageHandler; use App\\Message\\SmsNotification;\nuse Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler;\nuse Symfony\\Component\\Messenger\\Message\\RedispatchMessage;\nuse Symfony\\Component\\Messenger\\MessageBusInterface; #[AsMessageHandler]\nclass SmsNotificationHandler\n{\npublic function __construct(private MessageBusInterface $bus)\n{\n} public function __invoke(SmsNotification $message): void\n{\n// do something with the message\n// then redispatch it based on your own logic if ($needsRedispatch) {\n$this->bus->dispatch(new RedispatchMessage($message));\n}\n}\n} The built-in Symfony\\\\Component\\\\Messenger\\\\Handler\\\\RedispatchMessageHandler\nwill take care of this message to redispatch it through the same bus it was\ndispatched at first. You can also use the second argument of the RedispatchMessage\nconstructor to provide transports to use when redispatching the message. Learn more :maxdepth: 1\n:glob: /messenger/*", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "performance.rst_sem_0", "source": "performance.rst", "text": "Performance Symfony is fast, right out of the box. However, you can make it faster if you\noptimize your servers and your applications as explained in the following\nperformance checklists. Performance Checklists Use these checklists to verify that your application and server are configured\nfor maximum performance: * **Symfony Application Checklist**: #. Restrict the number of locales enabled in the application * **Production Server Checklist**: #. Dump the service container into a single file\n#. Use the OPcache byte code cache\n#. Configure OPcache for maximum performance\n#. Don't check PHP files timestamps\n#. Configure the PHP realpath Cache\n#. Optimize Composer Autoloader Restrict the Number of Locales Enabled in the Application Use the framework.enabled_locales\noption to only generate the translation files actually used in your application. Dump the Service Container into a Single File Symfony compiles the service container into multiple\nsmall files by default. Set this parameter to true to compile the entire\ncontainer into a single file, which could improve performance when using\n\"class preloading\" in PHP 7.4 or newer versions: # config/services.yaml\nparameters:\n# ...\n.container.dumper.inline_factories: true <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters>\n<!-- ... -->\n<parameter key=\".container.dumper.inline_factories\">true</parameter>\n</parameters>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void {\n$container->parameters()->set('.container.dumper.inline_factories', true);\n}; The . prefix denotes a parameter that is only used during compilation of the container.\nSee Configuration Parameters for more details. Use the OPcache Byte Code Cache OPcache stores the compiled PHP files to avoid having to recompile them for\nevery request. There are some `byte code caches`_ available, but as of PHP\n5.5, PHP comes with `OPcache`_ built-in. For older versions, the most widely\nused byte code cache is APC. Use the OPcache class preloading Starting from PHP 7.4, OPcache can compile and load classes at start-up and\nmake them available to all requests until the server is restarted, improving\nperformance significantly. During container compilation (e.g. when running the cache:clear command),\nSymfony generates a file with the list of classes to preload in the\nvar/cache/ directory. Rather than use this file directly, use the\nconfig/preload.php file that is created when\nusing Symfony Flex in your project : ; php.ini\nopcache.preload=/path/to/project/config/preload.php ; required for opcache.preload:\nopcache.preload_user=www-data If this file is missing, run this command to update the Symfony Flex recipe:\ncomposer recipes:update symfony/framework-bundle. Use the container.preload and\ncontainer.no_preload service tags to define\nwhich classes should or should not be preloaded by PHP. Configure OPcache for Maximum Performance The default OPcache configuration is not suited for Symfony applications, so\nit's recommended to change these settings as follows: ; php.ini\n; maximum memory that OPcache can use to store compiled PHP files\nopcache.memory_consumption=256 ; maximum number of files that can be stored in the cache\nopcache.max_accelerated_files=20000 Don't Check PHP Files Timestamps", "title": "Performance", "category": "performance"}
{"chunk_id": "performance.rst_sem_1", "source": "performance.rst", "text": "In production servers, PHP files should never change, unless a new application\nversion is deployed. However, by default OPcache checks if cached files have\nchanged their contents since they were cached. This check introduces some\noverhead that can be avoided as follows: ; php.ini\nopcache.validate_timestamps=0 After each deployment, you must empty and regenerate the cache of OPcache. Otherwise\nyou won't see the updates made in the application. Given that in PHP, the CLI\nand the web processes don't share the same OPcache, you cannot clear the web\nserver OPcache by executing some command in your terminal. These are some of the\npossible solutions: 1. Restart the web server;\n2. Call the apc_clear_cache() or opcache_reset() functions via the\nweb server (i.e. by having these in a script that you execute over the web);\n3. Use the `cachetool`_ utility to control APC and OPcache from the CLI. Configure the PHP realpath Cache When a relative path is transformed into its real and absolute path, PHP\ncaches the result to improve performance. Applications that open many PHP files,\nsuch as Symfony projects, should use at least these values: ; php.ini\n; maximum memory allocated to store the results\nrealpath_cache_size=4096K ; save the results for 10 minutes (600 seconds)\nrealpath_cache_ttl=600 PHP disables the realpath cache when the `open_basedir`_ config option\nis enabled. Optimize Composer Autoloader The class loader used while developing the application is optimized to find new\nand changed classes. In production servers, PHP files should never change,\nunless a new application version is deployed. That's why you can optimize\nComposer's autoloader to scan the entire application once and build an\noptimized \"class map\", which is a big array of the locations of all the classes\nand it's stored in vendor/composer/autoload_classmap.php. Execute this command to generate the new class map (and make it part of your\ndeployment process too): $ composer dump-autoload --no-dev --classmap-authoritative * --no-dev excludes the classes that are only needed in the development\nenvironment (i.e. require-dev dependencies and autoload-dev rules);\n* --classmap-authoritative creates a class map for PSR-0 and PSR-4 compatible classes\nused in your application and prevents Composer from scanning the file system for\nclasses that are not found in the class map. (see: `Composer's autoloader optimization`_). Disable Dumping the Container as XML in Debug Mode In debug mode , Symfony generates an XML file with all the\nservice container information (services, arguments, etc.)\nThis XML file is used by various debugging commands such as debug:container\nand debug:autowiring. When the container grows larger and larger, so does the size of the file and the\ntime to generate it. If the benefit of this XML file does not outweigh the decrease\nin performance, you can stop generating the file as follows: # config/services.yaml\nparameters:\n# ...\ndebug.container.dump: false <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters>\n<!-- ... -->\n<parameter key=\"debug.container.dump\">false</parameter>\n</parameters>\n</container> // config/services.php // ...\n$container->parameters()->set('debug.container.dump', false); Profiling Symfony Applications Profiling with Blackfire", "title": "Performance", "category": "performance"}
{"chunk_id": "performance.rst_sem_2", "source": "performance.rst", "text": "`Blackfire`_ is the best tool to profile and optimize performance of Symfony\napplications during development, test and production. It's a commercial service,\nbut provides a `full-featured demo`_. Profiling with Symfony Stopwatch Symfony provides a basic performance profiler in the development\nconfig environment . Click on the \"time panel\"\nof the web debug toolbar to see how much time Symfony\nspent on tasks such as making database queries and rendering templates. You can measure the execution time and memory consumption of your own code and\ndisplay the result in the Symfony profiler thanks to the `Stopwatch component`_. When using autowiring , type-hint any controller or\nservice argument with the Symfony\\\\Component\\\\Stopwatch\\\\Stopwatch class\nand Symfony will inject the debug.stopwatch service:: use Symfony\\Component\\Stopwatch\\Stopwatch; class DataExporter\n{\npublic function __construct(\nprivate Stopwatch $stopwatch,\n) {\n} public function export(): void\n{\n// the argument is the name of the \"profiling event\"\n$this->stopwatch->start('export-data'); // ...do things to export data... // reset the stopwatch to delete all the data measured so far\n// $this->stopwatch->reset(); $this->stopwatch->stop('export-data');\n}\n} If the request calls this service during its execution, you'll see a new\nevent called export-data in the Symfony profiler. The start(), stop() and getEvent() methods return a\nSymfony\\\\Component\\\\Stopwatch\\\\StopwatchEvent object that provides\ninformation about the current event, even while it's still running. This\nobject can be converted to a string for a quick summary:: // ...\ndump((string) $this->stopwatch->getEvent('export-data')); // dumps e.g. '4.50 MiB - 26 ms' You can also profile your template code with the stopwatch Twig tag : {% stopwatch 'render-blog-posts' %}\n{% for post in blog_posts %}\n{# ... #}\n{% endfor %}\n{% endstopwatch %} Profiling Categories\n.................... Use the second optional argument of the start() method to define the\ncategory or tag of the event. This helps keep events organized by type:: $this->stopwatch->start('export-data', 'export'); Profiling Periods\n................. A `real-world stopwatch`_ not only includes the start/stop button but also a\n\"lap button\" to measure each partial lap. This is exactly what the lap()\nmethod does, which stops an event and then restarts it immediately:: $this->stopwatch->start('process-data-records', 'export'); foreach ($records as $record) {\n// ... some code goes here\n$this->stopwatch->lap('process-data-records');\n} $event = $this->stopwatch->stop('process-data-records');\n// $event->getDuration(), $event->getMemory(), etc. // Lap information is stored as \"periods\" within the event:\n// $event->getPeriods(); // Gets the last event period:\n// $event->getLastPeriod(); The getLastPeriod() method was introduced in Symfony 7.2. Profiling Sections\n.................. Sections are a way to split the profile timeline into groups. Example:: $this->stopwatch->openSection();\n$this->stopwatch->start('validating-file', 'validation');\n$this->stopwatch->stopSection('parsing'); $events = $this->stopwatch->getSectionEvents('parsing'); // later you can reopen a section passing its name to the openSection() method\n$this->stopwatch->openSection('parsing');\n$this->stopwatch->start('processing-file');\n$this->stopwatch->stopSection('parsing'); All events that don't belong to any named section are added to the special section\ncalled __root__. This way you can get all stopwatch events, even if you don't\nknow their names, as follows:: use Symfony\\Component\\Stopwatch\\Stopwatch; foreach($this->stopwatch->getSectionEvents(Stopwatch::ROOT) as $event) {\necho (string) $event;\n} The Stopwatch::ROOT constant as a shortcut for __root__ was introduced in Symfony 7.2. Learn more * /http_cache/varnish", "title": "Performance", "category": "performance"}
{"chunk_id": "routing.rst_sem_0", "source": "routing.rst", "text": "Routing When your application receives a request, it calls a\ncontroller action to generate the response. The routing\nconfiguration defines which action to run for each incoming URL. It also\nprovides other useful features, like generating SEO-friendly URLs (e.g.\n/read/intro-to-symfony instead of index.php?article_id=57). Creating Routes Routes can be configured in YAML, XML, PHP or using attributes.\nAll formats provide the same features and performance, so choose\nyour favorite.\nSymfony recommends attributes\nbecause it's convenient to put the route and controller in the same place. Creating Routes as Attributes PHP attributes allow you to define routes next to the code of the\ncontrollers associated to those routes. You need to add a bit of configuration to your project before using them. If your\nproject uses Symfony Flex , this file is already created for you.\nOtherwise, create the following file manually: # config/routes/attributes.yaml\ncontrollers:\nresource:\npath: ../../src/Controller/\nnamespace: App\\Controller\ntype: attribute kernel:\nresource: App\\Kernel\ntype: attribute This configuration tells Symfony to look for routes defined as attributes on\nclasses declared in the App\\Controller namespace and stored in the\nsrc/Controller/ directory which follows the PSR-4 standard. The kernel can\nact as a controller too, which is especially useful for small applications that\nuse Symfony as a microframework. Suppose you want to define a route for the /blog URL in your application. To\ndo so, create a controller class like the following: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n#[Route('/blog', name: 'blog_list')]\npublic function list(): Response\n{\n// ...\n}\n} This configuration defines a route called blog_list that matches when the\nuser requests the /blog URL. When the match occurs, the application runs\nthe list() method of the BlogController class. The query string of a URL is not considered when matching routes. In this\nexample, URLs like /blog?foo=bar and /blog?foo=bar&bar=foo will\nalso match the blog_list route. If you define multiple PHP classes in the same file, Symfony only loads the\nroutes of the first class, ignoring all the other routes. The route name (blog_list) is not important for now, but it will be\nessential later when generating URLs . You only\nhave to keep in mind that each route name must be unique in the application. Creating Routes in YAML, XML or PHP Files Instead of defining routes in the controller classes, you can define them in a\nseparate YAML, XML or PHP file. The main advantage is that they don't require\nany extra dependency. The main drawback is that you have to work with multiple\nfiles when checking the routing of some controller action. The following example shows how to define in YAML/XML/PHP a route called\nblog_list that associates the /blog URL with the list() action of\nthe BlogController: # config/routes.yaml\nblog_list:\npath: /blog\n# the controller value has the format 'controller_class::method_name'\ncontroller: App\\Controller\\BlogController::list # if the action is implemented as the __invoke() method of the\n# controller class, you can skip the '::method_name' part:\n# controller: App\\Controller\\BlogController", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_1", "source": "routing.rst", "text": "<!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <!-- the controller value has the format 'controller_class::method_name' -->\n<route id=\"blog_list\" path=\"/blog\"\ncontroller=\"App\\Controller\\BlogController::list\"/> <!-- if the action is implemented as the __invoke() method of the\ncontroller class, you can skip the '::method_name' part:\ncontroller=\"App\\Controller\\BlogController\"/> -->\n</routes> // config/routes.php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void {\n$routes->add('blog_list', '/blog')\n// the controller value has the format [controller_class, method_name]\n->controller([BlogController::class, 'list']) // if the action is implemented as the __invoke() method of the\n// controller class, you can skip the 'method_name' part:\n// ->controller(BlogController::class)\n;\n}; By default, Symfony loads the routes defined in both YAML and PHP formats.\nIf you define routes in XML format, you need to\nupdate the src/Kernel.php file . Matching HTTP Methods By default, routes match any HTTP verb (GET, POST, PUT, etc.)\nUse the methods option to restrict the verbs each route should respond to: // src/Controller/BlogApiController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogApiController extends AbstractController\n{\n#[Route('/api/posts/{id}', methods: ['GET', 'HEAD'])]\npublic function show(int $id): Response\n{\n// ... return a JSON response with the post\n} #[Route('/api/posts/{id}', methods: ['PUT'])]\npublic function edit(int $id): Response\n{\n// ... edit a post\n}\n} # config/routes.yaml\napi_post_show:\npath: /api/posts/{id}\ncontroller: App\\Controller\\BlogApiController::show\nmethods: GET|HEAD api_post_edit:\npath: /api/posts/{id}\ncontroller: App\\Controller\\BlogApiController::edit\nmethods: PUT <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"api_post_show\" path=\"/api/posts/{id}\"\ncontroller=\"App\\Controller\\BlogApiController::show\"\nmethods=\"GET|HEAD\"/> <route id=\"api_post_edit\" path=\"/api/posts/{id}\"\ncontroller=\"App\\Controller\\BlogApiController::edit\"\nmethods=\"PUT\"/>\n</routes> // config/routes.php\nuse App\\Controller\\BlogApiController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void {\n$routes->add('api_post_show', '/api/posts/{id}')\n->controller([BlogApiController::class, 'show'])\n->methods(['GET', 'HEAD'])\n;\n$routes->add('api_post_edit', '/api/posts/{id}')\n->controller([BlogApiController::class, 'edit'])\n->methods(['PUT'])\n;\n}; HTML forms only support GET and POST methods. If you're calling a\nroute with a different method from an HTML form, add a hidden field called\n_method with the method to use (e.g. <input type=\"hidden\" name=\"_method\" value=\"PUT\">).\nIf you create your forms with Symfony Forms this is done\nautomatically for you when the framework.http_method_override\noption is true. Matching Environments Use the env option to register a route only when the current\nconfiguration environment matches the\ngiven value: // src/Controller/DefaultController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class DefaultController extends AbstractController\n{\n#[Route('/tools', name: 'tools', env: 'dev')]\npublic function developerTools(): Response\n{\n// ...\n}\n} # config/routes.yaml\nwhen@dev:\ntools:\npath: /tools\ncontroller: App\\Controller\\DefaultController::developerTools <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <when env=\"dev\">\n<route id=\"tools\" path=\"/tools\" controller=\"App\\Controller\\DefaultController::developerTools\"/>\n</when>\n</routes> // config/routes.php\nuse App\\Controller\\DefaultController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void {\nif('dev' === $routes->env()) {\n$routes->add('tools', '/tools')\n->controller([DefaultController::class, 'developerTools'])\n;\n}\n}; Matching Expressions Use the condition option if you need some route to match based on some\narbitrary matching logic: // src/Controller/DefaultController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class DefaultController extends AbstractController\n{\n#[Route(\n'/contact',\nname: 'contact',\ncondition: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\",\n// expressions can also include config parameters:\n// condition: \"request.headers.get('User-Agent') matches '%app.allowed_browsers%'\"\n)]\npublic function contact(): Response\n{\n// ...\n}", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_2", "source": "routing.rst", "text": "#[Route(\n'/posts/{id}',\nname: 'post_show',\n// expressions can retrieve route parameter values using the \"params\" variable\ncondition: \"params['id'] < 1000\"\n)]\npublic function showPost(int $id): Response\n{\n// ... return a JSON response with the post\n}\n} # config/routes.yaml\ncontact:\npath: /contact\ncontroller: App\\Controller\\DefaultController::contact\ncondition: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\"\n# expressions can also include configuration parameters:\n# condition: \"request.headers.get('User-Agent') matches '%app.allowed_browsers%'\"\n# expressions can even use environment variables:\n# condition: \"context.getHost() == env('APP_MAIN_HOST')\" post_show:\npath: /posts/{id}\ncontroller: App\\Controller\\DefaultController::showPost\n# expressions can retrieve route parameter values using the \"params\" variable\ncondition: \"params['id'] < 1000\" <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"contact\" path=\"/contact\" controller=\"App\\Controller\\DefaultController::contact\">\n<condition>context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'</condition>\n<!-- expressions can also include configuration parameters: -->\n<!-- <condition>request.headers.get('User-Agent') matches '%app.allowed_browsers%'</condition> -->\n<!-- expressions can even use environment variables: -->\n<!-- <condition>context.getHost() == env('APP_MAIN_HOST')</condition> -->\n</route> <route id=\"post_show\" path=\"/posts/{id}\" controller=\"App\\Controller\\DefaultController::showPost\">\n<!-- expressions can retrieve route parameter values using the \"params\" variable -->\n<condition>params['id'] &lt; 1000</condition>\n</route>\n</routes> // config/routes.php\nuse App\\Controller\\DefaultController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void {\n$routes->add('contact', '/contact')\n->controller([DefaultController::class, 'contact'])\n->condition('context.getMethod() in [\"GET\", \"HEAD\"] and request.headers.get(\"User-Agent\") matches \"/firefox/i\"')\n// expressions can also include configuration parameters:\n// ->condition('request.headers.get(\"User-Agent\") matches \"%app.allowed_browsers%\"')\n// expressions can even use environment variables:\n// ->condition('context.getHost() == env(\"APP_MAIN_HOST\")')\n;\n$routes->add('post_show', '/posts/{id}')\n->controller([DefaultController::class, 'showPost'])\n// expressions can retrieve route parameter values using the \"params\" variable\n->condition('params[\"id\"] < 1000')\n;\n}; The value of the condition option is an expression using any valid\nexpression language syntax and\ncan use any of these variables created by Symfony: context\nAn instance of Symfony\\\\Component\\\\Routing\\\\RequestContext,\nwhich holds the most fundamental information about the route being matched. request\nThe Symfony Request object that\nrepresents the current request. params\nAn array of matched route parameters for\nthe current route. You can also use these functions: env(string $name)\nReturns the value of a variable using Environment Variable Processors service(string $alias)\nReturns a routing condition service. First, add the #[AsRoutingConditionService] attribute or routing.condition_service\ntag to the services that you want to use in route conditions:: use Symfony\\Bundle\\FrameworkBundle\\Routing\\Attribute\\AsRoutingConditionService;\nuse Symfony\\Component\\HttpFoundation\\Request; #[AsRoutingConditionService(alias: 'route_checker')]\nclass RouteChecker\n{\npublic function check(Request $request): bool\n{\n// ...\n}\n} Then, use the service() function to refer to that service inside conditions:: // Controller (using an alias):\n#[Route(condition: \"service('route_checker').check(request)\")]\n// Or without alias:\n#[Route(condition: \"service('App\\\\\\Service\\\\\\RouteChecker').check(request)\")] Behind the scenes, expressions are compiled down to raw PHP. Because of this,\nusing the condition key causes no extra overhead beyond the time it takes\nfor the underlying PHP to execute. Conditions are *not* taken into account when generating URLs (which is\nexplained later in this article). Debugging Routes As your application grows, you'll eventually have a *lot* of routes. Symfony\nincludes some commands to help you debug routing issues. First, the debug:router\ncommand lists all your application routes in the same order in which Symfony\nevaluates them: $ php bin/console debug:router", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_3", "source": "routing.rst", "text": "---------------- ------- ------- ----- --------------------------------------------\nName Method Scheme Host Path\n---------------- ------- ------- ----- --------------------------------------------\nhomepage ANY ANY ANY /\ncontact GET ANY ANY /contact\ncontact_process POST ANY ANY /contact\narticle_show ANY ANY ANY /articles/{_locale}/{year}/{title}.{_format}\nblog ANY ANY ANY /blog/{page}\nblog_show ANY ANY ANY /blog/{slug}\n---------------- ------- ------- ----- -------------------------------------------- # pass this option to also display all the defined route aliases\n$ php bin/console debug:router --show-aliases # pass this option to only display routes that match the given HTTP method\n# (you can use the special value ANY to see routes that match any method)\n$ php bin/console debug:router --method=GET\n$ php bin/console debug:router --method=ANY The --method option was introduced in Symfony 7.3. Pass the name (or part of the name) of some route to this argument to print the\nroute details: $ php bin/console debug:router app_lucky_number | Property | Value |\n| Route Name | app_lucky_number |\n| Path | /lucky/number/{max} |\n| ... | ... |\n| Options | compiler_class: Symfony\\Component\\Routing\\RouteCompiler |\n| | utf8: true | The other command is called router:match and it shows which route will match\nthe given URL. It's useful to find out why some URL is not executing the\ncontroller action that you expect: $ php bin/console router:match /lucky/number/8 [OK] Route \"app_lucky_number\" matches Route Parameters The previous examples defined routes where the URL never changes (e.g. /blog).\nHowever, it's common to define routes where some parts are variable. For example,\nthe URL to display some blog post will probably include the title or slug\n(e.g. /blog/my-first-post or /blog/all-about-symfony). In Symfony routes, variable parts are wrapped in { }.\nFor example, the route to display the blog post contents is defined as /blog/{slug}: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n// ... #[Route('/blog/{slug}', name: 'blog_show')]\npublic function show(string $slug): Response\n{\n// $slug will equal the dynamic part of the URL\n// e.g. at /blog/yay-routing, then $slug='yay-routing' // ...\n}\n} # config/routes.yaml\nblog_show:\npath: /blog/{slug}\ncontroller: App\\Controller\\BlogController::show <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_show\" path=\"/blog/{slug}\"\ncontroller=\"App\\Controller\\BlogController::show\"/>\n</routes> // config/routes.php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void {\n$routes->add('blog_show', '/blog/{slug}')\n->controller([BlogController::class, 'show'])\n;\n}; The name of the variable part ({slug} in this example) is used to create a\nPHP variable where that route content is stored and passed to the controller.\nIf a user visits the /blog/my-first-post URL, Symfony executes the show()\nmethod in the BlogController class and passes a $slug = 'my-first-post'\nargument to the show() method. Routes can define any number of parameters, but each of them can only be used\nonce on each route (e.g. /blog/posts-about-{category}/page/{pageNumber}). Parameters Validation Imagine that your application has a blog_show route (URL: /blog/{slug})\nand a blog_list route (URL: /blog/{page}). Given that route parameters\naccept any value, there's no way to differentiate both routes.", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_4", "source": "routing.rst", "text": "If the user requests /blog/my-first-post, both routes will match and Symfony\nwill use the route which was defined first. To fix this, add some validation to\nthe {page} parameter using the requirements option: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n#[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\\d+'])]\npublic function list(int $page): Response\n{\n// ...\n} #[Route('/blog/{slug}', name: 'blog_show')]\npublic function show(string $slug): Response\n{\n// ...\n}\n} # config/routes.yaml\nblog_list:\npath: /blog/{page}\ncontroller: App\\Controller\\BlogController::list\nrequirements:\npage: '\\d+' blog_show:\npath: /blog/{slug}\ncontroller: App\\Controller\\BlogController::show <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_list\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::list\">\n<requirement key=\"page\">\\d+</requirement>\n</route> <route id=\"blog_show\" path=\"/blog/{slug}\"\ncontroller=\"App\\Controller\\BlogController::show\"/>\n</routes> // config/routes.php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('blog_list', '/blog/{page}')\n->controller([BlogController::class, 'list'])\n->requirements(['page' => '\\d+'])\n; $routes->add('blog_show', '/blog/{slug}')\n->controller([BlogController::class, 'show'])\n;\n// ...\n}; The requirements option defines the `PHP regular expressions`_ that route\nparameters must match for the entire route to match. In this example, \\d+ is\na regular expression that matches a *digit* of any length. Now: ======================== ============= ===============================\nURL Route Parameters\n======================== ============= ===============================\n/blog/2 blog_list $page = 2\n/blog/my-first-post blog_show $slug = my-first-post\n======================== ============= =============================== The Symfony\\\\Component\\\\Routing\\\\Requirement\\\\Requirement enum\ncontains a collection of commonly used regular-expression constants such as\ndigits, dates and UUIDs which can be used as route parameter requirements. // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\nuse Symfony\\Component\\Routing\\Requirement\\Requirement; class BlogController extends AbstractController\n{\n#[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => Requirement::DIGITS])]\npublic function list(int $page): Response\n{\n// ...\n}\n} # config/routes.yaml\nblog_list:\npath: /blog/{page}\ncontroller: App\\Controller\\BlogController::list\nrequirements:\npage: !php/const Symfony\\Component\\Routing\\Requirement\\Requirement::DIGITS // config/routes.php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nuse Symfony\\Component\\Routing\\Requirement\\Requirement; return static function (RoutingConfigurator $routes): void {\n$routes->add('blog_list', '/blog/{page}')\n->controller([BlogController::class, 'list'])\n->requirements(['page' => Requirement::DIGITS])\n;\n// ...\n}; Route requirements (and route paths too) can include\nconfiguration parameters , which is useful to\ndefine complex regular expressions once and reuse them in multiple routes. Parameters also support `PCRE Unicode properties`_, which are escape\nsequences that match generic character types. For example, \\p{Lu}\nmatches any uppercase character in any language, \\p{Greek} matches any\nGreek characters, etc. If you prefer, requirements can be inlined in each parameter using the syntax\n{parameter_name<requirements>}. This feature makes configuration more\nconcise, but it can decrease route readability when requirements are complex: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n#[Route('/blog/{page<\\d+>}', name: 'blog_list')]\npublic function list(int $page): Response\n{\n// ...\n}\n} # config/routes.yaml\nblog_list:\npath: /blog/{page<\\d+>}\ncontroller: App\\Controller\\BlogController::list <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_list\" path=\"/blog/{page<\\d+>}\"\ncontroller=\"App\\Controller\\BlogController::list\"/> <!-- ... -->\n</routes> // config/routes.php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('blog_list', '/blog/{page<\\d+>}')\n->controller([BlogController::class, 'list'])\n;\n// ...\n}; Optional Parameters", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_5", "source": "routing.rst", "text": "In the previous example, the URL of blog_list is /blog/{page}. If users\nvisit /blog/1, it will match. But if they visit /blog, it will **not**\nmatch. As soon as you add a parameter to a route, it must have a value. You can make blog_list once again match when the user visits /blog by\nadding a default value for the {page} parameter. When using attributes,\ndefault values are defined in the arguments of the controller action. In the\nother configuration formats they are defined with the defaults option: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n#[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\\d+'])]\npublic function list(int $page = 1): Response\n{\n// ...\n}\n} # config/routes.yaml\nblog_list:\npath: /blog/{page}\ncontroller: App\\Controller\\BlogController::list\ndefaults:\npage: 1\nrequirements:\npage: '\\d+' blog_show:\n# ... <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_list\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::list\">\n<default key=\"page\">1</default> <requirement key=\"page\">\\d+</requirement>\n</route> <!-- ... -->\n</routes> // config/routes.php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('blog_list', '/blog/{page}')\n->controller([BlogController::class, 'list'])\n->defaults(['page' => 1])\n->requirements(['page' => '\\d+'])\n;\n}; Now, when the user visits /blog, the blog_list route will match and\n$page will default to a value of 1. The default value is allowed to not match the requirement. You can have more than one optional parameter (e.g. /blog/{slug}/{page}),\nbut everything after an optional parameter must be optional. For example,\n/{page}/blog is a valid path, but page will always be required\n(i.e. /blog will not match this route). If you want to always include some default value in the generated URL (for\nexample to force the generation of /blog/1 instead of /blog in the\nprevious example) add the ! character before the parameter name: /blog/{!page} As it happens with requirements, default values can also be inlined in each\nparameter using the syntax {parameter_name?default_value}. This feature\nis compatible with inlined requirements, so you can inline both in a single\nparameter: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n#[Route('/blog/{page<\\d+>?1}', name: 'blog_list')]\npublic function list(int $page): Response\n{\n// ...\n}\n} # config/routes.yaml\nblog_list:\npath: /blog/{page<\\d+>?1}\ncontroller: App\\Controller\\BlogController::list <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_list\" path=\"/blog/{page<\\d+>?1}\"\ncontroller=\"App\\Controller\\BlogController::list\"/> <!-- ... -->\n</routes> // config/routes.php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('blog_list', '/blog/{page<\\d+>?1}')\n->controller([BlogController::class, 'list'])\n;\n}; To give a null default value to any parameter, add nothing after the\n? character (e.g. /blog/{page?}). If you do this, don't forget to\nupdate the types of the related controller arguments to allow passing\nnull values (e.g. replace int $page by ?int $page). Priority Parameter", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_6", "source": "routing.rst", "text": "Symfony evaluates routes in the order they are defined. If the path of a route\nmatches many different patterns, it might prevent other routes from being\nmatched. In YAML and XML you can move the route definitions up or down in the\nconfiguration file to control their priority. In routes defined as PHP\nattributes this is much harder to do, so you can set the\noptional priority parameter in those routes to control their priority: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n/**\n* This route has a greedy pattern and is defined first.\n*/\n#[Route('/blog/{slug}', name: 'blog_show')]\npublic function show(string $slug): Response\n{\n// ...\n} /**\n* This route could not be matched without defining a higher priority than 0.\n*/\n#[Route('/blog/list', name: 'blog_list', priority: 2)]\npublic function list(): Response\n{\n// ...\n}\n} The priority parameter expects an integer value. Routes with higher priority\nare sorted before routes with lower priority. The default value when it is not\ndefined is 0. Parameter Conversion A common routing need is to convert the value stored in some parameter (e.g. an\ninteger acting as the user ID) into another value (e.g. the object that\nrepresents the user). This feature is called a \"param converter\". Now, keep the previous route configuration, but change the arguments of the\ncontroller action. Instead of string $slug, add BlogPost $post:: // src/Controller/BlogController.php\nnamespace App\\Controller; use App\\Entity\\BlogPost;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n// ... #[Route('/blog/{slug:post}', name: 'blog_show')]\npublic function show(BlogPost $post): Response\n{\n// $post is the object whose slug matches the routing parameter // ...\n}\n} If your controller arguments include type-hints for objects (BlogPost in\nthis case), the \"param converter\" makes a database request to find the object\nusing the request parameters (slug in this case). If no object is found,\nSymfony generates a 404 response automatically. The {slug:post} syntax maps the route parameter named slug to the controller\nargument named $post. It also hints the \"param converter\" to look up the\ncorresponding BlogPost object from the database using the slug. Route parameter mapping was introduced in Symfony 7.1. When mapping multiple entities from route parameters, name collisions can occur.\nIn this example, the route tries to define two mappings: one for an author and one\nfor a category; both using the same name parameter. This isn't allowed because\nthe route ends up declaring name twice:: #[Route('/search-book/{name:author}/{name:category}')] Such routes should instead be defined using the following syntax:: #[Route('/search-book/{authorName:author.name}/{categoryName:category.name}')] This way, the route parameter names are unique (authorName and categoryName),\nand the \"param converter\" can correctly map them to controller arguments ($author\nand $category), loading them both by their name. This more advanced style of route parameter mapping was introduced in Symfony 7.3. More advanced mappings can be achieved using the #[MapEntity] attribute.\nCheck out the Doctrine param conversion documentation\nto learn how to customize the database queries used to fetch the object from the route\nparameter.", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_7", "source": "routing.rst", "text": "Backed Enum Parameters You can use PHP `backed enumerations`_ as route parameters because Symfony will\nconvert them automatically to their scalar values. // src/Controller/OrderController.php\nnamespace App\\Controller; use App\\Enum\\OrderStatusEnum;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class OrderController extends AbstractController\n{\n#[Route('/orders/list/{status}', name: 'list_orders_by_status')]\npublic function list(OrderStatusEnum $status = OrderStatusEnum::Paid): Response\n{\n// ...\n}\n} Special Parameters In addition to your own parameters, routes can include any of the following\nspecial parameters created by Symfony: _controller\nThis parameter is used to determine which controller and action is executed\nwhen the route is matched. _format\nThe matched value is used to set the \"request format\" of the Request object.\nThis is used for such things as setting the Content-Type of the response\n(e.g. a json format translates into a Content-Type of application/json). _fragment\nUsed to set the fragment identifier, which is the optional last part of a URL that\nstarts with a # character and is used to identify a portion of a document. _locale\nUsed to set the locale on the request. You can include these attributes (except _fragment) both in individual routes\nand in route imports. Symfony defines some special attributes with the same name\n(except for the leading underscore) so you can define them easier: // src/Controller/ArticleController.php\nnamespace App\\Controller; // ...\nclass ArticleController extends AbstractController\n{\n#[Route(\npath: '/articles/{_locale}/search.{_format}',\nlocale: 'en',\nformat: 'html',\nrequirements: [\n'_locale' => 'en|fr',\n'_format' => 'html|xml',\n],\n)]\npublic function search(): Response\n{\n}\n} # config/routes.yaml\narticle_search:\npath: /articles/{_locale}/search.{_format}\ncontroller: App\\Controller\\ArticleController::search\nlocale: en\nformat: html\nrequirements:\n_locale: en|fr\n_format: html|xml <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"article_search\"\npath=\"/articles/{_locale}/search.{_format}\"\ncontroller=\"App\\Controller\\ArticleController::search\"\nlocale=\"en\"\nformat=\"html\"> <requirement key=\"_locale\">en|fr</requirement>\n<requirement key=\"_format\">html|xml</requirement> </route>\n</routes> // config/routes.php\nnamespace Symfony\\Component\\Routing\\Loader\\Configurator; use App\\Controller\\ArticleController; return static function (RoutingConfigurator $routes): void {\n$routes->add('article_show', '/articles/{_locale}/search.{_format}')\n->controller([ArticleController::class, 'search'])\n->locale('en')\n->format('html')\n->requirements([\n'_locale' => 'en|fr',\n'_format' => 'html|xml',\n])\n;\n}; Extra Parameters In the defaults option of a route you can optionally define parameters not\nincluded in the route configuration. This is useful to pass extra arguments to\nthe controllers of the routes: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n#[Route('/blog/{page}', name: 'blog_index', defaults: ['page' => 1, 'title' => 'Hello world!'])]\npublic function index(int $page, string $title): Response\n{\n// ...\n}\n} # config/routes.yaml\nblog_index:\npath: /blog/{page}\ncontroller: App\\Controller\\BlogController::index\ndefaults:\npage: 1\ntitle: \"Hello world!\" <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_index\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::index\">\n<default key=\"page\">1</default>\n<default key=\"title\">Hello world!</default>\n</route>\n</routes> // config/routes.php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('blog_index', '/blog/{page}')\n->controller([BlogController::class, 'index'])\n->defaults([\n'page' => 1,\n'title' => 'Hello world!',\n])\n;\n}; Slash Characters in Route Parameters Route parameters can contain any values except the / slash character,\nbecause that's the character used to separate the different parts of the URLs.\nFor example, if the token value in the /share/{token} route contains a\n/ character, this route won't match.", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_8", "source": "routing.rst", "text": "A possible solution is to change the parameter requirements to be more permissive: // src/Controller/DefaultController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class DefaultController extends AbstractController\n{\n#[Route('/share/{token}', name: 'share', requirements: ['token' => '.+'])]\npublic function share($token): Response\n{\n// ...\n}\n} # config/routes.yaml\nshare:\npath: /share/{token}\ncontroller: App\\Controller\\DefaultController::share\nrequirements:\ntoken: .+ <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"share\" path=\"/share/{token}\" controller=\"App\\Controller\\DefaultController::share\">\n<requirement key=\"token\">.+</requirement>\n</route>\n</routes> // config/routes.php\nuse App\\Controller\\DefaultController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('share', '/share/{token}')\n->controller([DefaultController::class, 'share'])\n->requirements([\n'token' => '.+',\n])\n;\n}; If the route defines several parameters and you apply this permissive\nregular expression to all of them, you might get unexpected results. For\nexample, if the route definition is /share/{path}/{token} and both\npath and token accept /, then token will only get the last part\nand the rest is matched by path. If the route includes the special {_format} parameter, you shouldn't\nuse the .+ requirement for the parameters that allow slashes. For example,\nif the pattern is /share/{token}.{_format} and {token} allows any\ncharacter, the /share/foo/bar.json URL will consider foo/bar.json\nas the token and the format will be empty. This can be solved by replacing\nthe .+ requirement by [^.]+ to allow any character except dots. Route Aliasing Route alias allows you to have multiple names for the same route\nand can be used to provide backward compatibility for routes that\nhave been renamed. Let's say you have a route called product_show: // src/Controller/ProductController.php\nnamespace App\\Controller; use Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class ProductController\n{\n#[Route('/product/{id}', name: 'product_show')]\npublic function show(): Response\n{\n// ...\n}\n} # config/routes.yaml\nproduct_show:\npath: /product/{id}\ncontroller: App\\Controller\\ProductController::show <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"product_show\" path=\"/product/{id}\" controller=\"App\\Controller\\ProductController::show\"/>\n</routes> // config/routes.php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('product_show', '/product/{id}')\n->controller('App\\Controller\\ProductController::show');\n}; Now, let's say you want to create a new route called product_details\nthat acts exactly the same as product_show. Instead of duplicating the original route, you can create an alias for it. // src/Controller/ProductController.php\nnamespace App\\Controller; use Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class ProductController\n{\n// the \"alias\" argument assigns an alternate name to this route;\n// the alias will point to the actual route \"product_show\"\n#[Route('/product/{id}', name: 'product_show', alias: ['product_details'])]\npublic function show(): Response\n{\n// ...\n}\n} # config/routes.yaml\nproduct_show:\npath: /product/{id}\ncontroller: App\\Controller\\ProductController::show product_details:\n# \"alias\" option refers to the name of the route declared above\nalias: product_show <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"product_show\" path=\"/product/{id}\" controller=\"App\\Controller\\ProductController::show\"/>\n<!-- \"alias\" attribute value refers to the name of the route declared above -->\n<route id=\"product_details\" alias=\"product_show\"/>\n</routes> // config/routes.php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('product_show', '/product/{id}')\n->controller('App\\Controller\\ProductController::show');\n// second argument refers to the name of the route declared above\n$routes->alias('product_details', 'product_show');\n}; Support for route aliases in PHP attributes was introduced in Symfony 7.3.", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_9", "source": "routing.rst", "text": "In this example, both product_show and product_details routes can\nbe used in the application and will produce the same result. YAML, XML, and PHP configuration formats are the only ways to define an alias\nfor a route that you do not own. You can't do this when using PHP attributes. This allows you for example to use your own route name for URL generation,\nwhile still targeting a route defined by a third-party bundle. The alias and\nthe original route do not need to be declared in the same file or format. Deprecating Route Aliases Route aliases can be used to provide backward compatibility for routes that\nhave been renamed. Now, let's say you want to replace the product_show route in favor of\nproduct_details and mark the old one as deprecated. In the previous example, the alias product_details was pointing to\nproduct_show route. To mark the product_show route as deprecated, you need to \"switch\" the alias.\nThe product_show become the alias, and will now point to the product_details route.\nThis way, the product_show alias could be deprecated. // src/Controller/ProductController.php\nnamespace App\\Controller; use Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\DeprecatedAlias;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class ProductController\n{\n// this outputs the following generic deprecation message:\n// Since acme/package 1.2: The \"product_show\" route alias is deprecated. You should stop using it, as it will be removed in the future.\n#[Route('/product/{id}',\nname: 'product_details',\nalias: new DeprecatedAlias(\naliasName: 'product_show',\npackage: 'acme/package',\nversion: '1.2',\n),\n)]\n// Or, you can also define a custom deprecation message (%alias_id% placeholder is available)\n#[Route('/product/{id}',\nname: 'product_details',\nalias: new DeprecatedAlias(\naliasName: 'product_show',\npackage: 'acme/package',\nversion: '1.2',\nmessage: 'The \"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead.',\n),\n)]\npublic function show(): Response\n{\n// ...\n}\n} # Move the concrete route definition under product_details\nproduct_details:\npath: /product/{id}\ncontroller: App\\Controller\\ProductController::show # Define the alias and the deprecation under the product_show definition\nproduct_show:\nalias: product_details # this outputs the following generic deprecation message:\n# Since acme/package 1.2: The \"product_show\" route alias is deprecated. You should stop using it, as it will be removed in the future.\ndeprecated:\npackage: 'acme/package'\nversion: '1.2' # or # you can define a custom deprecation message (%alias_id% placeholder is available)\ndeprecated:\npackage: 'acme/package'\nversion: '1.2'\nmessage: 'The \"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead.' <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <!-- Move the concrete route definition under product_details -->\n<route id=\"product_details\" path=\"/product/{id}\" controller=\"App\\Controller\\ProductController::show\"/> <!-- Define the alias and the deprecation under the product_show definition -->\n<route id=\"product_show\" alias=\"product_details\">\n<!-- this outputs the following generic deprecation message:\nSince acme/package 1.2: The \"product_show\" route alias is deprecated. You should stop using it, as it will be removed in the future. -->\n<deprecated package=\"acme/package\" version=\"1.2\"/> <!-- or --> <!-- you can define a custom deprecation message (%alias_id% placeholder is available) -->\n<deprecated package=\"acme/package\" version=\"1.2\">\nThe \"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead.\n</deprecated>\n</route>\n</routes> $routes->add('product_details', '/product/{id}')\n->controller('App\\Controller\\ProductController::show');", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_10", "source": "routing.rst", "text": "$routes->alias('product_show', 'product_details')\n// this outputs the following generic deprecation message:\n// Since acme/package 1.2: The \"product_show\" route alias is deprecated. You should stop using it, as it will be removed in the future.\n->deprecate('acme/package', '1.2', '') // or // you can define a custom deprecation message (%alias_id% placeholder is available)\n->deprecate(\n'acme/package',\n'1.2',\n'The \"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead.'\n)\n; The DeprecatedAlias class for PHP attributes was introduced in Symfony 7.3. In this example, every time the product_show alias is used, a deprecation\nwarning is triggered, advising you to stop using this route and prefer using product_details. The message is actually a message template, which replaces occurrences of the\n%alias_id% placeholder by the route alias name. You **must** have\nat least one occurrence of the %alias_id% placeholder in your template. Route Groups and Prefixes It's common for a group of routes to share some options (e.g. all routes related\nto the blog start with /blog) That's why Symfony includes a feature to share\nroute configuration. When defining routes as attributes, put the common configuration\nin the #[Route] attribute of the controller class.\nIn other routing formats, define the common configuration using options\nwhen importing the routes. // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; #[Route('/blog', requirements: ['_locale' => 'en|es|fr'], name: 'blog_')]\nclass BlogController extends AbstractController\n{\n#[Route('/{_locale}', name: 'index')]\npublic function index(): Response\n{\n// ...\n} #[Route('/{_locale}/posts/{slug}', name: 'show')]\npublic function show(string $slug): Response\n{\n// ...\n}\n} # config/routes/attributes.yaml\ncontrollers:\nresource: '../../src/Controller/'\ntype: attribute\n# this is added to the beginning of all imported route URLs\nprefix: '/blog'\n# this is added to the beginning of all imported route names\nname_prefix: 'blog_'\n# these requirements are added to all imported routes\nrequirements:\n_locale: 'en|es|fr' # An imported route with an empty URL will become \"/blog/\"\n# Uncomment this option to make that URL \"/blog\" instead\n# trailing_slash_on_root: false # you can optionally exclude some files/subdirectories when loading attributes\n# (the value must be a string or an array of PHP glob patterns)\n# exclude: '../../src/Controller/{Debug*Controller.php}' <!-- config/routes/attributes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <!--\nthe 'prefix' value is added to the beginning of all imported route URLs\nthe 'name-prefix' value is added to the beginning of all imported route names\nthe 'exclude' option defines the files or subdirectories ignored when loading attributes\n(the value must be a PHP glob pattern and you can repeat this option any number of times)\n-->\n<import resource=\"../../src/Controller/\"\ntype=\"attribute\"\nprefix=\"/blog\"\nname-prefix=\"blog_\"\nexclude=\"../../src/Controller/{Debug*Controller.php}\">\n<!-- these requirements are added to all imported routes -->\n<requirement key=\"_locale\">en|es|fr</requirement>\n</import> <!-- An imported route with an empty URL will become \"/blog/\"\nUncomment this option to make that URL \"/blog\" instead -->\n<import resource=\"../../src/Controller/\" type=\"attribute\"\nprefix=\"/blog\"\ntrailing-slash-on-root=\"false\">\n<!-- ... -->\n</import>\n</routes> // config/routes/attributes.php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_11", "source": "routing.rst", "text": "return static function (RoutingConfigurator $routes): void {\n$routes->import(\n'../../src/Controller/',\n'attribute',\nfalse,\n// the optional fourth argument is used to exclude some files\n// or subdirectories when loading attributes\n// (the value must be a string or an array of PHP glob patterns)\n'../../src/Controller/{Debug*Controller.php}'\n)\n// this is added to the beginning of all imported route URLs\n->prefix('/blog') // An imported route with an empty URL will become \"/blog/\"\n// Pass FALSE as the second argument to make that URL \"/blog\" instead\n// ->prefix('/blog', false) // this is added to the beginning of all imported route names\n->namePrefix('blog_') // these requirements are added to all imported routes\n->requirements(['_locale' => 'en|es|fr'])\n;\n}; The exclude option only works when the resource value is a glob string.\nIf you use a regular string (e.g. '../src/Controller') the exclude\nvalue will be ignored. In this example, the route of the index() action will be called blog_index\nand its URL will be /blog/{_locale}. The route of the show() action will be called\nblog_show and its URL will be /blog/{_locale}/posts/{slug}. Both routes\nwill also validate that the _locale parameter matches the regular expression\ndefined in the class attribute. If any of the prefixed routes defines an empty path, Symfony adds a trailing\nslash to it. In the previous example, an empty path prefixed with /blog\nwill result in the /blog/ URL. If you want to avoid this behavior, set\nthe trailing_slash_on_root option to false (this option is not\navailable when using PHP attributes): # config/routes/attributes.yaml\ncontrollers:\nresource: '../../src/Controller/'\ntype: attribute\nprefix: '/blog'\ntrailing_slash_on_root: false\n# ... <!-- config/routes/attributes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"../../src/Controller/\"\ntype=\"attribute\"\nprefix=\"/blog\"\nname-prefix=\"blog_\"\ntrailing-slash-on-root=\"false\"\nexclude=\"../../src/Controller/{DebugEmailController}.php\">\n<!-- ... -->\n</import>\n</routes> // config/routes/attributes.php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->import('../../src/Controller/', 'attribute')\n// the second argument is the $trailingSlashOnRoot option\n->prefix('/blog', false) // ...\n;\n}; Symfony can import routes from different sources\nand you can even create your own route loader. Getting the Route Name and Parameters The Request object created by Symfony stores all the route configuration\n(such as the name and parameters) in the \"request attributes\". You can get this\ninformation in a controller via the Request object:: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController\n{\n#[Route('/blog', name: 'blog_list')]\npublic function list(Request $request): Response\n{\n$routeName = $request->attributes->get('_route');\n$routeParameters = $request->attributes->get('_route_params'); // use this to get all the available attributes (not only routing ones):\n$allAttributes = $request->attributes->all(); // ...\n}\n} In services, you can get this information by\ninjecting the RequestStack service .\nIn templates, use the Twig global app variable\nto get the current route name (app.current_route) and its parameters\n(app.current_route_parameters). Special Routes Symfony defines some special controllers to render templates and redirect to\nother routes from the route configuration so you don't have to create a\ncontroller action. Rendering a Template Directly from a Route", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_12", "source": "routing.rst", "text": "Read the section about rendering a template from a route\nin the main article about Symfony templates. Redirecting to URLs and Routes Directly from a Route Use the RedirectController to redirect to other routes and URLs: # config/routes.yaml\ndoc_shortcut:\npath: /doc\ncontroller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\ndefaults:\nroute: 'doc_page'\n# optionally you can define some arguments passed to the route\npage: 'index'\nversion: 'current'\n# redirections are temporary by default (code 302) but you can make them permanent (code 301)\npermanent: true\n# add this to keep the original query string parameters when redirecting\nkeepQueryParams: true\n# add this to keep the HTTP method when redirecting. The redirect status changes\n# * for temporary redirects, it uses the 307 status code instead of 302\n# * for permanent redirects, it uses the 308 status code instead of 301\nkeepRequestMethod: true\n# add this to remove all original route attributes when redirecting\nignoreAttributes: true\n# or specify which attributes to ignore:\n# ignoreAttributes: ['offset', 'limit'] legacy_doc:\npath: /legacy/doc\ncontroller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\ndefaults:\n# this value can be an absolute path or an absolute URL\npath: 'https://legacy.example.com/doc'\npermanent: true <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"doc_shortcut\" path=\"/doc\"\ncontroller=\"Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\">\n<default key=\"route\">doc_page</default>\n<!-- optionally you can define some arguments passed to the route -->\n<default key=\"page\">index</default>\n<default key=\"version\">current</default>\n<!-- redirections are temporary by default (code 302) but you can make them permanent (code 301)-->\n<default key=\"permanent\">true</default>\n<!-- add this to keep the original query string parameters when redirecting -->\n<default key=\"keepQueryParams\">true</default>\n<!-- add this to keep the HTTP method when redirecting. The redirect status changes:\n* for temporary redirects, it uses the 307 status code instead of 302\n* for permanent redirects, it uses the 308 status code instead of 301 -->\n<default key=\"keepRequestMethod\">true</default>\n</route> <route id=\"legacy_doc\" path=\"/legacy/doc\"\ncontroller=\"Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\">\n<!-- this value can be an absolute path or an absolute URL -->\n<default key=\"path\">https://legacy.example.com/doc</default>\n<!-- redirections are temporary by default (code 302) but you can make them permanent (code 301)-->\n<default key=\"permanent\">true</default>\n</route>\n</routes> // config/routes.php\nuse App\\Controller\\DefaultController;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('doc_shortcut', '/doc')\n->controller(RedirectController::class)\n->defaults([\n'route' => 'doc_page',\n// optionally you can define some arguments passed to the route\n'page' => 'index',\n'version' => 'current',\n// redirections are temporary by default (code 302) but you can make them permanent (code 301)\n'permanent' => true,\n// add this to keep the original query string parameters when redirecting\n'keepQueryParams' => true,\n// add this to keep the HTTP method when redirecting. The redirect status changes:\n// * for temporary redirects, it uses the 307 status code instead of 302\n// * for permanent redirects, it uses the 308 status code instead of 301\n'keepRequestMethod' => true,\n])\n; $routes->add('legacy_doc', '/legacy/doc')\n->controller(RedirectController::class)\n->defaults([\n// this value can be an absolute path or an absolute URL\n'path' => 'https://legacy.example.com/doc',\n// redirections are temporary by default (code 302) but you can make them permanent (code 301)\n'permanent' => true,\n])\n;\n};", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_13", "source": "routing.rst", "text": "Symfony also provides some utilities to\nredirect inside controllers Redirecting URLs with Trailing Slashes\n...................................... Historically, URLs have followed the UNIX convention of adding trailing slashes\nfor directories (e.g. https://example.com/foo/) and removing them to refer\nto files (https://example.com/foo). Although serving different contents for\nboth URLs is OK, nowadays it's common to treat both URLs as the same URL and\nredirect between them. Symfony follows this logic to redirect between URLs with and without trailing\nslashes (but only for GET and HEAD requests): ========== ======================================== ==========================================\nRoute URL If the requested URL is /foo If the requested URL is /foo/\n========== ======================================== ==========================================\n/foo It matches (200 status response) It makes a 301 redirect to /foo\n/foo/ It makes a 301 redirect to /foo/ It matches (200 status response)\n========== ======================================== ========================================== Sub-Domain Routing Routes can configure a host option to require that the HTTP host of the\nincoming requests matches some specific value. In the following example, both\nroutes match the same path (/) but one of them only responds to a specific\nhost name: // src/Controller/MainController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class MainController extends AbstractController\n{\n#[Route('/', name: 'mobile_homepage', host: 'm.example.com')]\npublic function mobileHomepage(): Response\n{\n// ...\n} #[Route('/', name: 'homepage')]\npublic function homepage(): Response\n{\n// ...\n}\n} # config/routes.yaml\nmobile_homepage:\npath: /\nhost: m.example.com\ncontroller: App\\Controller\\MainController::mobileHomepage homepage:\npath: /\ncontroller: App\\Controller\\MainController::homepage <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"mobile_homepage\"\npath=\"/\"\nhost=\"m.example.com\"\ncontroller=\"App\\Controller\\MainController::mobileHomepage\"/> <route id=\"homepage\" path=\"/\" controller=\"App\\Controller\\MainController::homepage\"/>\n</routes> // config/routes.php\nuse App\\Controller\\MainController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('mobile_homepage', '/')\n->controller([MainController::class, 'mobileHomepage'])\n->host('m.example.com')\n;\n$routes->add('homepage', '/')\n->controller([MainController::class, 'homepage'])\n;\n}; The value of the host option can include parameters (which is useful in\nmulti-tenant applications) and these parameters can be validated too with\nrequirements: // src/Controller/MainController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class MainController extends AbstractController\n{\n#[Route(\n'/',\nname: 'mobile_homepage',\nhost: '{subdomain}.example.com',\ndefaults: ['subdomain' => 'm'],\nrequirements: ['subdomain' => 'm|mobile'],\n)]\npublic function mobileHomepage(): Response\n{\n// ...\n} #[Route('/', name: 'homepage')]\npublic function homepage(): Response\n{\n// ...\n}\n} # config/routes.yaml\nmobile_homepage:\npath: /\nhost: \"{subdomain}.example.com\"\ncontroller: App\\Controller\\MainController::mobileHomepage\ndefaults:\nsubdomain: m\nrequirements:\nsubdomain: m|mobile homepage:\npath: /\ncontroller: App\\Controller\\MainController::homepage <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"mobile_homepage\"\npath=\"/\"\nhost=\"{subdomain}.example.com\"\ncontroller=\"App\\Controller\\MainController::mobileHomepage\">\n<default key=\"subdomain\">m</default>\n<requirement key=\"subdomain\">m|mobile</requirement>\n</route> <route id=\"homepage\" path=\"/\" controller=\"App\\Controller\\MainController::homepage\"/>\n</routes> // config/routes.php\nuse App\\Controller\\MainController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('mobile_homepage', '/')\n->controller([MainController::class, 'mobileHomepage'])\n->host('{subdomain}.example.com')\n->defaults([\n'subdomain' => 'm',\n])\n->requirements([\n'subdomain' => 'm|mobile',\n])\n;\n$routes->add('homepage', '/')\n->controller([MainController::class, 'homepage'])\n;\n}; In the above example, the subdomain parameter defines a default value because\notherwise you need to include a subdomain value each time you generate a URL using\nthese routes. You can also set the host option when importing routes\nto make all of them require that host name. When using sub-domain routing, you must set the Host HTTP headers in\nfunctional tests or routes won't match::", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_14", "source": "routing.rst", "text": "$crawler = $client->request(\n'GET',\n'/',\n[],\n[],\n['HTTP_HOST' => 'm.example.com']\n// or get the value from some configuration parameter:\n// ['HTTP_HOST' => 'm.'.$client->getContainer()->getParameter('domain')]\n); You can also use the inline defaults and requirements format in the\nhost option: {subdomain<m|mobile>?m}.example.com Localized Routes (i18n) If your application is translated into multiple languages, each route can define\na different URL per each translation locale . This\navoids the need for duplicating routes, which also reduces the potential bugs: // src/Controller/CompanyController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class CompanyController extends AbstractController\n{\n#[Route(path: [\n'en' => '/about-us',\n'nl' => '/over-ons'\n], name: 'about_us')]\npublic function about(): Response\n{\n// ...\n}\n} # config/routes.yaml\nabout_us:\npath:\nen: /about-us\nnl: /over-ons\ncontroller: App\\Controller\\CompanyController::about <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"about_us\" controller=\"App\\Controller\\CompanyController::about\">\n<path locale=\"en\">/about-us</path>\n<path locale=\"nl\">/over-ons</path>\n</route>\n</routes> // config/routes.php\nuse App\\Controller\\CompanyController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('about_us', [\n'en' => '/about-us',\n'nl' => '/over-ons',\n])\n->controller([CompanyController::class, 'about'])\n;\n}; When using PHP attributes for localized routes, you have to use the path\nnamed parameter to specify the array of paths. When a localized route is matched, Symfony uses the same locale automatically\nduring the entire request. When the application uses full \"language + territory\" locales (e.g. fr_FR,\nfr_BE), if the URLs are the same in all related locales, routes can use\nonly the language part (e.g. fr) to avoid repeating the same URLs. A common requirement for internationalized applications is to prefix all routes\nwith a locale. This can be done by defining a different prefix for each locale\n(and setting an empty prefix for your default locale if you prefer it): # config/routes/attributes.yaml\ncontrollers:\nresource: '../../src/Controller/'\ntype: attribute\nprefix:\nen: '' # don't prefix URLs for English, the default locale\nnl: '/nl' <!-- config/routes/attributes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"../../src/Controller/\" type=\"attribute\">\n<!-- don't prefix URLs for English, the default locale -->\n<prefix locale=\"en\"></prefix>\n<prefix locale=\"nl\">/nl</prefix>\n</import>\n</routes> // config/routes/attributes.php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->import('../../src/Controller/', 'attribute')\n->prefix([\n// don't prefix URLs for English, the default locale\n'en' => '',\n'nl' => '/nl',\n])\n;\n}; If a route being imported includes the special _locale\nparameter in its own definition, Symfony will only import it for that locale\nand not for the other configured locale prefixes. E.g. if a route contains locale: 'en' in its definition and it's being\nimported with en (prefix: empty) and nl (prefix: /nl) locales,\nthat route will be available only in en locale and not in nl. Another common requirement is to host the website on a different domain\naccording to the locale. This can be done by defining a different host for each\nlocale. # config/routes/attributes.yaml\ncontrollers:\nresource: '../../src/Controller/'\ntype: attribute\nhost:\nen: 'www.example.com'\nnl: 'www.example.nl' <!-- config/routes/attributes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\">\n<import resource=\"../../src/Controller/\" type=\"attribute\">\n<host locale=\"en\">www.example.com</host>\n<host locale=\"nl\">www.example.nl</host>\n</import>\n</routes>", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_15", "source": "routing.rst", "text": "// config/routes/attributes.php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n$routes->import('../../src/Controller/', 'attribute')\n->host([\n'en' => 'www.example.com',\n'nl' => 'www.example.nl',\n])\n;\n}; Stateless Routes Sometimes, when an HTTP response should be cached, it is important to ensure\nthat can happen. However, whenever a session is started during a request,\nSymfony turns the response into a private non-cacheable response. For details, see /http_cache. Routes can configure a stateless boolean option in order to declare that the\nsession shouldn't be used when matching a request: // src/Controller/MainController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class MainController extends AbstractController\n{\n#[Route('/', name: 'homepage', stateless: true)]\npublic function homepage(): Response\n{\n// ...\n}\n} # config/routes.yaml\nhomepage:\ncontroller: App\\Controller\\MainController::homepage\npath: /\nstateless: true <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\">\n<route id=\"homepage\" controller=\"App\\Controller\\MainController::homepage\" path=\"/\" stateless=\"true\"/>\n</routes> // config/routes.php\nuse App\\Controller\\MainController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('homepage', '/')\n->controller([MainController::class, 'homepage'])\n->stateless()\n;\n}; Now, if the session is used, the application will report it based on your\nkernel.debug parameter: * enabled: will throw an Symfony\\\\Component\\\\HttpKernel\\\\Exception\\\\UnexpectedSessionUsageException exception\n* disabled: will log a warning It will help you understand and hopefully fixing unexpected behavior in your application. Generating URLs Routing systems are bidirectional: 1. they associate URLs with controllers (as explained in the previous sections);\n2. they generate URLs for a given route. Generating URLs from routes allows you to not write the <a href=\"...\">\nvalues manually in your HTML templates. Also, if the URL of some route changes,\nyou only have to update the route configuration and all links will be updated. To generate a URL, you need to specify the name of the route (e.g.\nblog_show) and the values of the parameters defined by the route (e.g.\nslug = my-blog-post). For that reason each route has an internal name that must be unique in the\napplication. If you don't set the route name explicitly with the name\noption, Symfony generates an automatic name based on the controller and action. Symfony declares route aliases based on the FQCN if the target class has an\n__invoke() method that adds a route **and** if the target class added\none route exactly. Symfony also automatically adds an alias for every method\nthat defines only one route. Consider the following class:: // src/Controller/MainController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\Routing\\Attribute\\Route; final class MainController extends AbstractController\n{\n#[Route('/', name: 'homepage')]\npublic function homepage(): Response\n{\n// ...\n}\n} Symfony will add a route alias named App\\Controller\\MainController::homepage. Generating URLs in Controllers If your controller extends from the AbstractController ,\nuse the generateUrl() helper:: // src/Controller/BlogController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\nuse Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface; class BlogController extends AbstractController\n{\n#[Route('/blog', name: 'blog_list')]\npublic function list(): Response\n{\n// generate a URL with no route arguments\n$signUpPage = $this->generateUrl('sign_up'); // generate a URL with route arguments\n$userProfilePage = $this->generateUrl('user_profile', [\n'username' => $user->getUserIdentifier(),\n]);", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_16", "source": "routing.rst", "text": "// generated URLs are \"absolute paths\" by default. Pass a third optional\n// argument to generate different URLs (e.g. an \"absolute URL\")\n$signUpPage = $this->generateUrl('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL); // when a route is localized, Symfony uses by default the current request locale\n// pass a different '_locale' value if you want to set the locale explicitly\n$signUpPageInDutch = $this->generateUrl('sign_up', ['_locale' => 'nl']); // ...\n}\n} If you pass to the generateUrl() method some parameters that are not\npart of the route definition, they are included in the generated URL as a\nquery string:: $this->generateUrl('blog', ['page' => 2, 'category' => 'Symfony']);\n// the 'blog' route only defines the 'page' parameter; the generated URL is:\n// /blog/2?category=Symfony While objects are converted to string when used as placeholders, they are not\nconverted when used as extra parameters. So, if you're passing an object (e.g. an Uuid)\nas value of an extra parameter, you need to explicitly convert it to a string:: $this->generateUrl('blog', ['uuid' => (string) $entity->getUuid()]); If your controller does not extend from AbstractController, you'll need to\nfetch services in your controller and\nfollow the instructions of the next section. Generating URLs in Services Inject the router Symfony service into your own services and use its\ngenerate() method. When using service autowiring\nyou only need to add an argument in the service constructor and type-hint it with\nthe Symfony\\\\Component\\\\Routing\\\\Generator\\\\UrlGeneratorInterface class:: // src/Service/SomeService.php\nnamespace App\\Service; use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface; class SomeService\n{\npublic function __construct(\nprivate UrlGeneratorInterface $urlGenerator,\n) {\n} public function someMethod(): void\n{\n// ... // generate a URL with no route arguments\n$signUpPage = $this->urlGenerator->generate('sign_up'); // generate a URL with route arguments\n$userProfilePage = $this->urlGenerator->generate('user_profile', [\n'username' => $user->getUserIdentifier(),\n]); // generated URLs are \"absolute paths\" by default. Pass a third optional\n// argument to generate different URLs (e.g. an \"absolute URL\")\n$signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL); // when a route is localized, Symfony uses by default the current request locale\n// pass a different '_locale' value if you want to set the locale explicitly\n$signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']);\n}\n} Generating URLs in Templates Read the section about creating links between pages\nin the main article about Symfony templates. Generating URLs in JavaScript If your JavaScript code is included in a Twig template, you can use the\npath() and url() Twig functions to generate the URLs and store them in\nJavaScript variables. The escape() filter is needed to escape any\nnon-JavaScript-safe values: <script>\nconst route = \"{{ path('blog_show', {slug: 'my-blog-post'})|escape('js') }}\";\n</script> If you need to generate URLs dynamically or if you are using pure JavaScript\ncode, this solution doesn't work. In those cases, consider using the\n`FOSJsRoutingBundle`_. Generating URLs in Commands Generating URLs in commands works the same as\ngenerating URLs in services . The\nonly difference is that commands are not executed in the HTTP context. Therefore,\nif you generate absolute URLs, you'll get http://localhost/ as the host name\ninstead of your real host name.", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_17", "source": "routing.rst", "text": "The solution is to configure the default_uri option to define the\n\"request context\" used by commands when they generate URLs: # config/packages/routing.yaml\nframework:\nrouter:\n# ...\ndefault_uri: 'https://example.org/my/path/' <!-- config/packages/routing.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:router default-uri=\"https://example.org/my/path/\">\n<!-- ... -->\n</framework:router>\n</framework:config>\n</container> // config/packages/routing.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->router()->defaultUri('https://example.org/my/path/');\n}; Now you'll get the expected results when generating URLs in your commands:: // src/Command/MyCommand.php\nnamespace App\\Command; use Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\nuse Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\n// ... #[AsCommand(name: 'app:my-command')]\nclass MyCommand\n{\npublic function __construct(\nprivate UrlGeneratorInterface $urlGenerator,\n) {\n} public function __invoke(SymfonyStyle $io): int\n{\n// generate a URL with no route arguments\n$signUpPage = $this->urlGenerator->generate('sign_up'); // generate a URL with route arguments\n$userProfilePage = $this->urlGenerator->generate('user_profile', [\n'username' => $user->getUserIdentifier(),\n]); // by default, generated URLs are \"absolute paths\". Pass a third optional\n// argument to generate different URIs (e.g. an \"absolute URL\")\n$signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL); // when a route is localized, Symfony uses by default the current request locale\n// pass a different '_locale' value if you want to set the locale explicitly\n$signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']); // ...\n}\n} By default, the URLs generated for web assets use the same default_uri\nvalue, but you can change it with the asset.request_context.base_path\nand asset.request_context.secure container parameters. Checking if a Route Exists In highly dynamic applications, it may be necessary to check whether a route\nexists before using it to generate a URL. In those cases, don't use the\nSymfony\\\\Component\\\\Routing\\\\Router::getRouteCollection method because\nthat regenerates the routing cache and slows down the application. Instead, try to generate the URL and catch the\nSymfony\\\\Component\\\\Routing\\\\Exception\\\\RouteNotFoundException thrown\nwhen the route doesn't exist:: use Symfony\\Component\\Routing\\Exception\\RouteNotFoundException; // ... try {\n$url = $this->router->generate($routeName, $routeParameters);\n} catch (RouteNotFoundException $e) {\n// the route is not defined...\n} Forcing HTTPS on Generated URLs If your server runs behind a proxy that terminates SSL, make sure to\nconfigure Symfony to work behind a proxy The configuration for the scheme is only used for non-HTTP requests.\nThe schemes option together with incorrect proxy configuration will\nlead to a redirect loop. By default, generated URLs use the same HTTP scheme as the current request.\nIn console commands, where there is no HTTP request, URLs use http by\ndefault. You can change this per command (via the router's getContext()\nmethod) or globally with these configuration parameters: # config/services.yaml\nparameters:\nrouter.request_context.scheme: 'https'\nasset.request_context.secure: true <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters>\n<parameter key=\"router.request_context.scheme\">https</parameter>\n<parameter key=\"asset.request_context.secure\">true</parameter>\n</parameters> </container> // config/services.php\n$container->parameters()\n->set('router.request_context.scheme', 'https')\n->set('asset.request_context.secure', true)\n; Outside of console commands, use the schemes option to define the scheme of\neach route explicitly: // src/Controller/SecurityController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class SecurityController extends AbstractController\n{\n#[Route('/login', name: 'login', schemes: ['https'])]\npublic function login(): Response\n{\n// ...\n}\n} # config/routes.yaml\nlogin:\npath: /login\ncontroller: App\\Controller\\SecurityController::login\nschemes: [https] <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_18", "source": "routing.rst", "text": "<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"login\" path=\"/login\" schemes=\"https\"\ncontroller=\"App\\Controller\\SecurityController::login\"/>\n</routes> // config/routes.php\nuse App\\Controller\\SecurityController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->add('login', '/login')\n->controller([SecurityController::class, 'login'])\n->schemes(['https'])\n;\n}; The URL generated for the login route will always use HTTPS. This means that\nwhen using the path() Twig function to generate URLs, you may get an\nabsolute URL instead of a relative URL if the HTTP scheme of the original\nrequest is different from the scheme used by the route: {# if the current scheme is HTTPS, generates a relative URL: /login #}\n{{ path('login') }} {# if the current scheme is HTTP, generates an absolute URL to change\nthe scheme: https://example.com/login #}\n{{ path('login') }} The scheme requirement is also enforced for incoming requests. If you try to\naccess the /login URL with HTTP, you will automatically be redirected to the\nsame URL, but with the HTTPS scheme. If you want to force a group of routes to use HTTPS, you can define the default\nscheme when importing them. The following example forces HTTPS on all routes\ndefined as attributes: # config/routes/attributes.yaml\ncontrollers:\nresource: '../../src/Controller/'\ntype: attribute\nschemes: [https] <!-- config/routes/attributes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"../../src/Controller/\" type=\"attribute\" schemes=\"https\"/>\n</routes> // config/routes/attributes.php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->import('../../src/Controller/', 'attribute')\n->schemes(['https'])\n;\n}; The Security component provides\nanother way to enforce HTTP or HTTPS\nvia the requires_channel setting. Signing URIs A signed URI is an URI that includes a hash value that depends on the contents of\nthe URI. This way, you can later check the integrity of the signed URI by\nrecomputing its hash value and comparing it with the hash included in the URI. Symfony provides a utility to sign URIs via the Symfony\\\\Component\\\\HttpFoundation\\\\UriSigner\nservice, which you can inject in your services or controllers:: // src/Service/SomeService.php\nnamespace App\\Service; use Symfony\\Component\\HttpFoundation\\UriSigner; class SomeService\n{\npublic function __construct(\nprivate UriSigner $uriSigner,\n) {\n} public function someMethod(): void\n{\n// ... // generate a URL yourself or get it somehow...\n$url = 'https://example.com/foo/bar?sort=desc'; // sign the URL (it adds a query parameter called '_hash')\n$signedUrl = $this->uriSigner->sign($url);\n// $url = 'https://example.com/foo/bar?sort=desc&_hash=e4a21b9' // check the URL signature\n$uriSignatureIsValid = $this->uriSigner->check($signedUrl);\n// $uriSignatureIsValid = true // if you have access to the current Request object, you can use this\n// other method to pass the entire Request object instead of the URI:\n$uriSignatureIsValid = $this->uriSigner->checkRequest($request);\n}\n} For security reasons, it's common to make signed URIs expire after some time\n(e.g. when using them to reset user credentials). By default, signed URIs don't\nexpire, but you can define an expiration date/time using the $expiration\nargument of Symfony\\\\Component\\\\HttpFoundation\\\\UriSigner::sign:: // src/Service/SomeService.php\nnamespace App\\Service; use Symfony\\Component\\HttpFoundation\\UriSigner; class SomeService\n{\npublic function __construct(\nprivate UriSigner $uriSigner,\n) {\n} public function someMethod(): void\n{\n// ... // generate a URL yourself or get it somehow...\n$url = 'https://example.com/foo/bar?sort=desc';", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_sem_19", "source": "routing.rst", "text": "// sign the URL with an explicit expiration date\n$signedUrl = $this->uriSigner->sign($url, new \\DateTimeImmutable('2050-01-01'));\n// $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=2524608000&_hash=e4a21b9' // if you pass a \\DateInterval, it will be added from now to get the expiration date\n$signedUrl = $this->uriSigner->sign($url, new \\DateInterval('PT10S')); // valid for 10 seconds from now\n// $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=1712414278&_hash=e4a21b9' // you can also use a timestamp in seconds\n$signedUrl = $this->uriSigner->sign($url, 4070908800); // timestamp for the date 2099-01-01\n// $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=4070908800&_hash=e4a21b9'\n}\n} The expiration date/time is included in the signed URIs as a timestamp via\nthe _expiration query parameter. The feature to add an expiration date for a signed URI was introduced in Symfony 7.1. If you need to know the reason why a signed URI is invalid, you can use the\nverify() method which throws exceptions on failure:: use Symfony\\Component\\HttpFoundation\\Exception\\ExpiredSignedUriException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\UnsignedUriException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\UnverifiedSignedUriException; // ... try {\n$uriSigner->verify($uri); // $uri can be a string or Request object // the URI is valid\n} catch (UnsignedUriException) {\n// the URI isn't signed\n} catch (UnverifiedSignedUriException) {\n// the URI is signed but the signature is invalid\n} catch (ExpiredSignedUriException) {\n// the URI is signed but expired\n} The verify() method was introduced in Symfony 7.3. If symfony/clock is installed, it will be used to create and verify\nexpirations. This allows you to mock the current time in your tests\n. Support for Symfony Clock in UriSigner was\nintroduced in Symfony 7.3. Troubleshooting Here are some common errors you might see while working with routing: Controller \"App\\\\Controller\\\\BlogController::show()\" requires that you\nprovide a value for the \"$slug\" argument. This happens when your controller method has an argument (e.g. $slug):: public function show(string $slug): Response\n{\n// ...\n} But your route path does *not* have a {slug} parameter (e.g. it is\n/blog/show). Add a {slug} to your route path: /blog/show/{slug} or\ngive the argument a default value (i.e. $slug = null). Some mandatory parameters are missing (\"slug\") to generate a URL for route\n\"blog_show\". This means that you're trying to generate a URL to the blog_show route but\nyou are *not* passing a slug value (which is required, because it has a\n{slug} parameter in the route path). To fix this, pass a slug value when\ngenerating the route:: $this->generateUrl('blog_show', ['slug' => 'slug-value']); or, in Twig: {{ path('blog_show', {slug: 'slug-value'}) }} Learn more about Routing :maxdepth: 1\n:glob: routing/*", "title": "Routing", "category": "routing"}
{"chunk_id": "security.rst_sem_0", "source": "security.rst", "text": "Security Symfony provides many tools to secure your application. Some HTTP-related\nsecurity tools, like secure session cookies and\nCSRF protection are provided by default. The\nSecurityBundle, which you will learn about in this guide, provides all\nauthentication and authorization features needed to secure your\napplication. To get started, install the SecurityBundle: $ composer require symfony/security-bundle If you have Symfony Flex installed, this also\ncreates a security.yaml configuration file for you: # config/packages/security.yaml\nsecurity:\n# https://symfony.com/doc/current/security.html#registering-the-user-hashing-passwords\npassword_hashers:\nSymfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface: 'auto'\n# https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers\nproviders:\nusers_in_memory: { memory: null }\nfirewalls:\ndev:\npattern: ^/(_(profiler|wdt)|css|images|js)/\nsecurity: false\nmain:\nlazy: true\nprovider: users_in_memory # activate different ways to authenticate\n# https://symfony.com/doc/current/security.html#firewalls-authentication # https://symfony.com/doc/current/security/impersonating_user.html\n# switch_user: true # An easy way to control access for large sections of your site\n# Note: Only the *first* access control that matches will be used\naccess_control:\n# - { path: ^/admin, roles: ROLE_ADMIN }\n# - { path: ^/profile, roles: ROLE_USER } That's a lot of config! In the next sections, the three main elements are\ndiscussed: `The User`_ (providers)\nAny secured section of your application needs some concept of\na user. The user provider loads users from any storage (e.g. the\ndatabase) based on a \"user identifier\" (e.g. the user's email address); `The Firewall`_ & `Authenticating Users`_ (firewalls)\nThe firewall is the core of securing your application. Every request\nwithin the firewall is checked if it needs an authenticated user. The\nfirewall also takes care of authenticating this user (e.g. using a\nlogin form); `Access Control (Authorization)`_ (access_control)\nUsing access control and the authorization checker, you control the\nrequired permissions to perform a specific action or visit a specific\nURL. The User Permissions in Symfony are always linked to a user object. If you need to\nsecure (parts of) your application, you need to create a user class. This\nis a class that implements Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\UserInterface.\nThis is often a Doctrine entity, but you can also use a dedicated\nSecurity user class. The easiest way to generate a user class is using the make:user command\nfrom the `MakerBundle`_: $ php bin/console make:user\nThe name of the security user class (e.g. User) [User]:\n> User Do you want to store user data in the database (via Doctrine)? (yes/no) [yes]:\n> yes Enter a property name that will be the unique \"display\" name for the user (e.g. email, username, uuid) [email]:\n> email Will this app need to hash/check user passwords? Choose No if passwords are not needed or will be checked/hashed by some other system (e.g. a single sign-on server). Does this app need to hash/check user passwords? (yes/no) [yes]:\n> yes created: src/Entity/User.php\ncreated: src/Repository/UserRepository.php\nupdated: src/Entity/User.php\nupdated: config/packages/security.yaml // src/Entity/User.php\nnamespace App\\Entity; use App\\Repository\\UserRepository;\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface; #[ORM\\Entity(repositoryClass: UserRepository::class)]\nclass User implements UserInterface, PasswordAuthenticatedUserInterface\n{\n#[ORM\\Id]\n#[ORM\\GeneratedValue]\n#[ORM\\Column(type: 'integer')]\nprivate int $id; #[ORM\\Column(type: 'string', length: 180, unique: true)]\nprivate ?string $email; #[ORM\\Column(type: 'json')]\nprivate array $roles = []; #[ORM\\Column(type: 'string')]\nprivate string $password; public function getId(): ?int\n{\nreturn $this->id;\n}", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_1", "source": "security.rst", "text": "public function getEmail(): ?string\n{\nreturn $this->email;\n} public function setEmail(string $email): self\n{\n$this->email = $email; return $this;\n} /**\n* The public representation of the user (e.g. a username, an email address, etc.)\n*\n* @see UserInterface\n*/\npublic function getUserIdentifier(): string\n{\nreturn (string) $this->email;\n} /**\n* @see UserInterface\n*/\npublic function getRoles(): array\n{\n$roles = $this->roles;\n// guarantee every user at least has ROLE_USER\n$roles[] = 'ROLE_USER'; return array_unique($roles);\n} public function setRoles(array $roles): self\n{\n$this->roles = $roles; return $this;\n} /**\n* @see PasswordAuthenticatedUserInterface\n*/\npublic function getPassword(): string\n{\nreturn $this->password;\n} public function setPassword(string $password): self\n{\n$this->password = $password; return $this;\n} // [...]\n} Starting in `MakerBundle`_: v1.57.0 - You can pass either --with-uuid or\n--with-ulid to make:user. Leveraging Symfony's Uid Component ,\nthis generates a User entity with the id type as Uuid\nor Ulid instead of int. If your user is a Doctrine entity, like in the example above, don't forget\nto create the tables by creating and running a migration : $ php bin/console make:migration\n$ php bin/console doctrine:migrations:migrate Starting in `MakerBundle`_: v1.56.0 - Passing --formatted to make:migration\ngenerates a nice and tidy migration file. Loading the User: The User Provider Besides creating the entity, the make:user command also adds config\nfor a user provider in your security configuration: # config/packages/security.yaml\nsecurity:\n# ... providers:\napp_user_provider:\nentity:\nclass: App\\Entity\\User\nproperty: email <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... --> <provider name=\"app_user_provider\">\n<entity class=\"App\\Entity\\User\" property=\"email\"/>\n</provider>\n</config>\n</srv:container> // config/packages/security.php\nuse App\\Entity\\User;\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ... $security->provider('app_user_provider')\n->entity()\n->class(User::class)\n->property('email')\n;\n}; This user provider knows how to (re)load users from a storage (e.g. a database)\nbased on a \"user identifier\" (e.g. the user's email address or username).\nThe configuration above uses Doctrine to load the User entity using the\nemail property as \"user identifier\". User providers are used in a couple places during the security lifecycle: **Load the User based on an identifier**\nDuring login (or any other authenticator), the provider loads the user\nbased on the user identifier. Some other features, like\nuser impersonation and\nRemember Me also use this. **Reload the User from the session**\nAt the beginning of each request, the user is loaded from the\nsession (unless your firewall is stateless). The provider\n\"refreshes\" the user (e.g. the database is queried again for fresh\ndata) to make sure all user information is up to date (and if\nnecessary, the user is de-authenticated/logged out if something\nchanged). See user_session_refresh for more information about\nthis process. Symfony comes with several built-in user providers:", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_2", "source": "security.rst", "text": "Entity User Provider\nLoads users from a database using Doctrine ;\nLDAP User Provider\nLoads users from a LDAP server;\nMemory User Provider\nLoads users from a configuration file;\nChain User Provider\nMerges two or more user providers into a new user provider.\nSince each firewall has exactly *one* user provider, you can use this\nto chain multiple providers together. The built-in user providers cover the most common needs for applications, but you\ncan also create your own custom user provider . Sometimes, you need to inject the user provider in another class (e.g.\nin your custom authenticator). All user providers follow this pattern\nfor their service ID: security.user.provider.concrete.<your-provider-name>\n(where <your-provider-name> is the configuration key, e.g.\napp_user_provider). If you only have one user provider, you can autowire\nit using the Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\UserProviderInterface\ntype-hint. Registering the User: Hashing Passwords Many applications require a user to log in with a password. For these\napplications, the SecurityBundle provides password hashing and verification\nfunctionality. First, make sure your User class implements the\nSymfony\\\\Component\\\\Security\\\\Core\\\\User\\\\PasswordAuthenticatedUserInterface:: // src/Entity/User.php // ...\nuse Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface; class User implements UserInterface, PasswordAuthenticatedUserInterface\n{\n// ... /**\n* @return string the hashed password for this user\n*/\npublic function getPassword(): string\n{\nreturn $this->password;\n}\n} Then, configure which password hasher should be used for this class. If your\nsecurity.yaml file wasn't already pre-configured, then make:user should\nhave done this for you: # config/packages/security.yaml\nsecurity:\n# ...\npassword_hashers:\n# Use native password hasher, which auto-selects and migrates the best\n# possible hashing algorithm (which currently is \"bcrypt\")\nSymfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface: 'auto' <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... -->\n<!-- Use native password hasher, which auto-selects and migrates the best\npossible hashing algorithm (currently this is \"bcrypt\") -->\n<password-hasher class=\"Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface\" algorithm=\"auto\"/>\n</config>\n</srv:container> // config/packages/security.php\nuse App\\Entity\\User;\nuse Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface; return static function (SecurityConfig $security): void {\n// ... // Use native password hasher, which auto-selects and migrates the best\n// possible hashing algorithm (currently this is \"bcrypt\")\n$security->passwordHasher(PasswordAuthenticatedUserInterface::class)\n->algorithm('auto')\n;\n}; Now that Symfony knows *how* you want to hash the passwords, you can use the\nUserPasswordHasherInterface service to do this before saving your users to\nthe database:: // src/Controller/RegistrationController.php\nnamespace App\\Controller; // ...\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\PasswordHasher\\Hasher\\UserPasswordHasherInterface; class RegistrationController extends AbstractController\n{\npublic function index(UserPasswordHasherInterface $passwordHasher): Response\n{\n// ... e.g. get the user data from a registration form\n$user = new User(...);\n$plaintextPassword = ...; // hash the password (based on the security.yaml config for the $user class)\n$hashedPassword = $passwordHasher->hashPassword(\n$user,\n$plaintextPassword\n);\n$user->setPassword($hashedPassword); // ...\n}\n} If your user class is a Doctrine entity and you hash user passwords, the\nDoctrine repository class related to the user class must implement the\nSymfony\\\\Component\\\\Security\\\\Core\\\\User\\\\PasswordUpgraderInterface. The make:registration-form maker command can help you set-up the\nregistration controller and add features like email address\nverification using the `SymfonyCastsVerifyEmailBundle`_. $ composer require symfonycasts/verify-email-bundle\n$ php bin/console make:registration-form You can also manually hash a password by running: $ php bin/console security:hash-password", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_3", "source": "security.rst", "text": "Read more about all available hashers and password migration in\n/security/passwords. The Firewall The firewalls section of config/packages/security.yaml is the *most*\nimportant section. A \"firewall\" is your authentication system: the firewall\ndefines which parts of your application are secured and *how* your users\nwill be able to authenticate (e.g. login form, API token, etc). # config/packages/security.yaml\nsecurity:\n# ...\nfirewalls:\n# the order in which firewalls are defined is very important, as the\n# request will be handled by the first firewall whose pattern matches\ndev:\npattern: ^/(_(profiler|wdt)|css|images|js)/\nsecurity: false\n# a firewall with no pattern should be defined last because it will match all requests\nmain:\nlazy: true\n# provider that you set earlier inside providers\nprovider: app_user_provider # activate different ways to authenticate\n# https://symfony.com/doc/current/security.html#firewalls-authentication # https://symfony.com/doc/current/security/impersonating_user.html\n# switch_user: true <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... --> <!-- the order in which firewalls are defined is very important, as the\nrequest will be handled by the first firewall whose pattern matches -->\n<firewall name=\"dev\"\npattern=\"^/(_(profiler|wdt)|css|images|js)/\"\nsecurity=\"false\"/> <!-- a firewall with no pattern should be defined last because it will match all requests -->\n<firewall name=\"main\"\nlazy=\"true\"/> <!-- activate different ways to authenticate\nhttps://symfony.com/doc/current/security.html#firewalls-authentication --> <!-- https://symfony.com/doc/current/security/impersonating_user.html -->\n<!-- <switch-user/> -->\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ... // the order in which firewalls are defined is very important, as the\n// request will be handled by the first firewall whose pattern matches\n$security->firewall('dev')\n->pattern('^/(_(profiler|wdt)|css|images|js)/')\n->security(false)\n; // a firewall with no pattern should be defined last because it will match all requests\n$security->firewall('main')\n->lazy(true) // activate different ways to authenticate\n// https://symfony.com/doc/current/security.html#firewalls-authentication // https://symfony.com/doc/current/security/impersonating_user.html\n// ->switchUser(true)\n;\n}; Only one firewall is active on each request: Symfony uses the pattern key\nto find the first match (you can also\nmatch by host or other things ).\nHere, all real URLs are handled by the main firewall (no pattern key means\nit matches *all* URLs). The dev firewall is really a fake firewall: it makes sure that you\ndon't accidentally block Symfony's dev tools - which live under URLs like\n/_profiler and /_wdt. When matching several routes, instead of creating a long regex you can also\nuse an array of simpler regexes to match each route: # config/packages/security.yaml\nsecurity:\n# ...\nfirewalls:\ndev:\npattern:\n- ^/_profiler/\n- ^/_wdt/\n- ^/css/\n- ^/images/\n- ^/js/\n# ... // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ...\n$security->firewall('dev')\n->pattern([\n'^/_profiler/',\n'^/_wdt/',\n'^/css/',\n'^/images/',\n'^/js/',\n])\n->security(false)\n; // ...\n}; This feature is not supported by the XML configuration format.", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_4", "source": "security.rst", "text": "A firewall can have many modes of authentication, in other words, it enables many\nways to ask the question \"Who are you?\". Often, the user is unknown (i.e. not logged in)\nwhen they first visit your website. If you visit your homepage right now, you *will*\nhave access and you'll see that you're visiting a page behind the firewall in the toolbar: :alt: The Symfony profiler toolbar where the Security information shows \"Authenticated: no\" and \"Firewall name: main\" Visiting a URL under a firewall doesn't necessarily require you to be authenticated\n(e.g. the login form has to be accessible or some parts of your application\nare public). On the other hand, all pages that you want to be *aware* of a logged in\nuser have to be under the same firewall. So if you want to display a *\"You are logged in\nas ...\"* message on every page, they all have to be included in the same firewall. You'll learn how to restrict access to URLs, controllers or\nanything else within your firewall in the access control\nsection. The lazy anonymous mode prevents the session from being started if\nthere is no need for authorization (i.e. explicit check for a user\nprivilege). This is important to keep requests cacheable (see\n/http_cache). If you do not see the toolbar, install the profiler\nwith: $ composer require --dev symfony/profiler-pack Fetching the Firewall Configuration for a Request If you need to get the configuration of the firewall that matched a given request,\nuse the Symfony\\\\Bundle\\\\SecurityBundle\\\\Security service:: // src/Service/ExampleService.php\n// ... use Symfony\\Bundle\\SecurityBundle\\Security;\nuse Symfony\\Component\\HttpFoundation\\RequestStack; class ExampleService\n{\npublic function __construct(\n// Avoid calling getFirewallConfig() in the constructor: auth may not\n// be complete yet. Instead, store the entire Security object.\nprivate Security $security,\nprivate RequestStack $requestStack,\n) {\n} public function someMethod(): void\n{\n$request = $this->requestStack->getCurrentRequest();\n$firewallName = $this->security->getFirewallConfig($request)?->getName(); // ...\n}\n} Authenticating Users During authentication, the system tries to find a matching user for the\nvisitor of the webpage. Traditionally, this was done using a login form or\na HTTP basic dialog in the browser. However, the SecurityBundle comes with\nmany other authenticators: * `Form Login`_\n* `JSON Login`_\n* `HTTP Basic`_\n* `Login Link`_\n* `X.509 Client Certificates`_\n* `Remote users`_\n* Custom Authenticators If your application logs users in via a third-party service such as\nGoogle, Facebook or Twitter (social login), check out the `HWIOAuthBundle`_\ncommunity bundle or `Oauth2-client`_ package. Form Login Most websites have a login form where users authenticate using an\nidentifier (e.g. email address or username) and a password. This\nfunctionality is provided by the built-in Symfony\\\\Component\\\\Security\\\\Http\\\\Authenticator\\\\FormLoginAuthenticator. You can run the following command to create everything needed to add a login\nform in your application: $ php bin/console make:security:form-login This command will create the required controller and template and it will also\nupdate the security configuration. Alternatively, if you prefer to make these\nchanges manually, follow the next steps. First, create a controller for the login form: $ php bin/console make:controller Login", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_5", "source": "security.rst", "text": "created: src/Controller/LoginController.php\ncreated: templates/login/index.html.twig // src/Controller/LoginController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class LoginController extends AbstractController\n{\n#[Route('/login', name: 'app_login')]\npublic function index(): Response\n{\nreturn $this->render('login/index.html.twig', [\n'controller_name' => 'LoginController',\n]);\n}\n} Then, enable the FormLoginAuthenticator using the form_login setting: # config/packages/security.yaml\nsecurity:\n# ... firewalls:\nmain:\n# ...\nform_login:\n# \"app_login\" is the name of the route created previously\nlogin_path: app_login\ncheck_path: app_login <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... -->\n<firewall name=\"main\">\n<!-- \"app_login\" is the name of the route created previously -->\n<form-login login-path=\"app_login\" check-path=\"app_login\"/>\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ... $mainFirewall = $security->firewall('main'); // \"app_login\" is the name of the route created previously\n$mainFirewall->formLogin()\n->loginPath('app_login')\n->checkPath('app_login')\n;\n}; The login_path and check_path support URLs and route names (but\ncannot have mandatory wildcards - e.g. /login/{foo} where foo\nhas no default value). Once enabled, the security system redirects unauthenticated visitors to the\nlogin_path when they try to access a secured place (this behavior can\nbe customized using authentication entry points ). Edit the login controller to render the login form: // ...\n+ use Symfony\\Component\\Security\\Http\\Authentication\\AuthenticationUtils; class LoginController extends AbstractController\n{\n#[Route('/login', name: 'app_login')]\n- public function index(): Response\n+ public function index(AuthenticationUtils $authenticationUtils): Response\n{\n+ // get the login error if there is one\n+ $error = $authenticationUtils->getLastAuthenticationError();\n+\n+ // last username entered by the user\n+ $lastUsername = $authenticationUtils->getLastUsername();\n+\nreturn $this->render('login/index.html.twig', [\n- 'controller_name' => 'LoginController',\n+ 'last_username' => $lastUsername,\n+ 'error' => $error,\n]);\n}\n} Don't let this controller confuse you. Its job is only to *render* the form.\nThe FormLoginAuthenticator will handle the form *submission* automatically.\nIf the user submits an invalid email or password, that authenticator will store\nthe error and redirect back to this controller, where we read the error (using\nAuthenticationUtils) so that it can be displayed back to the user. Finally, create or update the template: {# templates/login/index.html.twig #}\n{% extends 'base.html.twig' %} {# ... #} {% block body %}\n{% if error %}\n<div>{{ error.messageKey|trans(error.messageData, 'security') }}</div>\n{% endif %} <form action=\"{{ path('app_login') }}\" method=\"post\">\n<label for=\"username\">Email:</label>\n<input type=\"text\" id=\"username\" name=\"_username\" value=\"{{ last_username }}\" required> <label for=\"password\">Password:</label>\n<input type=\"password\" id=\"password\" name=\"_password\" required> {# If you want to control the URL the user is redirected to on success\n<input type=\"hidden\" name=\"_target_path\" value=\"/account\"> #} <button type=\"submit\">login</button>\n</form>\n{% endblock %} The error variable passed into the template is an instance\nof Symfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AuthenticationException.\nIt may contain sensitive information about the authentication failure.\n*Never* use error.message: use the messageKey property instead,\nas shown in the example. This message is always safe to display. The form can look like anything, but it usually follows some conventions:", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_6", "source": "security.rst", "text": "* The <form> element sends a POST request to the app_login route, since\nthat's what you configured as the check_path under the form_login key in\nsecurity.yaml;\n* The username (or whatever your user's \"identifier\" is, like an email) field has\nthe name _username and the password field has the name _password. Actually, all of this can be configured under the form_login key. See\nreference-security-firewall-form-login for more details. This login form is currently not protected against CSRF attacks. Read\nform_login-csrf on how to protect your login form. And that's it! When you submit the form, the security system automatically\nreads the _username and _password POST parameter, loads the user via\nthe user provider, checks the user's credentials and either authenticates the\nuser or sends them back to the login form where the error can be displayed. To review the whole process: #. The user tries to access a resource that is protected (e.g. /admin);\n#. The firewall initiates the authentication process by redirecting the\nuser to the login form (/login);\n#. The /login page renders login form via the route and controller created\nin this example;\n#. The user submits the login form to /login;\n#. The security system (i.e. the FormLoginAuthenticator) intercepts the\nrequest, checks the user's submitted credentials, authenticates the user if\nthey are correct, and sends the user back to the login form if they are not. You can customize the responses on a successful or failed login\nattempt. See /security/form_login. CSRF Protection in Login Forms\n.............................. `Login CSRF attacks`_ can be prevented using the same technique of adding hidden\nCSRF tokens into the login forms. The Security component already provides CSRF\nprotection, but you need to configure some options before using it. First, you need to enable CSRF on the form login: # config/packages/security.yaml\nsecurity:\n# ... firewalls:\nsecured_area:\n# ...\nform_login:\n# ...\nenable_csrf: true <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... --> <firewall name=\"secured_area\">\n<!-- ... -->\n<form-login enable-csrf=\"true\"/>\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ... $mainFirewall = $security->firewall('main');\n$mainFirewall->formLogin()\n// ...\n->enableCsrf(true)\n;\n}; Then, use the csrf_token() function in the Twig template to generate a CSRF\ntoken and store it as a hidden field of the form. By default, the HTML field\nmust be called _csrf_token and the string used to generate the value must\nbe authenticate: {# templates/login/index.html.twig #} {# ... #}\n<form action=\"{{ path('app_login') }}\" method=\"post\">\n{# ... the login fields #} <input type=\"hidden\" name=\"_csrf_token\" data-controller=\"csrf-protection\" value=\"{{ csrf_token('authenticate') }}\"> <button type=\"submit\">login</button>\n</form> After this, you have protected your login form against CSRF attacks. You can change the name of the field by setting csrf_parameter and change\nthe token ID by setting csrf_token_id in your configuration. See\nreference-security-firewall-form-login for more details. JSON Login", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_7", "source": "security.rst", "text": "Some applications provide an API that is secured using tokens. These\napplications may use an endpoint that provides these tokens based on a\nusername (or email) and password. The JSON login authenticator helps you create\nthis functionality. Enable the authenticator using the json_login setting: # config/packages/security.yaml\nsecurity:\n# ... firewalls:\nmain:\n# ...\njson_login:\n# api_login is a route we will create below\ncheck_path: api_login <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... -->\n<firewall name=\"main\">\n<json-login check-path=\"api_login\"/>\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ... $mainFirewall = $security->firewall('main');\n$mainFirewall->jsonLogin()\n->checkPath('api_login')\n;\n}; The check_path supports URLs and route names (but cannot have\nmandatory wildcards - e.g. /login/{foo} where foo has no\ndefault value). The authenticator runs when a client requests the check_path. First,\ncreate a controller for this path: $ php bin/console make:controller --no-template ApiLogin created: src/Controller/ApiLoginController.php // src/Controller/ApiLoginController.php\nnamespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class ApiLoginController extends AbstractController\n{\n#[Route('/api/login', name: 'api_login')]\npublic function index(): Response\n{\nreturn $this->json([\n'message' => 'Welcome to your new controller!',\n'path' => 'src/Controller/ApiLoginController.php',\n]);\n}\n} This login controller will be called after the authenticator successfully\nauthenticates the user. You can get the authenticated user, generate a\ntoken (or whatever you need to return) and return the JSON response: // ...\n+ use App\\Entity\\User;\n+ use Symfony\\Component\\Security\\Http\\Attribute\\CurrentUser; class ApiLoginController extends AbstractController\n{\n- #[Route('/api/login', name: 'api_login')]\n+ #[Route('/api/login', name: 'api_login', methods: ['POST'])]\n- public function index(): Response\n+ public function index(#[CurrentUser] ?User $user): Response\n{\n+ if (null === $user) {\n+ return $this->json([\n+ 'message' => 'missing credentials',\n+ ], Response::HTTP_UNAUTHORIZED);\n+ }\n+\n+ $token = ...; // somehow create an API token for $user\n+\nreturn $this->json([\n- 'message' => 'Welcome to your new controller!',\n- 'path' => 'src/Controller/ApiLoginController.php',\n+ 'user' => $user->getUserIdentifier(),\n+ 'token' => $token,\n]);\n}\n} The #[CurrentUser] can only be used in controller arguments to\nretrieve the authenticated user. In services, you would use\nSymfony\\\\Bundle\\\\SecurityBundle\\\\Security::getUser. That's it! To summarize the process: #. A client (e.g. the front-end) makes a *POST request* with the\nContent-Type: application/json header to /api/login with\nusername (even if your identifier is actually an email) and\npassword keys: {\n\"username\": \"dunglas@example.com\",\n\"password\": \"MyPassword\"\n}\n#. The security system intercepts the request, checks the user's submitted\ncredentials and authenticates the user. If the credentials are incorrect,\nan HTTP 401 Unauthorized JSON response is returned, otherwise your\ncontroller is run;\n#. Your controller creates the correct response: {\n\"user\": \"dunglas@example.com\",\n\"token\": \"45be42...\"\n} The JSON request format can be configured under the json_login key.\nSee reference-security-firewall-json-login for more details. HTTP Basic `HTTP Basic authentication`_ is a standardized HTTP authentication\nframework. It asks credentials (username and password) using a dialog in\nthe browser and the HTTP basic authenticator of Symfony will verify these\ncredentials. Add the http_basic key to your firewall to enable HTTP Basic\nauthentication: # config/packages/security.yaml\nsecurity:\n# ...", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_8", "source": "security.rst", "text": "firewalls:\nmain:\n# ...\nhttp_basic:\nrealm: Secured Area <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... -->\n<firewall name=\"main\">\n<http-basic realm=\"Secured Area\"/>\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n$mainFirewall = $security->firewall('main');\n$mainFirewall->httpBasic()\n->realm('Secured Area')\n;\n}; That's it! Whenever an unauthenticated user tries to visit a protected\npage, Symfony will inform the browser that it needs to start HTTP basic\nauthentication (using the WWW-Authenticate response header). Then, the\nauthenticator verifies the credentials and authenticates the user. You cannot use log out with the HTTP\nbasic authenticator. Even if you log out from Symfony, your browser\n\"remembers\" your credentials and will send them on every request. Login Link Login links are a passwordless authentication mechanism. The user will\nreceive a short-lived link (e.g. via email) which will authenticate them to the\nwebsite. You can learn all about this authenticator in /security/login_link. Access Tokens Access Tokens are often used in API contexts.\nThe user receives a token from an authorization server\nwhich authenticates them. You can learn all about this authenticator in /security/access_token. X.509 Client Certificates When using client certificates, your web server does all the authentication\nitself. The X.509 authenticator provided by Symfony extracts the email from\nthe \"distinguished name\" (DN) of the client certificate. Then, it uses this\nemail as user identifier in the user provider. First, configure your web server to enable client certificate verification\nand to expose the certificate's DN to the Symfony application: server {\n# ... ssl_client_certificate /path/to/my-custom-CA.pem; # enable client certificate verification\nssl_verify_client optional;\nssl_verify_depth 1; location / {\n# pass the DN as \"SSL_CLIENT_S_DN\" to the application\nfastcgi_param SSL_CLIENT_S_DN $ssl_client_s_dn; # ...\n}\n} # ...\nSSLCACertificateFile \"/path/to/my-custom-CA.pem\"\nSSLVerifyClient optional\nSSLVerifyDepth 1 # pass the DN to the application\nSSLOptions +StdEnvVars tls {\nclient_auth {\nmode verify_if_given # check the Caddy documentation for more information\ntrusted_ca_cert_file /path/to/my-custom-CA.pem\n}\n} route {\n# Other configuration options go here php_fastcgi unix//var/run/php/php-fpm.sock {\nenv SSL_CLIENT_S_DN {tls_client_subject} # Environment variables for other certificate fields that you might need.\n# They are not used by Symfony, but you can use them in your application.\n# See all placeholders: https://caddyserver.com/docs/caddyfile/concepts#placeholders\nenv SSL_CLIENT_S_FINGERPRINT {tls_client_fingerprint}\nenv SSL_CLIENT_S_CERTIFICATE {tls_client_certificate_der_base64}\nenv SSL_CLIENT_S_ISSUER {tls_client_issuer}\nenv SSL_CLIENT_S_SERIAL {tls_client_serial}\nenv SSL_CLIENT_S_VERSION {tls_version}\n}\n} Then, enable the X.509 authenticator using x509 on your firewall: # config/packages/security.yaml\nsecurity:\n# ... firewalls:\nmain:\n# ...\nx509:\nprovider: your_user_provider <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... --> <firewall name=\"main\">\n<!-- ... -->\n<x509 provider=\"your_user_provider\"/>\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n$mainFirewall = $security->firewall('main');\n$mainFirewall->x509()\n->provider('your_user_provider')\n;\n}; By default, Symfony extracts the email address from the DN in two different\nways: #. First, it tries the SSL_CLIENT_S_DN_Email server parameter, which is\nexposed by Apache;\n#. If it is not set (e.g. when using Nginx), it uses SSL_CLIENT_S_DN and\nmatches the value following emailAddress.", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_9", "source": "security.rst", "text": "You can customize the name of some parameters under the x509 key.\nSee the x509 configuration reference\nfor more details. Remote Users Besides client certificate authentication, there are more web server\nmodules that pre-authenticate a user (e.g. kerberos). The remote user\nauthenticator provides a basic integration for these services. These modules often expose the authenticated user in the REMOTE_USER\nenvironment variable. The remote user authenticator uses this value as the\nuser identifier to load the corresponding user. Enable remote user authentication using the remote_user key: # config/packages/security.yaml\nsecurity:\nfirewalls:\nmain:\n# ...\nremote_user:\nprovider: your_user_provider <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<firewall name=\"main\">\n<remote-user provider=\"your_user_provider\"/>\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n$mainFirewall = $security->firewall('main');\n$mainFirewall->remoteUser()\n->provider('your_user_provider')\n;\n}; You can customize the name of this server variable under the\nremote_user key. See\nthe configuration reference\nfor more details. Limiting Login Attempts Symfony provides basic protection against `brute force login attacks`_ thanks to\nthe Rate Limiter component . If you haven't used this\ncomponent in your application yet, install it before using this feature: $ composer require symfony/rate-limiter Then, enable this feature using the login_throttling setting: # config/packages/security.yaml\nsecurity: firewalls:\n# ... main:\n# ... # by default, the feature allows 5 login attempts per minute\nlogin_throttling: null # configure the maximum login attempts\nlogin_throttling:\nmax_attempts: 3 # per minute ...\n# interval: '15 minutes' # ... or in a custom period # use a custom rate limiter via its service ID\nlogin_throttling:\nlimiter: app.my_login_rate_limiter <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <!-- you must use the authenticator manager -->\n<config enable-authenticator-manager=\"true\">\n<!-- ... --> <firewall name=\"main\">\n<!-- by default, the feature allows 5 login attempts per minute\nmax-attempts: (optional) You can configure the maximum attempts ...\ninterval: (optional) ... and the period of time. -->\n<login-throttling max-attempts=\"3\" interval=\"15 minutes\"/> <!-- use a custom rate limiter via its service ID -->\n<login-throttling limiter=\"app.my_login_rate_limiter\"/>\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n$security->enableAuthenticatorManager(true); $mainFirewall = $security->firewall('main'); // by default, the feature allows 5 login attempts per minute\n$mainFirewall->loginThrottling()\n// ->maxAttempts(3) // Optional: You can configure the maximum attempts ...\n// ->interval('15 minutes') // ... and the period of time.\n;\n}; The value of the interval option must be a number followed by any of the\nunits accepted by the `PHP date relative formats`_ (e.g. 3 seconds,\n10 hours, 1 day, etc.) Internally, Symfony uses the Rate Limiter component\nwhich by default uses Symfony's cache to store the previous login attempts.\nHowever, you can implement a custom storage . Login attempts are limited on max_attempts (default: 5)\nfailed requests for IP address + username and 5 * max_attempts\nfailed requests for IP address. The second limit protects against an\nattacker using multiple usernames from bypassing the first limit, without\ndisrupting normal users on big networks (such as offices).", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_10", "source": "security.rst", "text": "Limiting the failed login attempts is only one basic protection against\nbrute force attacks. The `OWASP Brute Force Attacks`_ guidelines mention\nseveral other protections that you should consider depending on the\nlevel of protection required. If you need a more complex limiting algorithm, create a class that implements\nSymfony\\\\Component\\\\HttpFoundation\\\\RateLimiter\\\\RequestRateLimiterInterface\n(or use\nSymfony\\\\Component\\\\Security\\\\Http\\\\RateLimiter\\\\DefaultLoginRateLimiter)\nand set the limiter option to its service ID: # config/packages/security.yaml\nframework:\nrate_limiter:\n# define 2 rate limiters (one for username+IP, the other for IP)\nusername_ip_login:\npolicy: token_bucket\nlimit: 5\nrate: { interval: '5 minutes' } ip_login:\npolicy: sliding_window\nlimit: 50\ninterval: '15 minutes' services:\n# our custom login rate limiter\napp.login_rate_limiter:\nclass: Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter\narguments:\n# globalFactory is the limiter for IP\n$globalFactory: '@limiter.ip_login'\n# localFactory is the limiter for username+IP\n$localFactory: '@limiter.username_ip_login'\n$secret: '%kernel.secret%' security:\nfirewalls:\nmain:\n# use a custom rate limiter via its service ID\nlogin_throttling:\nlimiter: app.login_rate_limiter <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <framework:config>\n<framework:rate-limiter>\n<!-- define 2 rate limiters (one for username+IP, the other for IP) -->\n<framework:limiter name=\"username_ip_login\"\npolicy=\"token_bucket\"\nlimit=\"5\"\n>\n<framework:rate interval=\"5 minutes\"/>\n</framework:limiter> <framework:limiter name=\"ip_login\"\npolicy=\"sliding_window\"\nlimit=\"50\"\ninterval=\"15 minutes\"\n/>\n</framework:rate-limiter>\n</framework:config> <srv:services>\n<!-- our custom login rate limiter -->\n<srv:service id=\"app.login_rate_limiter\"\nclass=\"Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter\"\n>\n<!-- 1st argument is the limiter for IP -->\n<srv:argument type=\"service\" id=\"limiter.ip_login\"/>\n<!-- 2nd argument is the limiter for username+IP -->\n<srv:argument type=\"service\" id=\"limiter.username_ip_login\"/>\n<!-- 3rd argument is the app secret -->\n<srv:argument type=\"string\">%kernel.secret%</srv:argument>\n</srv:service>\n</srv:services> <config>\n<firewall name=\"main\">\n<!-- use a custom rate limiter via its service ID -->\n<login-throttling limiter=\"app.login_rate_limiter\"/>\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\DependencyInjection\\Reference;\nuse Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter;\nuse Symfony\\Config\\FrameworkConfig;\nuse Symfony\\Config\\SecurityConfig; return static function (ContainerBuilder $container, FrameworkConfig $framework, SecurityConfig $security): void {\n$framework->rateLimiter()\n->limiter('username_ip_login')\n->policy('token_bucket')\n->limit(5)\n->rate()\n->interval('5 minutes')\n; $framework->rateLimiter()\n->limiter('ip_login')\n->policy('sliding_window')\n->limit(50)\n->interval('15 minutes')\n; $container->register('app.login_rate_limiter', DefaultLoginRateLimiter::class)\n->setArguments([\n// 1st argument is the limiter for IP\nnew Reference('limiter.ip_login'),\n// 2nd argument is the limiter for username+IP\nnew Reference('limiter.username_ip_login'),\n// 3rd argument is the app secret\nparam('kernel.secret'),\n]); $security->firewall('main')\n->loginThrottling()\n->limiter('app.login_rate_limiter')\n;\n}; Customize Successful and Failed Authentication Behavior If you want to customize how the successful or failed authentication process is\nhandled, you don't have to overwrite the respective listeners globally. Instead,\nyou can set custom success failure handlers by implementing the\nSymfony\\\\Component\\\\Security\\\\Http\\\\Authentication\\\\AuthenticationSuccessHandlerInterface\nor the\nSymfony\\\\Component\\\\Security\\\\Http\\\\Authentication\\\\AuthenticationFailureHandlerInterface. Read how to customize your success handler\nfor more information about this. Login Programmatically You can log in a user programmatically using the login() method of the\nSymfony\\\\Bundle\\\\SecurityBundle\\\\Security helper:: // src/Controller/SecurityController.php\nnamespace App\\Controller; use App\\Security\\Authenticator\\ExampleAuthenticator;\nuse Symfony\\Bundle\\SecurityBundle\\Security;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\RememberMeBadge; class SecurityController\n{\npublic function someAction(Security $security): Response\n{\n// get the user to be authenticated\n$user = ...; // log the user in on the current firewall\n$security->login($user); // if the firewall has more than one authenticator, you must pass it explicitly\n// by using the name of built-in authenticators...\n$security->login($user, 'form_login');\n// ...or the service id of custom authenticators\n$security->login($user, ExampleAuthenticator::class); // you can also log in on a different firewall...\n$security->login($user, 'form_login', 'other_firewall');", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_11", "source": "security.rst", "text": "// ... add badges...\n$security->login($user, 'form_login', 'other_firewall', [(new RememberMeBadge())->enable()]); // ... and also add passport attributes\n$security->login($user, 'form_login', 'other_firewall', [(new RememberMeBadge())->enable()], ['referer' => 'https://oauth.example.com']); // use the redirection logic applied to regular login\n$redirectResponse = $security->login($user);\nreturn $redirectResponse; // or use a custom redirection logic (e.g. redirect users to their account page)\n// return new RedirectResponse('...');\n}\n} The support for passport attributes in the\nSymfony\\\\Bundle\\\\SecurityBundle\\\\Security::login method was\nintroduced in Symfony 7.2. Logging Out To enable logging out, activate the logout config parameter under your firewall: # config/packages/security.yaml\nsecurity:\n# ... firewalls:\nmain:\n# ...\nlogout:\npath: /logout # where to redirect after logout\n# target: app_any_route <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... --> <firewall name=\"main\">\n<logout path=\"/logout\"/> <!-- use \"target\" to configure where to redirect after logout\n<logout path=\"/logout\" target=\"app_any_route\"/>\n-->\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ... $mainFirewall = $security->firewall('main');\n// ...\n$mainFirewall->logout()\n->path('/logout') // where to redirect after logout\n// ->target('app_any_route')\n;\n}; Symfony will then un-authenticate users navigating to the configured path,\nand redirect them to the configured target. If you need to reference the logout path, you can use the _logout_<firewallname>\nroute name (e.g. _logout_main). If your project does not use Symfony Flex , make sure\nyou have imported the logout route loader in your routes: # config/routes/security.yaml\n_symfony_logout:\nresource: security.route_loader.logout\ntype: service <!-- config/routes/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"security.route_loader.logout\" type=\"service\"/>\n</routes> // config/routes/security.php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void {\n$routes->import('security.route_loader.logout', 'service');\n}; Logout programmatically You can logout user programmatically using the logout() method of the\nSymfony\\\\Bundle\\\\SecurityBundle\\\\Security helper:: // src/Controller/SecurityController.php\nnamespace App\\Controller; use Symfony\\Bundle\\SecurityBundle\\Security; class SecurityController\n{\npublic function someAction(Security $security): Response\n{\n// logout the user in on the current firewall\n$response = $security->logout(); // you can also disable the csrf logout\n$response = $security->logout(false); // ... return $response (if set) or e.g. redirect to the homepage\n}\n} The user will be logged out from the firewall of the request. If the request is\nnot behind a firewall a \\LogicException will be thrown. Customizing Logout In some cases you need to run extra logic upon logout (e.g. invalidate\nsome tokens) or want to customize what happens after a logout. During\nlogout, a Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LogoutEvent\nis dispatched. Register an event listener or subscriber\nto execute custom logic:: // src/EventListener/LogoutSubscriber.php\nnamespace App\\EventListener; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\HttpFoundation\\RedirectResponse;\nuse Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\LogoutEvent; class LogoutSubscriber implements EventSubscriberInterface\n{\npublic function __construct(\nprivate UrlGeneratorInterface $urlGenerator\n) {\n} public static function getSubscribedEvents(): array\n{\nreturn [LogoutEvent::class => 'onLogout'];\n} public function onLogout(LogoutEvent $event): void\n{\n// get the security token of the session that is about to be logged out\n$token = $event->getToken(); // get the current request\n$request = $event->getRequest(); // get the current response, if it is already set by another listener\n$response = $event->getResponse();", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_12", "source": "security.rst", "text": "// configure a custom logout response to the homepage\n$response = new RedirectResponse(\n$this->urlGenerator->generate('homepage'),\nRedirectResponse::HTTP_SEE_OTHER\n);\n$event->setResponse($response);\n}\n} Customizing Logout Path Another option is to configure path as a route name. This can be useful\nif you want logout URIs to be dynamic (e.g. translated according to the\ncurrent locale). In that case, you have to create this route yourself: # config/routes.yaml\napp_logout:\npath:\nen: /logout\nfr: /deconnexion\nmethods: GET <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"app_logout\" path=\"/logout\" methods=\"GET\">\n<path locale=\"en\">/logout</path>\n<path locale=\"fr\">/deconnexion</path>\n</route>\n</routes> // config/routes.php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void {\n$routes->add('app_logout', [\n'en' => '/logout',\n'fr' => '/deconnexion',\n])\n->methods(['GET'])\n;\n}; Then, pass the route name to the path option: # config/packages/security.yaml\nsecurity:\n# ... firewalls:\nmain:\n# ...\nlogout:\npath: app_logout <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... --> <firewall name=\"main\">\n<logout path=\"app_logout\"/>\n</firewall>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ... $mainFirewall = $security->firewall('main');\n// ...\n$mainFirewall->logout()\n->path('app_logout')\n;\n}; Fetching the User Object After authentication, the User object of the current user can be\naccessed via the getUser() shortcut in the\nbase controller :: use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response; class ProfileController extends AbstractController\n{\npublic function index(): Response\n{\n// usually you'll want to make sure the user is authenticated first,\n// see \"Authorization\" below\n$this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY'); // returns your User object, or null if the user is not authenticated\n// use inline documentation to tell your editor your exact User class\n/** @var \\App\\Entity\\User $user */\n$user = $this->getUser(); // Call whatever methods you've added to your User class\n// For example, if you added a getFirstName() method, you can use that.\nreturn new Response('Well hi there '.$user->getFirstName());\n}\n} Fetching the User from a Service If you need to get the logged in user from a service, use the\nSymfony\\\\Bundle\\\\SecurityBundle\\\\Security service:: // src/Service/ExampleService.php\n// ... use Symfony\\Bundle\\SecurityBundle\\Security; class ExampleService\n{\n// Avoid calling getUser() in the constructor: auth may not\n// be complete yet. Instead, store the entire Security object.\npublic function __construct(\nprivate Security $security,\n){\n} public function someMethod(): void\n{\n// returns User object or null if not authenticated\n$user = $this->security->getUser(); // ...\n}\n} Fetch the User in a Template In a Twig Template the user object is available via the app.user variable\nthanks to the Twig global app variable : {% if is_granted('IS_AUTHENTICATED_FULLY') %}\n<p>Email: {{ app.user.email }}</p>\n{% endif %} Access Control (Authorization) Users can now log in to your app using your login form. Great! Now, you need to learn\nhow to deny access and work with the User object. This is called **authorization**,\nand its job is to decide if a user can access some resource (a URL, a model object,\na method call, ...). The process of authorization has two different sides:", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_13", "source": "security.rst", "text": "#. The user receives a specific role when logging in (e.g. ROLE_ADMIN).\n#. You add code so that a resource (e.g. URL, controller) requires a specific\n\"attribute\" (e.g. a role like ROLE_ADMIN) in order to be accessed. Roles When a user logs in, Symfony calls the getRoles() method on your User\nobject to determine which roles this user has. In the User class that\nwas generated earlier, the roles are an array that's stored in the\ndatabase and every user is *always* given at least one role: ROLE_USER:: // src/Entity/User.php // ...\nclass User\n{\n#[ORM\\Column(type: 'json')]\nprivate array $roles = []; // ...\npublic function getRoles(): array\n{\n$roles = $this->roles;\n// guarantee every user at least has ROLE_USER\n$roles[] = 'ROLE_USER'; return array_unique($roles);\n}\n} This is a nice default, but you can do *whatever* you want to determine which roles\na user should have. The only rule is that every role **must start with** the\nROLE_ prefix - otherwise, things won't work as expected. Other than that,\na role is just a string and you can invent whatever you need (e.g. ROLE_PRODUCT_ADMIN). You'll use these roles next to grant access to specific sections of your site. Hierarchical Roles\n.................. Instead of giving many roles to each user, you can define role inheritance\nrules by creating a role hierarchy: # config/packages/security.yaml\nsecurity:\n# ... role_hierarchy:\nROLE_ADMIN: ROLE_USER\nROLE_SUPER_ADMIN: [ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH] <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... --> <role id=\"ROLE_ADMIN\">ROLE_USER</role>\n<role id=\"ROLE_SUPER_ADMIN\">ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH</role>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ... $security->roleHierarchy('ROLE_ADMIN', ['ROLE_USER']);\n$security->roleHierarchy('ROLE_SUPER_ADMIN', ['ROLE_ADMIN', 'ROLE_ALLOWED_TO_SWITCH']);\n}; Users with the ROLE_ADMIN role will also have the ROLE_USER role.\nUsers with ROLE_SUPER_ADMIN, will automatically have ROLE_ADMIN,\nROLE_ALLOWED_TO_SWITCH and ROLE_USER (inherited from\nROLE_ADMIN). For role hierarchy to work, do not use $user->getRoles() manually.\nFor example, in a controller extending from the base controller :: // BAD - $user->getRoles() will not know about the role hierarchy\n$hasAccess = in_array('ROLE_ADMIN', $user->getRoles()); // GOOD - use of the normal security methods\n$hasAccess = $this->isGranted('ROLE_ADMIN');\n$this->denyAccessUnlessGranted('ROLE_ADMIN'); The role_hierarchy values are static - you can't, for example, store the\nrole hierarchy in a database. If you need that, create a custom\nsecurity voter that looks for the user roles\nin the database. Add Code to Deny Access There are **two** ways to deny access to something: #. access_control in security.yaml\nallows you to protect URL patterns (e.g. /admin/*). Simpler, but less flexible; #. in your controller (or other code) . Securing URL patterns (access_control)\n...................................... The most basic way to secure part of your app is to secure an entire URL pattern\nin security.yaml. For example, to require ROLE_ADMIN for all URLs that\nstart with /admin, you can: # config/packages/security.yaml\nsecurity:\n# ... firewalls:\n# ...\nmain:\n# ... access_control:\n# require ROLE_ADMIN for /admin*\n- { path: '^/admin', roles: ROLE_ADMIN }", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_14", "source": "security.rst", "text": "# or require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin*\n- { path: '^/admin', roles: [IS_AUTHENTICATED_FULLY, ROLE_ADMIN] } # the 'path' value can be any valid regular expression\n# (this one will match URLs like /api/post/7298 and /api/comment/528491)\n- { path: ^/api/(post|comment)/\\d+$, roles: ROLE_USER } <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... --> <firewall name=\"main\">\n<!-- ... -->\n</firewall> <!-- require ROLE_ADMIN for /admin* -->\n<rule path=\"^/admin\" role=\"ROLE_ADMIN\"/> <!-- require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin* -->\n<rule path=\"^/admin\">\n<role>ROLE_ADMIN</role>\n<role>IS_AUTHENTICATED_FULLY</role>\n</rule> <!-- the 'path' value can be any valid regular expression\n(this one will match URLs like /api/post/7298 and /api/comment/528491) -->\n<rule path=\"^/api/(post|comment)/\\d+$\" role=\"ROLE_USER\"/>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n$security->enableAuthenticatorManager(true); // ...\n$security->firewall('main')\n// ...\n; // require ROLE_ADMIN for /admin*\n$security->accessControl()\n->path('^/admin')\n->roles(['ROLE_ADMIN']); // require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin*\n$security->accessControl()\n->path('^/admin')\n->roles(['ROLE_ADMIN', 'IS_AUTHENTICATED_FULLY']); // the 'path' value can be any valid regular expression\n// (this one will match URLs like /api/post/7298 and /api/comment/528491)\n$security->accessControl()\n->path('^/api/(post|comment)/\\d+$')\n->roles(['ROLE_USER']);\n}; You can define as many URL patterns as you need - each is a regular expression.\n**BUT**, only **one** will be matched per request: Symfony starts at the top of\nthe list and stops when it finds the first match: # config/packages/security.yaml\nsecurity:\n# ... access_control:\n# matches /admin/users/*\n- { path: '^/admin/users', roles: ROLE_SUPER_ADMIN } # matches /admin/* except for anything matching the above rule\n- { path: '^/admin', roles: ROLE_ADMIN } <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config>\n<!-- ... --> <rule path=\"^/admin/users\" role=\"ROLE_SUPER_ADMIN\"/>\n<rule path=\"^/admin\" role=\"ROLE_ADMIN\"/>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n// ... $security->accessControl()\n->path('^/admin/users')\n->roles(['ROLE_SUPER_ADMIN']); $security->accessControl()\n->path('^/admin')\n->roles(['ROLE_ADMIN']);\n}; Prepending the path with ^ means that only URLs *beginning* with the\npattern are matched. For example, a path of /admin (without the ^)\nwould match /admin/foo but would also match URLs like /foo/admin. Each access_control can also match on IP address, hostname and HTTP methods.\nIt can also be used to redirect a user to the https version of a URL pattern.\nFor more complex needs, you can also use a service implementing RequestMatcherInterface. See /security/access_control. Securing Controllers and other Code\n................................... You can deny access from inside a controller:: // src/Controller/AdminController.php\n// ... public function adminDashboard(): Response\n{\n$this->denyAccessUnlessGranted('ROLE_ADMIN'); // or add an optional message - seen by developers\n$this->denyAccessUnlessGranted('ROLE_ADMIN', null, 'User tried to access a page without having ROLE_ADMIN');\n} That's it! If access is not granted, a special\nSymfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AccessDeniedException\nis thrown and no more code in your controller is called. Then, one of two things\nwill happen: 1) If the user isn't logged in yet, they will be asked to log in (e.g. redirected\nto the login page). 2) If the user *is* logged in, but does *not* have the ROLE_ADMIN role, they'll\nbe shown the 403 access denied page (which you can\ncustomize ).", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_15", "source": "security.rst", "text": "Another way to secure one or more controller actions is to use the #[IsGranted] attribute.\nIn the following example, all controller actions will require the\nROLE_ADMIN permission, except for adminDashboard(), which will require\nthe ROLE_SUPER_ADMIN permission: // src/Controller/AdminController.php\n// ... use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted; #[IsGranted('ROLE_ADMIN')]\nclass AdminController extends AbstractController\n{\n// Optionally, you can set a custom message that will be displayed to the user\n#[IsGranted('ROLE_SUPER_ADMIN', message: 'You are not allowed to access the admin dashboard.')]\npublic function adminDashboard(): Response\n{\n// ...\n}\n} If you want to use a custom status code instead of the default one (which\nis 403), this can be done by setting with the statusCode argument:: // src/Controller/AdminController.php\n// ... use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted; #[IsGranted('ROLE_ADMIN', statusCode: 423)]\nclass AdminController extends AbstractController\n{\n// ...\n} You can also set the internal exception code of the\nSymfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AccessDeniedException\nthat is thrown with the exceptionCode argument:: // src/Controller/AdminController.php\n// ... use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted; #[IsGranted('ROLE_ADMIN', statusCode: 403, exceptionCode: 10010)]\nclass AdminController extends AbstractController\n{\n// ...\n} Access Control in Templates\n........................... If you want to check if the current user has a certain role, you can use\nthe built-in is_granted() helper function in any Twig template: {% if is_granted('ROLE_ADMIN') %}\n<a href=\"...\">Delete</a>\n{% endif %} Similarly, if you want to check if a specific user has a certain role, you can use\nthe built-in is_granted_for_user() helper function: {% if is_granted_for_user(user, 'ROLE_ADMIN') %}\n<a href=\"...\">Delete</a>\n{% endif %} Securing other Services\n....................... You can check access *anywhere* in your code by injecting the Security\nservice. For example, suppose you have a SalesReportManager service and you\nwant to include extra details only for users that have a ROLE_SALES_ADMIN role: // src/SalesReport/SalesReportManager.php // ...\nuse Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException;\n+ use Symfony\\Bundle\\SecurityBundle\\Security; class SalesReportManager\n{\n+ public function __construct(\n+ private Security $security,\n+ ) {\n+ } public function generateReport(): void\n{\n$salesData = []; + if ($this->security->isGranted('ROLE_SALES_ADMIN')) {\n+ $salesData['top_secret_numbers'] = rand();\n+ } // ...\n} // ...\n} The isGranted() method checks authorization for the currently logged-in user.\nIf you need to check authorization for a different user or when the user session\nis unavailable (e.g., in a CLI context such as a message queue or cron job), you\ncan use the isGrantedForUser() method to explicitly set the target user. The Symfony\\\\Bundle\\\\SecurityBundle\\\\Security::isGrantedForUser\nmethod was introduced in Symfony 7.3. If you're using the default services.yaml configuration ,\nSymfony will automatically pass the security.helper to your service\nthanks to autowiring and the Security type-hint. You can also use a lower-level\nSymfony\\\\Component\\\\Security\\\\Core\\\\Authorization\\\\AuthorizationCheckerInterface\nservice. It does the same thing as Security, but allows you to type-hint a\nmore-specific interface. Allowing Unsecured Access (i.e. Anonymous Users) When a visitor isn't yet logged in to your website, they are treated as\n\"unauthenticated\" and don't have any roles. This will block them from\nvisiting your pages if you defined an access_control rule. In the access_control configuration, you can use the PUBLIC_ACCESS\nsecurity attribute to exclude some routes for unauthenticated access (e.g.\nthe login page): # config/packages/security.yaml\nsecurity:", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_16", "source": "security.rst", "text": "# ...\naccess_control:\n# allow unauthenticated users to access the login form\n- { path: ^/admin/login, roles: PUBLIC_ACCESS } # but require authentication for all other admin routes\n- { path: ^/admin, roles: ROLE_ADMIN } <!-- config/packages/security.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<srv:container xmlns=\"http://symfony.com/schema/dic/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:srv=\"http://symfony.com/schema/dic/services\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/security\nhttps://symfony.com/schema/dic/security/security-1.0.xsd\"> <config enable-authenticator-manager=\"true\">\n<!-- ... --> <access-control>\n<!-- allow unauthenticated users to access the login form -->\n<rule path=\"^/admin/login\" role=\"PUBLIC_ACCESS\"/> <!-- but require authentication for all other admin routes -->\n<rule path=\"^/admin\" role=\"ROLE_ADMIN\"/>\n</access-control>\n</config>\n</srv:container> // config/packages/security.php\nuse Symfony\\Component\\Security\\Core\\Authorization\\Voter\\AuthenticatedVoter;\nuse Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void {\n$security->enableAuthenticatorManager(true);\n// .... // allow unauthenticated users to access the login form\n$security->accessControl()\n->path('^/admin/login')\n->roles([AuthenticatedVoter::PUBLIC_ACCESS])\n; // but require authentication for all other admin routes\n$security->accessControl()\n->path('^/admin')\n->roles(['ROLE_ADMIN'])\n;\n}; Granting Anonymous Users Access in a Custom Voter If you're using a custom voter , you can allow\nanonymous users access by checking if there is no user set on the token:: // src/Security/PostVoter.php\nnamespace App\\Security; // ...\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\User\\UserInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\Voter\\Vote;\nuse Symfony\\Component\\Security\\Core\\Authorization\\Voter\\Voter; class PostVoter extends Voter\n{\n// ... protected function voteOnAttribute(string $attribute, $subject, TokenInterface $token, ?Vote $vote = null): bool\n{\n// ... if (!$token->getUser() instanceof UserInterface) {\n// the user is not authenticated, e.g. only allow them to\n// see public posts\nreturn $subject->isPublic();\n}\n}\n} The $vote argument of the voteOnAttribute() method was introduced\nin Symfony 7.3. Setting Individual User Permissions Most applications require more specific access rules. For instance, a user\nshould be able to only edit their *own* comments on a blog. Voters allow you\nto write *whatever* business logic you need to determine access. Using\nthese voters is similar to the role-based access checks implemented in the\nprevious chapters. Read /security/voters to learn how to implement\nyour own voter. Checking to see if a User is Logged In If you *only* want to check if a user is logged in (you don't care about roles),\nyou have the following two options. Firstly, if you've given *every* user ROLE_USER, you can check for that role. Secondly, you can use the special \"attribute\" IS_AUTHENTICATED in place of a role:: // ... public function adminDashboard(): Response\n{\n$this->denyAccessUnlessGranted('IS_AUTHENTICATED'); // ...\n} You can use IS_AUTHENTICATED anywhere roles are used: like\naccess_control or in Twig. IS_AUTHENTICATED isn't a role, but it kind of acts like one, and every\nuser that has logged in will have this. Actually, there are some special attributes\nlike this: * IS_AUTHENTICATED_FULLY: This is similar to IS_AUTHENTICATED_REMEMBERED,\nbut stronger. Users who are logged in only because of a \"remember me cookie\"\nwill have IS_AUTHENTICATED_REMEMBERED but will not have IS_AUTHENTICATED_FULLY. * IS_REMEMBERED: *Only* users authenticated using the\nremember me functionality , (i.e. a\nremember-me cookie). * IS_IMPERSONATOR: When the current user is\nimpersonating another user in this\nsession, this attribute will match. Understanding how Users are Refreshed from the Session", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_17", "source": "security.rst", "text": "At the end of every request (unless your firewall is stateless), your\nUser object is serialized to the session. At the beginning of the next\nrequest, it's deserialized and then passed to your user provider to \"refresh\" it\n(e.g. Doctrine queries for a fresh user). Then, the two User objects (the original from the session and the refreshed User\nobject) are \"compared\" to see if they are \"equal\". By default, the core\nAbstractToken class compares the return values of the getPassword(),\ngetSalt() and getUserIdentifier() methods. If any of these are different,\nyour user will be logged out. This is a security measure to make sure that malicious\nusers can be de-authenticated if core user data changes. Storing the (plain or hashed) password in the session can be a security risk.\nTo mitigate this, implement the __serialize() magic method in your user class\nto exclude or transform the password before storing the serialized user object\nin the session. Two strategies are supported: #. Remove the password completely. After unserialization, getPassword() returns\nnull and Symfony refreshes the user without checking the password. Use this\nonly if you store plaintext passwords (not recommended).\n#. Hash the password using the crc32c algorithm. Symfony will hash the password\nof the refreshed user and compare it to the session value. This approach avoids\nstoring the real hash and lets you invalidate sessions on password change. Example (assuming the password is stored in a private property called password):: public function __serialize(): array\n{\n$data = (array) $this;\n$data[\"\\0\".self::class.\"\\0password\"] = hash('crc32c', $this->password); return $data;\n} Support for hashing passwords with crc32c in session serialization was\nintroduced in Symfony 7.3. If you're having problems authenticating, it could be that you *are* authenticating\nsuccessfully, but you immediately lose authentication after the first redirect. In that case, review the serialization logic (e.g. the __serialize() or\nserialize() methods) on your user class (if you have any) to make sure\nthat all the fields necessary are serialized and also exclude all the\nfields not necessary to be serialized (e.g. Doctrine relations). Comparing Users Manually with EquatableInterface Or, if you need more control over the \"compare users\" process, make your User class\nimplement Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\EquatableInterface.\nThen, your isEqualTo() method will be called when comparing users instead\nof the core logic. Security Events During the authentication process, multiple events are dispatched that allow you\nto hook into the process or customize the response sent back to the user. You\ncan do this by creating an event listener or subscriber\nfor these events. Every Security firewall has its own event dispatcher\n(security.event_dispatcher.FIREWALLNAME). Events are dispatched on\nboth the global and the firewall-specific dispatcher. You can register\non the firewall dispatcher if you want your listener to only be\ncalled for a specific firewall. For instance, if you have an api\nand main firewall, use this configuration to register only on the\nlogout event in the main firewall: # config/services.yaml\nservices:\n# ... App\\EventListener\\LogoutSubscriber:\ntags:\n- name: kernel.event_subscriber\ndispatcher: security.event_dispatcher.main", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_18", "source": "security.rst", "text": "<!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... --> <service id=\"App\\EventListener\\LogoutSubscriber\">\n<tag name=\"kernel.event_subscriber\"\ndispatcher=\"security.event_dispatcher.main\"\n/>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\EventListener\\LogoutSubscriber; return function(ContainerConfigurator $container): void {\n$services = $container->services(); $services->set(LogoutSubscriber::class)\n->tag('kernel.event_subscriber', [\n'dispatcher' => 'security.event_dispatcher.main',\n]);\n}; Authentication Events <object data=\"_images/security/security_events.svg\" type=\"image/svg+xml\"\nalt=\"A flow diagram showing the authentication events that are described in this section in a request-response cycle.\"\n></object> Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\CheckPassportEvent\nDispatched after the authenticator created the security passport .\nListeners of this event do the actual authentication checks (like\nchecking the passport, validating the CSRF token, etc.) Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\AuthenticationTokenCreatedEvent\nDispatched after the passport was validated and the authenticator\ncreated the security token (and user). This can be used in advanced use-cases\nwhere you need to modify the created token (e.g. for multi factor\nauthentication). Symfony\\\\Component\\\\Security\\\\Core\\\\Event\\\\AuthenticationSuccessEvent\nDispatched when authentication is nearing success. This is the last\nevent that can make an authentication fail by throwing an\nAuthenticationException. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LoginSuccessEvent\nDispatched after authentication was fully successful. Listeners to this\nevent can modify the response sent back to the user. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LoginFailureEvent\nDispatched after an AuthenticationException was thrown during\nauthentication. Listeners to this event can modify the error response\nsent back to the user. Other Events Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\InteractiveLoginEvent\nDispatched after authentication was fully successful only when the authenticator\nimplements Symfony\\\\Component\\\\Security\\\\Http\\\\Authenticator\\\\InteractiveAuthenticatorInterface,\nwhich indicates login requires explicit user action (e.g. a login form).\nListeners to this event can modify the response sent back to the user. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LogoutEvent\nDispatched just before a user logs out of your application. See\nsecurity-logging-out. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\TokenDeauthenticatedEvent\nDispatched when a user is deauthenticated, for instance because the\npassword was changed. See user_session_refresh. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\SwitchUserEvent\nDispatched after impersonation is completed. See\n/security/impersonating_user. Frequently Asked Questions **Can I have Multiple Firewalls?**\nYes! However, each firewall is like a separate security system: being authenticated\nin one firewall doesn't make you authenticated in another one. Each firewall can have\nmultiple ways of allowing authentication (e.g. form login, and API key authentication).\nIf you want to share authentication between firewalls, you have to explicitly\nspecify the same reference-security-firewall-context for different firewalls. **Security doesn't seem to work on my Error Pages**\nAs routing is done *before* security, 404 error pages are not covered by\nany firewall. This means you can't check for security or even access the\nuser object on these pages. See /controller/error_pages\nfor more details. **My Authentication Doesn't Seem to Work: No Errors, but I'm Never Logged In**\nSometimes authentication may be successful, but after redirecting, you're\nlogged out immediately due to a problem loading the User from the session.\nTo see if this is an issue, check your log file (var/log/dev.log) for\nthe log message. **Cannot refresh token because user has changed**\nIf you see this, there are two possible causes. First, there may be a problem\nloading your User from the session. See user_session_refresh. Second,\nif certain user information was changed in the database since the last page\nrefresh, Symfony will purposely log out the user for security reasons. Learn More Authentication (Identifying/Logging in the User) :maxdepth: 1", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_sem_19", "source": "security.rst", "text": "security/passwords\nsecurity/ldap\nsecurity/remember_me\nsecurity/impersonating_user\nsecurity/user_checkers\nsecurity/firewall_restriction\nsecurity/csrf\nsecurity/form_login\nsecurity/custom_authenticator\nsecurity/entry_point Authorization (Denying Access) :maxdepth: 1 security/voters\nsecurity/access_control\nsecurity/expressions\nsecurity/access_denied_handler\nsecurity/force_https", "title": "Security", "category": "security"}
{"chunk_id": "serializer.rst_sem_0", "source": "serializer.rst", "text": "How to Use the Serializer Symfony provides a serializer to transform data structures from one format\nto PHP objects and the other way around. This is most commonly used when building an API or communicating with third\nparty APIs. The serializer can transform an incoming JSON request payload\nto a PHP object that is consumed by your application. Then, when generating\nthe response, you can use the serializer to transform the PHP objects back\nto a JSON response. It can also be used to, for instance, load CSV configuration data as PHP\nobjects, or even to transform between formats (e.g. YAML to XML). Installation In applications using Symfony Flex , run this command to\ninstall the serializer Symfony pack before using it: $ composer require symfony/serializer-pack The serializer pack also installs some commonly used optional\ndependencies of the Serializer component. When using this component\noutside the Symfony framework, you might want to start with the\nsymfony/serializer package and install optional dependencies if you\nneed them. A popular alternative to the Symfony Serializer component is the third-party\nlibrary, `JMS serializer`_. Serializing an Object For this example, assume the following class exists in your project:: // src/Model/Person.php\nnamespace App\\Model; class Person\n{\npublic function __construct(\nprivate int $age,\nprivate string $name,\nprivate bool $sportsperson\n) {\n} public function getAge(): int\n{\nreturn $this->age;\n} public function getName(): string\n{\nreturn $this->name;\n} public function isSportsperson(): bool\n{\nreturn $this->sportsperson;\n}\n} If you want to transform objects of this type into a JSON structure (e.g.\nto send them via an API response), get the serializer service by using\nthe Symfony\\\\Component\\\\Serializer\\\\SerializerInterface parameter type: // src/Controller/PersonController.php\nnamespace App\\Controller; use App\\Model\\Person;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Serializer\\SerializerInterface; class PersonController extends AbstractController\n{\npublic function index(SerializerInterface $serializer): Response\n{\n$person = new Person('Jane Doe', 39, false); $jsonContent = $serializer->serialize($person, 'json');\n// $jsonContent contains {\"name\":\"Jane Doe\",\"age\":39,\"sportsperson\":false} return JsonResponse::fromJsonString($jsonContent);\n}\n} use App\\Model\\Person;\nuse Symfony\\Component\\Serializer\\Encoder\\JsonEncoder;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Serializer; $encoders = [new JsonEncoder()];\n$normalizers = [new ObjectNormalizer()];\n$serializer = new Serializer($normalizers, $encoders); $person = new Person('Jane Done', 39, false); $jsonContent = $serializer->serialize($person, 'json');\n// $jsonContent contains {\"name\":\"Jane Doe\",\"age\":39,\"sportsperson\":false} The first parameter of the Symfony\\\\Component\\\\Serializer\\\\Serializer::serialize\nis the object to be serialized and the second is used to choose the proper\nencoder (i.e. format), in this case the Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\JsonEncoder. When your controller class extends AbstractController (like in the\nexample above), you can simplify your controller by using the\nSymfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::json\nmethod to create a JSON response from an object using the Serializer:: class PersonController extends AbstractController\n{\npublic function index(): Response\n{\n$person = new Person('Jane Doe', 39, false); // when the Serializer is not available, this will use json_encode()\nreturn $this->json($person);\n}\n} Using the Serializer in Twig Templates You can also serialize objects in any Twig template using the serialize\nfilter: {{ person|serialize(format = 'json') }} See the twig reference for more\ninformation. Deserializing an Object", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_1", "source": "serializer.rst", "text": "APIs often also need to convert a formatted request body (e.g. JSON) to a\nPHP object. This process is called *deserialization* (also known as \"hydration\"): // src/Controller/PersonController.php\nnamespace App\\Controller; // ...\nuse Symfony\\Component\\HttpFoundation\\Exception\\BadRequestException;\nuse Symfony\\Component\\HttpFoundation\\Request; class PersonController extends AbstractController\n{\n// ... public function create(Request $request, SerializerInterface $serializer): Response\n{\nif ('json' !== $request->getContentTypeFormat()) {\nthrow new BadRequestException('Unsupported content format');\n} $jsonData = $request->getContent();\n$person = $serializer->deserialize($jsonData, Person::class, 'json'); // ... do something with $person and return a response\n}\n} use App\\Model\\Person;\nuse Symfony\\Component\\Serializer\\Encoder\\JsonEncoder;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Serializer; // ...\n$jsonData = ...; // fetch JSON from the request\n$person = $serializer->deserialize($jsonData, Person::class, 'json'); In this case, Symfony\\\\Component\\\\Serializer\\\\Serializer::deserialize\nneeds three parameters: #. The data to be decoded\n#. The name of the class this information will be decoded to\n#. The name of the encoder used to convert the data to an array (i.e. the\ninput format) When sending a request to this controller (e.g.\n{\"first_name\":\"John Doe\",\"age\":54,\"sportsperson\":true}), the serializer\nwill create a new instance of Person and sets the properties to the\nvalues from the given JSON. By default, additional attributes that are not mapped to the\ndenormalized object will be ignored by the Serializer component. For\ninstance, if a request to the above controller contains {..., \"city\": \"Paris\"},\nthe city field will be ignored. You can also throw an exception in\nthese cases using the serializer context\nyou'll learn about later. You can also deserialize data into an existing object instance (e.g.\nwhen updating data). See Deserializing in an Existing Object . The Serialization Process: Normalizers and Encoders The serializer uses a two-step process when (de)serializing objects: <object data=\"_images/serializer/serializer_workflow.svg\" type=\"image/svg+xml\"\nalt=\"A flow diagram showing how objects are serialized/deserialized. This is described in the subsequent paragraph.\"\n></object> In both directions, data is always first converted to an array. This splits\nthe process in two separate responsibilities: Normalizers\nThese classes convert **objects** into **arrays** and vice versa. They\ndo the heavy lifting of finding out which class properties to\nserialize, what value they hold and what name they should have.\nEncoders\nEncoders convert **arrays** into a specific **format** and the other\nway around. Each encoder knows exactly how to parse and generate a\nspecific format, for instance JSON or XML. Internally, the Serializer class uses a sorted list of normalizers and\none encoder for the specific format when (de)serializing an object. There are several normalizers configured in the default serializer\nservice. The most important normalizer is the\nSymfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ObjectNormalizer. This\nnormalizer uses reflection and the PropertyAccess component\nto transform between any object and an array. You'll learn more about\nthis and other normalizers later. The default serializer is also configured with some encoders, covering the\ncommon formats used by HTTP applications: * Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\JsonEncoder\n* Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\XmlEncoder\n* Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\CsvEncoder\n* Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\YamlEncoder Read more about these encoders and their configuration in\n/serializer/encoders. The `API Platform`_ project provides encoders for more advanced\nformats: * `JSON-LD`_ along with the `Hydra Core Vocabulary`_\n* `OpenAPI`_ v2 (formerly Swagger) and v3\n* `GraphQL`_\n* `JSON:API`_\n* `HAL`_", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_2", "source": "serializer.rst", "text": "Serializer Context The serializer, and its normalizers and encoders, are configured through\nthe *serializer context*. This context can be configured in multiple\nplaces: * Globally through the framework configuration\n* While serializing/deserializing\n* For a specific property You can use all three options at the same time. When the same setting is\nconfigured in multiple places, the latter in the list above will override\nthe previous one (e.g. the setting on a specific property overrides the one\nconfigured globally). Configure a Default Context\n........................... You can configure a default context in the framework configuration, for\ninstance to disallow extra fields while deserializing: # config/packages/serializer.yaml\nframework:\nserializer:\ndefault_context:\nallow_extra_attributes: false <!-- config/packages/serializer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:serializer>\n<framework:default-context>\n<framework:allow-extra-attributes>false</framework:allow-extra-attributes>\n</framework:default-context>\n</framework:serializer>\n</framework:config>\n</container> // config/packages/serializer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->serializer()\n->defaultContext([\n'allow_extra_attributes' => false,\n])\n;\n}; use Symfony\\Component\\Serializer\\NameConverter\\CamelCaseToSnakeCaseNameConverter;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; // ...\n$normalizers = [\nnew ObjectNormalizer(null, null, null, null, null, null, [\n'allow_extra_attributes' => false,\n]),\n];\n$serializer = new Serializer($normalizers, $encoders); Pass Context while Serializing/Deserializing\n............................................ You can also configure the context for a single call to\nserialize()/deserialize(). For instance, you can skip\nproperties with a null value only for one serialize call:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer; // ...\n$serializer->serialize($person, 'json', [\nAbstractObjectNormalizer::SKIP_NULL_VALUES => true\n]); // next calls to serialize() will NOT skip null values Using Context Builders You can use \"context builders\" to help define the (de)serialization\ncontext. Context builders are PHP objects that provide autocompletion,\nvalidation, and documentation of context options:: use Symfony\\Component\\Serializer\\Context\\Normalizer\\DateTimeNormalizerContextBuilder; $contextBuilder = (new DateTimeNormalizerContextBuilder())\n->withFormat('Y-m-d H:i:s');\n$serializer->serialize($something, 'json', $contextBuilder->toArray()); Each normalizer/encoder has its related context builder. To create a more\ncomplex (de)serialization context, you can chain them using the\nwithContext() method:: use Symfony\\Component\\Serializer\\Context\\Encoder\\CsvEncoderContextBuilder;\nuse Symfony\\Component\\Serializer\\Context\\Normalizer\\ObjectNormalizerContextBuilder; $initialContext = [\n'custom_key' => 'custom_value',\n]; $contextBuilder = (new ObjectNormalizerContextBuilder())\n->withContext($initialContext)\n->withGroups(['group1', 'group2']); $contextBuilder = (new CsvEncoderContextBuilder())\n->withContext($contextBuilder)\n->withDelimiter(';'); $serializer->serialize($something, 'csv', $contextBuilder->toArray()); You can also create your context builders\nto have autocompletion, validation, and documentation for your custom\ncontext values. Configure Context on a Specific Property\n........................................ At last, you can also configure context values on a specific object\nproperty. For instance, to configure the datetime format: // src/Model/Person.php // ...\nuse Symfony\\Component\\Serializer\\Attribute\\Context;\nuse Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer; class Person\n{\n#[Context([DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'])]\npublic \\DateTimeImmutable $createdAt; // ...\n} # config/serializer/person.yaml\nApp\\Model\\Person:\nattributes:\ncreatedAt:\ncontexts:\n- context: { datetime_format: 'Y-m-d' } <!-- config/serializer/person.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Model\\Person\">\n<attribute name=\"createdAt\">\n<context>\n<entry name=\"datetime_format\">Y-m-d</entry>\n</context>\n</attribute>\n</class>\n</serializer> When using YAML or XML, the mapping files must be placed in one of\nthese locations: * All *.yaml and *.xml files in the config/serializer/\ndirectory.\n* The serialization.yaml or serialization.xml file in the\nResources/config/ directory of a bundle;\n* All *.yaml and *.xml files in the Resources/config/serialization/\ndirectory of a bundle. You can also specify a context specific to normalization or denormalization: // src/Model/Person.php // ...\nuse Symfony\\Component\\Serializer\\Attribute\\Context;\nuse Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer;", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_3", "source": "serializer.rst", "text": "class Person\n{\n#[Context(\nnormalizationContext: [DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'],\ndenormalizationContext: [DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339],\n)]\npublic \\DateTimeImmutable $createdAt; // ...\n} # config/serializer/person.yaml\nApp\\Model\\Person:\nattributes:\ncreatedAt:\ncontexts:\n- normalization_context: { datetime_format: 'Y-m-d' }\ndenormalization_context: { datetime_format: !php/const \\DateTime::RFC3339 } <!-- config/serializer/person.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Model\\Person\">\n<attribute name=\"createdAt\">\n<normalization-context>\n<entry name=\"datetime_format\">Y-m-d</entry>\n</normalization-context> <denormalization-context>\n<entry name=\"datetime_format\">Y-m-d\\TH:i:sP</entry>\n</denormalization-context>\n</attribute>\n</class>\n</serializer> You can also restrict the usage of a context to some\ngroups : // src/Model/Person.php // ...\nuse Symfony\\Component\\Serializer\\Attribute\\Context;\nuse Symfony\\Component\\Serializer\\Attribute\\Groups;\nuse Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer; class Person\n{\n#[Groups(['extended'])]\n#[Context([DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339])]\n#[Context(\ncontext: [DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339_EXTENDED],\ngroups: ['extended'],\n)]\npublic \\DateTimeImmutable $createdAt; // ...\n} # config/serializer/person.yaml\nApp\\Model\\Person:\nattributes:\ncreatedAt:\ngroups: [extended]\ncontexts:\n- context: { datetime_format: !php/const \\DateTime::RFC3339 }\n- context: { datetime_format: !php/const \\DateTime::RFC3339_EXTENDED }\ngroups: [extended] <!-- config/serializer/person.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Model\\Person\">\n<attribute name=\"createdAt\">\n<group>extended</group> <context>\n<entry name=\"datetime_format\">Y-m-d\\TH:i:sP</entry>\n</context>\n<context>\n<entry name=\"datetime_format\">Y-m-d\\TH:i:s.vP</entry>\n<group>extended</group>\n</context>\n</attribute>\n</class>\n</serializer> The attribute can be repeated as much as needed on a single property.\nContext without group is always applied first. Then context for the\nmatching groups are merged in the provided order. If you repeat the same context in multiple properties, consider using the\n#[Context] attribute on your class to apply that context configuration to\nall the properties of the class:: namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\Context;\nuse Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer; #[Context([DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339])]\n#[Context(\ncontext: [DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339_EXTENDED],\ngroups: ['extended'],\n)]\nclass Person\n{\n// ...\n} Serializing JSON Using Streams Symfony can encode PHP data structures to JSON streams and decode JSON streams\nback into PHP data structures. To do this, it relies on the JsonStreamer component ,\nwhich is designed for high efficiency and can process large JSON data incrementally,\nwithout needing to load the entire content into memory. When deciding between the Serializer component and the JsonStreamer component,\nconsider the following: * **Serializer Component**: Best suited for use cases that require flexibility,\nsuch as dynamically manipulating object structures using normalizers and\ndenormalizers, or handling complex objects with multiple serialization\nformats. It also supports output formats beyond JSON (including your own\ncustom ones).\n* **JsonStreamer Component**: Best suited for simple objects and scenarios that\ndemand high performance and low memory usage. It's particularly effective\nfor processing very large JSON datasets or when streaming JSON in real-time\nwithout loading the entire dataset into memory. The choice depends on your specific use case. The JsonStreamer component is\ntailored for performance and memory efficiency, whereas the Serializer\ncomponent provides greater flexibility and broader format support. Read more about streaming JSON . Serializing to or from PHP Arrays The default Symfony\\\\Component\\\\Serializer\\\\Serializer can also be\nused to only perform one step of the two step serialization process\nby using the respective interface: use Symfony\\Component\\Serializer\\Encoder\\DecoderInterface;\nuse Symfony\\Component\\Serializer\\Encoder\\EncoderInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface;\n// ... class PersonController extends AbstractController\n{\npublic function index(DenormalizerInterface&NormalizerInterface $serializer): Response\n{\n$person = new Person('Jane Doe', 39, false);", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_4", "source": "serializer.rst", "text": "// use normalize() to convert a PHP object to an array\n$personArray = $serializer->normalize($person, 'json'); // ...and denormalize() to convert an array back to a PHP object\n$personCopy = $serializer->denormalize($personArray, Person::class); // ...\n} public function json(DecoderInterface&EncoderInterface $serializer): Response\n{\n$data = ['name' => 'Jane Doe']; // use encode() to transform PHP arrays into another format\n$json = $serializer->encode($data, 'json'); // ...and decode() to transform any format to just PHP arrays (instead of objects)\n$data = $serializer->decode('{\"name\":\"Charlie Doe\"}', 'json');\n// $data contains ['name' => 'Charlie Doe']\n}\n} use App\\Model\\Person;\nuse Symfony\\Component\\Serializer\\Encoder\\JsonEncoder;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Serializer; $encoders = [new JsonEncoder()];\n$normalizers = [new ObjectNormalizer()];\n$serializer = new Serializer($normalizers, $encoders); // use normalize() to convert a PHP object to an array\n$personArray = $serializer->normalize($person, 'json'); // ...and denormalize() to convert an array back to a PHP object\n$personCopy = $serializer->denormalize($personArray, Person::class); $data = ['name' => 'Jane Doe']; // use encode() to transform PHP arrays into another format\n$json = $serializer->encode($data, 'json'); // ...and decode() to transform any format to just PHP arrays (instead of objects)\n$data = $serializer->decode('{\"name\":\"Charlie Doe\"}', 'json');\n// $data contains ['name' => 'Charlie Doe'] Ignoring Properties The ObjectNormalizer normalizes *all* properties of an object and all\nmethods starting with get*(), has*(), is*() and can*().\nSome properties or methods should never be serialized. You can exclude\nthem using the #[Ignore] attribute: // src/Model/Person.php\nnamespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\Ignore; class Person\n{\n// ... #[Ignore]\npublic function isPotentiallySpamUser(): bool\n{\n// ...\n}\n} App\\Model\\Person:\nattributes:\npotentiallySpamUser:\nignore: true <?xml version=\"1.0\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Model\\Person\">\n<attribute name=\"potentiallySpamUser\" ignore=\"true\"/>\n</class>\n</serializer> The potentiallySpamUser property will now never be serialized: use App\\Model\\Person; // ...\n$person = new Person('Jane Doe', 32, false);\n$json = $serializer->serialize($person, 'json');\n// $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false} $person1 = $serializer->deserialize(\n'{\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false\",\"potentiallySpamUser\":false}',\nPerson::class,\n'json'\n);\n// the \"potentiallySpamUser\" value is ignored use App\\Model\\Person;\nuse Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory;\nuse Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Serializer; // ... // you need to pass a class metadata factory with a loader to the\n// ObjectNormalizer when reading mapping information like Ignore or Groups.\n// E.g. when using PHP attributes:\n$classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());\n$normalizers = [new ObjectNormalizer($classMetadataFactory)]; $serializer = new Serializer($normalizers, $encoders); $person = new Person('Jane Doe', 32, false);\n$json = $serializer->serialize($person, 'json');\n// $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false} $person1 = $serializer->deserialize(\n'{\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false\",\"potentiallySpamUser\":false}',\nPerson::class,\n'json'\n);\n// the \"potentiallySpamUser\" value is ignored Ignoring Attributes Using the Context You can also pass an array of attribute names to ignore at runtime using\nthe ignored_attributes context options:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer; // ...\n$person = new Person('Jane Doe', 32, false);\n$json = $serializer->serialize($person, 'json',\n[\nAbstractNormalizer::IGNORED_ATTRIBUTES => ['age'],\n]);\n// $json contains {\"name\":\"Jane Doe\",\"sportsperson\":false} However, this can quickly become unmaintainable if used excessively. See\nthe next section about *serialization groups* for a better solution. Selecting Specific Properties Instead of excluding a property or method in all situations, you might need\nto exclude some properties in one place, but serialize them in another.\nGroups are a handy way to achieve this.", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_5", "source": "serializer.rst", "text": "You can add the #[Groups] attribute to your class: // src/Model/Person.php\nnamespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\Groups; class Person\n{\n#[Groups([\"admin-view\"])]\nprivate int $age; #[Groups([\"public-view\"])]\nprivate string $name; #[Groups([\"public-view\"])]\nprivate bool $sportsperson; // ...\n} # config/serializer/person.yaml\nApp\\Model\\Person:\nattributes:\nage:\ngroups: ['admin-view']\nname:\ngroups: ['public-view']\nsportsperson:\ngroups: ['public-view'] <!-- config/serializer/person.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Model\\Person\">\n<attribute name=\"age\">\n<group>admin-view</group>\n</attribute>\n<attribute name=\"name\">\n<group>public-view</group>\n</attribute>\n<attribute name=\"sportsperson\">\n<group>public-view</group>\n</attribute>\n</class>\n</serializer> You can now choose which groups to use when serializing:: $json = $serializer->serialize(\n$person,\n'json',\n['groups' => 'public-view']\n);\n// $json contains {\"name\":\"Jane Doe\",\"sportsperson\":false} // you can also pass an array of groups\n$json = $serializer->serialize(\n$person,\n'json',\n['groups' => ['public-view', 'admin-view']]\n);\n// $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false} // or use the special \"*\" value to select all groups\n$json = $serializer->serialize(\n$person,\n'json',\n['groups' => '*']\n);\n// $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false} Using the Serialization Context At last, you can also use the attributes context option to select\nproperties at runtime:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer;\n// ... $json = $serializer->serialize($person, 'json', [\nAbstractNormalizer::ATTRIBUTES => ['name', 'company' => ['name']]\n]);\n// $json contains {\"name\":\"Dunglas\",\"company\":{\"name\":\"Les-Tilleuls.coop\"}} Only attributes that are not ignored\nare available. If serialization groups are set, only attributes allowed by\nthose groups can be used. Handling Arrays The serializer is capable of handling arrays of objects. Serializing arrays\nworks just like serializing a single object:: use App\\Model\\Person; // ...\n$person1 = new Person('Jane Doe', 39, false);\n$person2 = new Person('John Smith', 52, true); $persons = [$person1, $person2];\n$jsonContent = $serializer->serialize($persons, 'json'); // $jsonContent contains [{\"name\":\"Jane Doe\",\"age\":39,\"sportsman\":false},{\"name\":\"John Smith\",\"age\":52,\"sportsman\":true}] To deserialize a list of objects, you have to append [] to the type\nparameter:: // ... $jsonData = ...; // the serialized JSON data from the previous example\n$persons = $serializer->deserialize($JsonData, Person::class.'[]', 'json'); For nested classes, you have to add a PHPDoc type to the property, constructor or setter:: // src/Model/UserGroup.php\nnamespace App\\Model; class UserGroup\n{\n/**\n* @param Person[] $members\n*/\npublic function __construct(\nprivate array $members,\n) {\n} // or if you're using a setter /**\n* @param Person[] $members\n*/\npublic function setMembers(array $members): void\n{\n$this->members = $members;\n} // ...\n} The Serializer also supports array types used in static analysis, like\nlist<Person> and array<Person>. Make sure the\nphpstan/phpdoc-parser and phpdocumentor/reflection-docblock\npackages are installed (these are part of the symfony/serializer-pack). Deserializing Nested Structures Some APIs might provide verbose nested structures that you want to flatten\nin the PHP object. For instance, imagine a JSON response like this: {\n\"id\": \"123\",\n\"profile\": {\n\"username\": \"jdoe\",\n\"personal_information\": {\n\"full_name\": \"Jane Doe\"\n}\n}\n} You may wish to serialize this information to a single PHP object like:: class Person\n{\nprivate int $id;\nprivate string $username;\nprivate string $fullName;\n} Use the #[SerializedPath] to specify the path of the nested property\nusing valid PropertyAccess syntax : namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\SerializedPath; class Person\n{\nprivate int $id; #[SerializedPath('[profile][username]')]\nprivate string $username; #[SerializedPath('[profile][personal_information][full_name]')]\nprivate string $fullName;\n} App\\Model\\Person:\nattributes:\nusername:\nserialized_path: '[profile][username]'\nfullName:\nserialized_path: '[profile][personal_information][full_name]'", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_6", "source": "serializer.rst", "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Model\\Person\">\n<attribute name=\"username\" serialized-path=\"[profile][username]\"/>\n<attribute name=\"fullName\" serialized-path=\"[profile][personal_information][full_name]\"/>\n</class>\n</serializer> The SerializedPath cannot be used in combination with a\nSerializedName for the same property. The #[SerializedPath] attribute also applies to the serialization of a\nPHP object:: use App\\Model\\Person;\n// ... $person = new Person(123, 'jdoe', 'Jane Doe');\n$jsonContent = $serializer->serialize($person, 'json');\n// $jsonContent contains {\"id\":123,\"profile\":{\"username\":\"jdoe\",\"personal_information\":{\"full_name\":\"Jane Doe\"}}} Converting Property Names when Serializing and Deserializing Sometimes serialized attributes must be named differently than properties\nor getter/setter methods of PHP classes. This can be achieved using name\nconverters. The serializer service uses the\nSymfony\\\\Component\\\\Serializer\\\\NameConverter\\\\MetadataAwareNameConverter.\nWith this name converter, you can change the name of an attribute using\nthe #[SerializedName] attribute: // src/Model/Person.php\nnamespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\SerializedName; class Person\n{\n#[SerializedName('customer_name')]\nprivate string $name; // ...\n} # config/serializer/person.yaml\nApp\\Entity\\Person:\nattributes:\nname:\nserialized_name: customer_name <!-- config/serializer/person.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Entity\\Person\">\n<attribute name=\"name\" serialized-name=\"customer_name\"/>\n</class>\n</serializer> This custom mapping is used to convert property names when serializing and\ndeserializing objects: // ... $json = $serializer->serialize($person, 'json');\n// $json contains {\"customer_name\":\"Jane Doe\", ...} use App\\Model\\Person;\nuse Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory;\nuse Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader;\nuse Symfony\\Component\\Serializer\\NameConverter\\MetadataAwareNameConverter;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Serializer; // ... // Configure a loader to retrieve mapping information like SerializedName.\n// E.g. when using PHP attributes:\n$classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());\n$nameConverter = new MetadataAwareNameConverter($classMetadataFactory);\n$normalizers = [\nnew ObjectNormalizer($classMetadataFactory, $nameConverter),\n]; $serializer = new Serializer($normalizers, $encoders); $person = new Person('Jane Doe', 32, false);\n$json = $serializer->serialize($person, 'json');\n// $json contains {\"customer_name\":\"Jane Doe\", ...} You can also create a custom name converter class. Read more about this\nin /serializer/custom_name_converter. CamelCase to snake_case In many formats, it's common to use underscores to separate words (also known\nas snake_case). However, in Symfony applications is common to use camelCase to\nname properties. Symfony provides a built-in name converter designed to transform between\nsnake_case and CamelCased styles during serialization and deserialization\nprocesses. You can use it instead of the metadata aware name converter by\nsetting the name_converter setting to\nserializer.name_converter.camel_case_to_snake_case: # config/packages/serializer.yaml\nframework:\nserializer:\nname_converter: 'serializer.name_converter.camel_case_to_snake_case' <!-- config/packages/serializer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:serializer\nname-converter=\"serializer.name_converter.camel_case_to_snake_case\"\n/>\n</framework:config>\n</container> // config/packages/serializer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->serializer()\n->nameConverter('serializer.name_converter.camel_case_to_snake_case')\n;\n}; use Symfony\\Component\\Serializer\\NameConverter\\CamelCaseToSnakeCaseNameConverter;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; // ...\n$normalizers = [\nnew ObjectNormalizer(null, new CamelCaseToSnakeCaseNameConverter()),\n];\n$serializer = new Serializer($normalizers, $encoders); snake_case to CamelCase In Symfony applications, it is common to use camelCase for naming properties.\nHowever some packages may follow a snake_case convention. Symfony provides a built-in name converter designed to transform between\nCamelCase and snake_case styles during serialization and deserialization\nprocesses. You can use it instead of the metadata-aware name converter by\nsetting the name_converter setting to\nserializer.name_converter.snake_case_to_camel_case: # config/packages/serializer.yaml\nframework:\nserializer:\nname_converter: 'serializer.name_converter.snake_case_to_camel_case' <!-- config/packages/serializer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:serializer\nname-converter=\"serializer.name_converter.snake_case_to_camel_case\"\n/>\n</framework:config>\n</container> // config/packages/serializer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->serializer()\n->nameConverter('serializer.name_converter.snake_case_to_camel_case')\n;\n};", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_7", "source": "serializer.rst", "text": "use Symfony\\Component\\Serializer\\NameConverter\\SnakeCaseToCamelCaseNameConverter;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; // ...\n$normalizers = [\nnew ObjectNormalizer(null, new SnakeCaseToCamelCaseNameConverter()),\n];\n$serializer = new Serializer($normalizers, $encoders); The snake_case to CamelCase converter was introduced in Symfony 7.2. Serializer Normalizers By default, the serializer service is configured with the following\nnormalizers (in order of priority): Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\UnwrappingDenormalizer\nCan be used to only denormalize a part of the input, read more about\nthis later in this article . Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ProblemNormalizer\nNormalizes Symfony\\\\Component\\\\ErrorHandler\\\\Exception\\\\FlattenException\nerrors according to the API Problem spec `RFC 7807`_. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\UidNormalizer\nNormalizes objects that extend Symfony\\\\Component\\\\Uid\\\\AbstractUid. The default normalization format for objects that implement Symfony\\\\Component\\\\Uid\\\\Uuid\nis the `RFC 4122`_ format (example: d9e7a184-5d5b-11ea-a62a-3499710062d0).\nThe default normalization format for objects that implement Symfony\\\\Component\\\\Uid\\\\Ulid\nis the Base 32 format (example: 01E439TP9XJZ9RPFH3T1PYBCR8).\nYou can change the string format by setting the serializer context option\nUidNormalizer::NORMALIZATION_FORMAT_KEY to UidNormalizer::NORMALIZATION_FORMAT_BASE58,\nUidNormalizer::NORMALIZATION_FORMAT_BASE32 or UidNormalizer::NORMALIZATION_FORMAT_RFC4122. Also it can denormalize uuid or ulid strings to Symfony\\\\Component\\\\Uid\\\\Uuid\nor Symfony\\\\Component\\\\Uid\\\\Ulid. The format does not matter. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateTimeNormalizer\nThis normalizes between DateTimeInterface objects (e.g.\nDateTime and DateTimeImmutable) and strings,\nintegers or floats. DateTime and DateTimeImmutable) into strings,\nintegers or floats. By default, it converts them to strings using the\n`RFC 3339`_ format. Use DateTimeNormalizer::FORMAT_KEY and\nDateTimeNormalizer::TIMEZONE_KEY to change the format. To convert the objects to integers or floats, set the serializer\ncontext option DateTimeNormalizer::CAST_KEY to int or\nfloat. The DateTimeNormalizer::CAST_KEY context option was introduced in Symfony 7.1. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ConstraintViolationListNormalizer\nThis normalizer converts objects that implement\nSymfony\\\\Component\\\\Validator\\\\ConstraintViolationListInterface\ninto a list of errors according to the `RFC 7807`_ standard. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateTimeZoneNormalizer\nThis normalizer converts between DateTimeZone objects and strings that\nrepresent the name of the timezone according to the `list of PHP timezones`_. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateIntervalNormalizer\nThis normalizes between DateInterval objects and strings.\nBy default, the P%yY%mM%dDT%hH%iM%sS format is used. Use the\nDateIntervalNormalizer::FORMAT_KEY option to change this. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\FormErrorNormalizer\nThis normalizer works with classes that implement\nSymfony\\\\Component\\\\Form\\\\FormInterface. It will get errors from the form and normalize them according to the\nAPI Problem spec `RFC 7807`_. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\TranslatableNormalizer\nThis normalizer converts objects implementing Symfony\\\\Contracts\\\\Translation\\\\TranslatableInterface\nto a translated string using the translator . You can define the locale to use to translate the object by setting the\nTranslatableNormalizer::NORMALIZATION_LOCALE_KEY context option. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\BackedEnumNormalizer\nThis normalizer converts between BackedEnum enums and\nstrings or integers. By default, an exception is thrown when data is not a valid backed enumeration. If you\nwant null instead, you can set the BackedEnumNormalizer::ALLOW_INVALID_VALUES option. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\NumberNormalizer\nThis normalizer converts between BcMath\\\\Number or GMP objects and\nstrings or integers. The NumberNormalizer was introduced in Symfony 7.3. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DataUriNormalizer\nThis normalizer converts between SplFileInfo objects and a\n`data URI`_ string (data:...) such that files can be embedded into\nserialized data. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\JsonSerializableNormalizer\nThis normalizer works with classes that implement JsonSerializable. It will call the JsonSerializable::jsonSerialize method and\nthen further normalize the result. This means that nested\nJsonSerializable classes will also be normalized. This normalizer is particularly helpful when you want to gradually migrate\nfrom an existing codebase using simple json_encode to the Symfony\nSerializer by allowing you to mix which normalizers are used for which classes. Unlike with json_encode circular references can be handled.", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_8", "source": "serializer.rst", "text": "Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ArrayDenormalizer\nThis denormalizer converts an array of arrays to an array of objects\n(with the given type). See Handling Arrays . Use Symfony\\\\Component\\\\PropertyInfo\\\\PropertyInfoExtractor to provide\nhints with annotations like @var Person[]: use Symfony\\Component\\PropertyInfo\\Extractor\\PhpDocExtractor;\nuse Symfony\\Component\\PropertyInfo\\Extractor\\ReflectionExtractor;\nuse Symfony\\Component\\PropertyInfo\\PropertyInfoExtractor;\nuse Symfony\\Component\\Serializer\\Encoder\\JsonEncoder;\nuse Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory;\nuse Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader;\nuse Symfony\\Component\\Serializer\\Normalizer\\ArrayDenormalizer;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Serializer; $propertyInfo = new PropertyInfoExtractor([], [new PhpDocExtractor(), new ReflectionExtractor()]);\n$normalizers = [new ObjectNormalizer(new ClassMetadataFactory(new AttributeLoader()), null, null, $propertyInfo), new ArrayDenormalizer()]; $this->serializer = new Serializer($normalizers, [new JsonEncoder()]); Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ObjectNormalizer\nThis is the most powerful default normalizer and used for any object\nthat could not be normalized by the other normalizers. It leverages the PropertyAccess Component\nto read and write in the object. This allows it to access properties\ndirectly or using getters, setters, hassers, issers, canners, adders and\nremovers. Names are generated by removing the get, set,\nhas, is, add or remove prefix from the method name and\ntransforming the first letter to lowercase (e.g. getFirstName() ->\nfirstName). During denormalization, it supports using the constructor as well as\nthe discovered methods. Always make sure the DateTimeNormalizer is registered when\nserializing the DateTime or DateTimeImmutable classes to avoid\nexcessive memory usage and exposing internal details. Built-in Normalizers Besides the normalizers registered by default (see previous section), the\nserializer component also provides some extra normalizers. You can register\nthese by defining a service and tag it with serializer.normalizer .\nFor instance, to use the CustomNormalizer you have to define a service\nlike: # config/services.yaml\nservices:\n# ... # if you're using autoconfigure, the tag will be automatically applied\nSymfony\\Component\\Serializer\\Normalizer\\CustomNormalizer:\ntags:\n# register the normalizer with a high priority (called earlier)\n- { name: 'serializer.normalizer', priority: 500 } <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... --> <!-- if you're using autoconfigure, the tag will be automatically applied -->\n<service id=\"Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer\">\n<!-- register the normalizer with a high priority (called earlier) -->\n<tag name=\"serializer.normalizer\"\npriority=\"500\"\n/>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer; return function(ContainerConfigurator $container) {\n// ... // if you're using autoconfigure, the tag will be automatically applied\n$services->set(CustomNormalizer::class)\n// register the normalizer with a high priority (called earlier)\n->tag('serializer.normalizer', [\n'priority' => 500,\n])\n;\n}; Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\CustomNormalizer\nThis normalizer calls a method on the PHP object when normalizing. The\nPHP object must implement Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\NormalizableInterface\nand/or Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DenormalizableInterface. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\GetSetMethodNormalizer\nThis normalizer is an alternative to the default ObjectNormalizer.\nIt reads the content of the class by calling the \"getters\" (public\nmethods starting with get, has, is or can). It will\ndenormalize data by calling the constructor and the \"setters\" (public\nmethods starting with set). Objects are normalized to a map of property names and values (names are\ngenerated by removing the get prefix from the method name and transforming\nthe first letter to lowercase; e.g. getFirstName() -> firstName).", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_9", "source": "serializer.rst", "text": "Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\PropertyNormalizer\nThis is yet another alternative to the ObjectNormalizer. This\nnormalizer directly reads and writes public properties as well as\n**private and protected** properties (from both the class and all of\nits parent classes) by using `PHP reflection`_. It supports calling the\nconstructor during the denormalization process. Objects are normalized to a map of property names to property values. You can also limit the normalizer to only use properties with a specific\nvisibility (e.g. only public properties) using the\nPropertyNormalizer::NORMALIZE_VISIBILITY context option. You can set it\nto any combination of the PropertyNormalizer::NORMALIZE_PUBLIC,\nPropertyNormalizer::NORMALIZE_PROTECTED and\nPropertyNormalizer::NORMALIZE_PRIVATE constants:: use Symfony\\Component\\Serializer\\Normalizer\\PropertyNormalizer;\n// ... $json = $serializer->serialize($person, 'json', [\n// only serialize public properties\nPropertyNormalizer::NORMALIZE_VISIBILITY => PropertyNormalizer::NORMALIZE_PUBLIC, // serialize public and protected properties\nPropertyNormalizer::NORMALIZE_VISIBILITY => PropertyNormalizer::NORMALIZE_PUBLIC | PropertyNormalizer::NORMALIZE_PROTECTED,\n]); Named Serializers Named serializers were introduced in Symfony 7.2. Sometimes, you may need multiple configurations for the serializer, such as\ndifferent default contexts, name converters, or sets of normalizers and encoders,\ndepending on the use case. For example, when your application communicates with\nmultiple APIs, each of which follows its own set of serialization rules. You can achieve this by configuring multiple serializer instances using\nthe named_serializers option: # config/packages/serializer.yaml\nframework:\nserializer:\nnamed_serializers:\napi_client1:\nname_converter: 'serializer.name_converter.camel_case_to_snake_case'\ndefault_context:\nenable_max_depth: true\napi_client2:\ndefault_context:\nenable_max_depth: false <!-- config/packages/serializer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:serializer> <framework:named-serializer\nname=\"api_client1\"\nname-converter=\"serializer.name_converter.camel_case_to_snake_case\"\n>\n<framework:default-context>\n<framework:enable_max_depth>true</framework:enable_max_depth>\n</framework:default-context>\n</framework:named-serializer> <framework:named-serializer name=\"api_client2\">\n<framework:default-context>\n<framework:enable_max_depth>false</framework:enable_max_depth>\n</framework:default-context>\n</framework:named-serializer> </framework:serializer>\n</framework:config>\n</container> // config/packages/serializer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->serializer()\n->namedSerializer('api_client1')\n->nameConverter('serializer.name_converter.camel_case_to_snake_case')\n->defaultContext([\n'enable_max_depth' => true,\n])\n;\n$framework->serializer()\n->namedSerializer('api_client2')\n->defaultContext([\n'enable_max_depth' => false,\n])\n;\n}; You can inject these different serializer instances\nusing named aliases :: namespace App\\Controller; // ...\nuse Symfony\\Component\\DependencyInjection\\Attribute\\Target; class PersonController extends AbstractController\n{\npublic function index(\nSerializerInterface $serializer, // default serializer\nSerializerInterface $apiClient1Serializer, // api_client1 serializer\n#[Target('apiClient2.serializer')] // api_client2 serializer\nSerializerInterface $customName,\n) {\n// ...\n}\n} By default, named serializers use the built-in set of normalizers and encoders,\njust like the main serializer service. However, you can customize them by\nregistering additional normalizers or encoders for a specific named serializer.\nTo do that, add a serializer attribute to\nthe serializer.normalizer\nor serializer.encoder tags: # config/services.yaml\nservices:\n# ... Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer:\ntags:\n# add this normalizer only to a specific named serializer\n- serializer.normalizer: { serializer: 'api_client1' }\n# add this normalizer to several named serializers\n- serializer.normalizer: { serializer: [ 'api_client1', 'api_client2' ] }\n# add this normalizer to all serializers, including the default one\n- serializer.normalizer: { serializer: '*' } <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... --> <service id=\"Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer\">\n<!-- add this normalizer only to a specific named serializer -->\n<tag name=\"serializer.normalizer\" serializer=\"api_client1\"/> <!-- add this normalizer to several named serializers -->\n<tag name=\"serializer.normalizer\" serializer=\"api_client1\"/>\n<tag name=\"serializer.normalizer\" serializer=\"api_client2\"/> <!-- add this normalizer to all serializers, including the default one -->\n<tag name=\"serializer.normalizer\" serializer=\"*\"/>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer; return function(ContainerConfigurator $container) {\n// ...", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_10", "source": "serializer.rst", "text": "$services->set(CustomNormalizer::class)\n// add this normalizer only to a specific named serializer\n->tag('serializer.normalizer', ['serializer' => 'api_client1'])\n// add this normalizer to several named serializers\n->tag('serializer.normalizer', ['serializer' => ['api_client1', 'api_client2']])\n// add this normalizer to all serializers, including the default one\n->tag('serializer.normalizer', ['serializer' => '*'])\n;\n}; Before Symfony 7.3, named serializer normalizers were added automatically\nto the default serializer, so you had to set their autoconfigure\noption to false to disable them. As of Symfony 7.3, they are no longer\nregistered by default. When the serializer attribute is not set, the service is registered only with\nthe default serializer. Each normalizer or encoder used in a named serializer is tagged with a\nserializer.normalizer.<name> or serializer.encoder.<name> tag.\nYou can inspect their priorities using the following command: $ php bin/console debug:container --tag serializer.<normalizer|encoder>.<name> Additionally, you can exclude the default set of normalizers and encoders from a\nnamed serializer by setting the include_built_in_normalizers and\ninclude_built_in_encoders options to false: # config/packages/serializer.yaml\nframework:\nserializer:\nnamed_serializers:\napi_client1:\ninclude_built_in_normalizers: false\ninclude_built_in_encoders: true <!-- config/packages/serializer.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:serializer> <framework:named-serializer\nname=\"api_client1\"\ninclude-built-in-normalizers=\"false\"\ninclude-built-in-encoders=\"true\"\n/> </framework:serializer>\n</framework:config>\n</container> // config/packages/serializer.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->serializer()\n->namedSerializer('api_client1')\n->includeBuiltInNormalizers(false)\n->includeBuiltInEncoders(true)\n;\n}; Debugging the Serializer Use the debug:serializer command to dump the serializer metadata of a\ngiven class: $ php bin/console debug:serializer 'App\\Entity\\Book' App\\Entity\\Book | Property | Options |\n| name | [ |\n| | \"groups\" => [ |\n| | \"book:read\", |\n| | \"book:write\", |\n| | ], |\n| | \"maxDepth\" => 1, |\n| | \"serializedName\" => \"book_name\", |\n| | \"serializedPath\" => null, |\n| | \"ignore\" => false, |\n| | \"normalizationContexts\" => [], |\n| | \"denormalizationContexts\" => [] |\n| | ] |\n| isbn | [ |\n| | \"groups\" => [ |\n| | \"book:read\", |\n| | ], |\n| | \"maxDepth\" => null, |\n| | \"serializedName\" => null, |\n| | \"serializedPath\" => \"[data][isbn]\", |\n| | \"ignore\" => false, |\n| | \"normalizationContexts\" => [], |\n| | \"denormalizationContexts\" => [] |\n| | ] | Advanced Serialization Skipping null Values By default, the Serializer will preserve properties containing a null value.\nYou can change this behavior by setting the AbstractObjectNormalizer::SKIP_NULL_VALUES context option\nto true:: class Person\n{\npublic string $name = 'Jane Doe';\npublic ?string $gender = null;\n} $jsonContent = $serializer->serialize(new Person(), 'json', [\nAbstractObjectNormalizer::SKIP_NULL_VALUES => true,\n]);\n// $jsonContent contains {\"name\":\"Jane Doe\"} Preserving Empty Objects By default, the Serializer transforms an empty array to []. You can change\nthis behavior by setting the AbstractObjectNormalizer::PRESERVE_EMPTY_OBJECTS\ncontext option to true. When the value is an instance of \\ArrayObject(),\nthe serialized data will be {}. Handling Uninitialized Properties In PHP, typed properties have an uninitialized state which is different\nfrom the default null of untyped properties. When you try to access a typed\nproperty before giving it an explicit value, you get an error.", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_11", "source": "serializer.rst", "text": "To avoid the serializer throwing an error when serializing or normalizing\nan object with uninitialized properties, by default the ObjectNormalizer\ncatches these errors and ignores such properties. You can disable this behavior by setting the\nAbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES context option to\nfalse:: class Person {\npublic string $name = 'Jane Doe';\npublic string $phoneNumber; // uninitialized\n} $jsonContent = $normalizer->serialize(new Dummy(), 'json', [\nAbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES => false,\n]);\n// throws Symfony\\Component\\PropertyAccess\\Exception\\UninitializedPropertyException\n// as the ObjectNormalizer cannot read uninitialized properties Using Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\PropertyNormalizer\nor Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\GetSetMethodNormalizer\nwith AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES context\noption set to false will throw an \\Error instance if the given\nobject has uninitialized properties as the normalizers cannot read them\n(directly or via getter/isser methods). Handling Circular References Circular references are common when dealing with associated objects:: class Organization\n{\npublic function __construct(\nprivate string $name,\nprivate array $members = []\n) {\n} public function getName(): string\n{\nreturn $this->name;\n} public function addMember(Member $member): void\n{\n$this->members[] = $member;\n} public function getMembers(): array\n{\nreturn $this->members;\n}\n} class Member\n{\nprivate Organization $organization; public function __construct(\nprivate string $name\n) {\n} public function getName(): string\n{\nreturn $this->name;\n} public function setOrganization(Organization $organization): void\n{\n$this->organization = $organization;\n} public function getOrganization(): Organization\n{\nreturn $this->organization;\n}\n} To avoid infinite loops, the normalizers throw a\nSymfony\\\\Component\\\\Serializer\\\\Exception\\\\CircularReferenceException\nwhen such a case is encountered:: $organization = new Organization('Les-Tilleuls.coop');\n$member = new Member('Kévin'); $organization->addMember($member);\n$member->setOrganization($organization); $jsonContent = $serializer->serialize($organization, 'json');\n// throws a CircularReferenceException The key circular_reference_limit in the context sets the number of\ntimes it will serialize the same object before considering it a circular\nreference. The default value is 1. Instead of throwing an exception, circular references can also be handled\nby custom callables. This is especially useful when serializing entities\nhaving unique identifiers:: use Symfony\\Component\\Serializer\\Exception\\CircularReferenceException; $context = [\nAbstractNormalizer::CIRCULAR_REFERENCE_HANDLER => function (object $object, ?string $format, array $context): string {\nif (!$object instanceof Organization) {\nthrow new CircularReferenceException('A circular reference has been detected when serializing the object of class \"'.get_debug_type($object).'\".');\n} // serialize the nested Organization with only the name (and not the members)\nreturn $object->getName();\n},\n]; $jsonContent = $serializer->serialize($organization, 'json', $context);\n// $jsonContent contains {\"name\":\"Les-Tilleuls.coop\",\"members\":[{\"name\":\"K\\u00e9vin\", organization: \"Les-Tilleuls.coop\"}]} Handling Serialization Depth The serializer can also detect nested objects of the same class and limit\nthe serialization depth. This is useful for tree structures, where the same\nobject is nested multiple times. For instance, assume a data structure of a family tree:: // ...\nclass Person\n{\n// ... public function __construct(\nprivate string $name,\nprivate ?self $mother\n) {\n} public function getName(): string\n{\nreturn $this->name;\n} public function getMother(): ?self\n{\nreturn $this->mother;\n} // ...\n} // ...\n$greatGrandmother = new Person('Elizabeth', null);\n$grandmother = new Person('Jane', $greatGrandmother);\n$mother = new Person('Sophie', $grandmother);\n$child = new Person('Joe', $mother); You can specify the maximum depth for a given property. For instance, you\ncan set the max depth to 1 to always only serialize someone's mother\n(and not their grandmother, etc.): // src/Model/Person.php\nnamespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\MaxDepth;", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_12", "source": "serializer.rst", "text": "class Person\n{\n#[MaxDepth(1)]\nprivate ?self $mother; // ...\n} # config/serializer/person.yaml\nApp\\Model\\Person:\nattributes:\nmother:\nmax_depth: 1 <!-- config/serializer/person.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Model\\Person\">\n<attribute name=\"mother\" max-depth=\"1\"/>\n</class>\n</serializer> To limit the serialization depth, you must set the\nAbstractObjectNormalizer::ENABLE_MAX_DEPTH key to true in the\ncontext (or the default context specified in framework.yaml):: // ...\n$greatGrandmother = new Person('Elizabeth', null);\n$grandmother = new Person('Jane', $greatGrandmother);\n$mother = new Person('Sophie', $grandmother);\n$child = new Person('Joe', $mother); $jsonContent = $serializer->serialize($child, null, [\nAbstractObjectNormalizer::ENABLE_MAX_DEPTH => true\n]);\n// $jsonContent contains {\"name\":\"Joe\",\"mother\":{\"name\":\"Sophie\"}} You can also configure a custom callable that is used when the maximum\ndepth is reached. This can be used to for instance return the unique\nidentifier of the next nested object, instead of omitting the property:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer;\n// ... $greatGrandmother = new Person('Elizabeth', null);\n$grandmother = new Person('Jane', $greatGrandmother);\n$mother = new Person('Sophie', $grandmother);\n$child = new Person('Joe', $mother); // all callback parameters are optional (you can omit the ones you don't use)\n$maxDepthHandler = function (object $innerObject, object $outerObject, string $attributeName, ?string $format = null, array $context = []): ?string {\n// return only the name of the next person in the tree\nreturn $innerObject instanceof Person ? $innerObject->getName() : null;\n}; $jsonContent = $serializer->serialize($child, null, [\nAbstractObjectNormalizer::ENABLE_MAX_DEPTH => true,\nAbstractObjectNormalizer::MAX_DEPTH_HANDLER => $maxDepthHandler,\n]);\n// $jsonContent contains {\"name\":\"Joe\",\"mother\":{\"name\":\"Sophie\",\"mother\":\"Jane\"}} Using Callbacks to Serialize Properties with Object Instances When serializing, you can set a callback to format a specific object\nproperty. This can be used instead of\ndefining the context for a group :: $person = new Person('cordoval', 34);\n$person->setCreatedAt(new \\DateTime('now')); $context = [\nAbstractNormalizer::CALLBACKS => [\n// all callback parameters are optional (you can omit the ones you don't use)\n'createdAt' => function (object $attributeValue, object $object, string $attributeName, ?string $format = null, array $context = []) {\nreturn $attributeValue instanceof \\DateTime ? $attributeValue->format(\\DateTime::ATOM) : '';\n},\n],\n];\n$jsonContent = $serializer->serialize($person, 'json', $context);\n// $jsonContent contains {\"name\":\"cordoval\",\"age\":34,\"createdAt\":\"2014-03-22T09:43:12-0500\"} Advanced Deserialization Require all Properties By default, the Serializer will add null to nullable properties when\nthe parameters for those are not provided. You can change this behavior by\nsetting the AbstractNormalizer::REQUIRE_ALL_PROPERTIES context option\nto true:: class Person\n{\npublic function __construct(\npublic string $firstName,\npublic ?string $lastName,\n) {\n}\n} // ...\n$data = ['firstName' => 'John'];\n$person = $serializer->deserialize($data, Person::class, 'json', [\nAbstractNormalizer::REQUIRE_ALL_PROPERTIES => true,\n]);\n// throws Symfony\\Component\\Serializer\\Exception\\MissingConstructorArgumentException Collecting Type Errors While Denormalizing When denormalizing a payload to an object with typed properties, you'll get an\nexception if the payload contains properties that don't have the same type as\nthe object. Use the COLLECT_DENORMALIZATION_ERRORS option to collect all exceptions\nat once, and to get the object partially denormalized:: try {\n$person = $serializer->deserialize($jsonString, Person::class, 'json', [\nDenormalizerInterface::COLLECT_DENORMALIZATION_ERRORS => true,\n]);\n} catch (PartialDenormalizationException $e) {\n$violations = new ConstraintViolationList();", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_13", "source": "serializer.rst", "text": "/** @var NotNormalizableValueException $exception */\nforeach ($e->getErrors() as $exception) {\n$message = sprintf('The type must be one of \"%s\" (\"%s\" given).', implode(', ', $exception->getExpectedTypes()), $exception->getCurrentType());\n$parameters = [];\nif ($exception->canUseMessageForUser()) {\n$parameters['hint'] = $exception->getMessage();\n}\n$violations->add(new ConstraintViolation($message, '', $parameters, null, $exception->getPath(), null));\n} // ... return violation list to the user\n} Deserializing in an Existing Object The serializer can also be used to update an existing object. You can do\nthis by configuring the object_to_populate serializer context option:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer; // ...\n$person = new Person('Jane Doe', 59); $serializer->deserialize($jsonData, Person::class, 'json', [\nAbstractNormalizer::OBJECT_TO_POPULATE => $person,\n]);\n// instead of returning a new object, $person is updated instead The AbstractNormalizer::OBJECT_TO_POPULATE option is only used for\nthe top level object. If that object is the root of a tree structure,\nall child elements that exist in the normalized data will be re-created\nwith new instances. When the AbstractObjectNormalizer::DEEP_OBJECT_TO_POPULATE context\noption is set to true, existing children of the root OBJECT_TO_POPULATE\nare updated from the normalized data, instead of the denormalizer\nre-creating them. This only works for single child objects, not for\narrays of objects. Those will still be replaced when present in the\nnormalized data. Deserializing Interfaces and Abstract Classes When working with associated objects, a property sometimes reference an\ninterface or abstract class. When deserializing these properties, the\nSerializer has to know which concrete class to initialize. This is done\nusing a *discriminator class mapping*. Imagine there is an InvoiceItemInterface that is implemented by the\nProduct and Shipping objects. When serializing an object, the\nserializer will add an extra \"discriminator attribute\". This contains\neither product or shipping. The discriminator class map maps\nthese type names to the real PHP class name when deserializing: namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\DiscriminatorMap; #[DiscriminatorMap(\ntypeProperty: 'type',\nmapping: [\n'product' => Product::class,\n'shipping' => Shipping::class,\n]\n)]\ninterface InvoiceItemInterface\n{\n// ...\n} App\\Model\\InvoiceItemInterface:\ndiscriminator_map:\ntype_property: type\nmapping:\nproduct: 'App\\Model\\Product'\nshipping: 'App\\Model\\Shipping' <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Model\\InvoiceItemInterface\">\n<discriminator-map type-property=\"type\">\n<mapping type=\"product\" class=\"App\\Model\\Product\"/>\n<mapping type=\"shipping\" class=\"App\\Model\\Shipping\"/>\n</discriminator-map>\n</class>\n</serializer> With the discriminator map configured, the serializer can now pick the\ncorrect class for properties typed as InvoiceItemInterface:: class InvoiceLine\n{\npublic function __construct(\nprivate InvoiceItemInterface $invoiceItem\n) {\n$this->invoiceItem = $invoiceItem;\n} public function getInvoiceItem(): InvoiceItemInterface\n{\nreturn $this->invoiceItem;\n} // ...\n} // ...\n$invoiceLine = new InvoiceLine(new Product()); $jsonString = $serializer->serialize($invoiceLine, 'json');\n// $jsonString contains {\"type\":\"product\",...} $invoiceLine = $serializer->deserialize($jsonString, InvoiceLine::class, 'json');\n// $invoiceLine contains new InvoiceLine(new Product(...)) // ...\nuse Symfony\\Component\\Serializer\\Mapping\\ClassDiscriminatorFromClassMetadata;\nuse Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory;\nuse Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader;\nuse Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\nuse Symfony\\Component\\Serializer\\Serializer; class InvoiceLine\n{\npublic function __construct(\nprivate InvoiceItemInterface $invoiceItem\n) {\n$this->invoiceItem = $invoiceItem;\n} public function getInvoiceItem(): InvoiceItemInterface\n{\nreturn $this->invoiceItem;\n} // ...\n} // ... // Configure a loader to retrieve mapping information like DiscriminatorMap.\n// E.g. when using PHP attributes:\n$classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());\n$discriminator = new ClassDiscriminatorFromClassMetadata($classMetadataFactory);\n$normalizers = [\nnew ObjectNormalizer($classMetadataFactory, null, null, null, $discriminator),\n]; $serializer = new Serializer($normalizers, $encoders); $invoiceLine = new InvoiceLine(new Product());", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_14", "source": "serializer.rst", "text": "$jsonString = $serializer->serialize($invoiceLine, 'json');\n// $jsonString contains {\"type\":\"product\",...} $invoiceLine = $serializer->deserialize($jsonString, InvoiceLine::class, 'json');\n// $invoiceLine contains new InvoiceLine(new Product(...)) You can add a default type to avoid the need to add the type property\nwhen deserializing: namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\DiscriminatorMap; #[DiscriminatorMap(\ntypeProperty: 'type',\nmapping: [\n'product' => Product::class,\n'shipping' => Shipping::class,\n],\ndefaultType: 'product',\n)]\ninterface InvoiceItemInterface\n{\n// ...\n} App\\Model\\InvoiceItemInterface:\ndiscriminator_map:\ntype_property: type\nmapping:\nproduct: 'App\\Model\\Product'\nshipping: 'App\\Model\\Shipping'\ndefault_type: product <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\nhttps://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n>\n<class name=\"App\\Model\\InvoiceItemInterface\">\n<discriminator-map type-property=\"type\" default-type=\"product\">\n<mapping type=\"product\" class=\"App\\Model\\Product\"/>\n<mapping type=\"shipping\" class=\"App\\Model\\Shipping\"/>\n</discriminator-map>\n</class>\n</serializer> Now it deserializes like this: // $jsonString does NOT contain \"type\" in \"invoiceItem\"\n$invoiceLine = $serializer->deserialize('{\"invoiceItem\":{...},...}', InvoiceLine::class, 'json');\n// $invoiceLine contains new InvoiceLine(new Product(...)) The defaultType parameter was added in Symfony 7.3. Deserializing Input Partially (Unwrapping) The serializer will always deserialize the complete input string into PHP\nvalues. When connecting with third party APIs, you often only need a\nspecific part of the returned response. To avoid deserializing the whole response, you can use the\nSymfony\\\\Component\\\\Serializer\\\\Normalizer\\\\UnwrappingDenormalizer\nand \"unwrap\" the input data:: $jsonData = '{\"result\":\"success\",\"data\":{\"person\":{\"name\": \"Jane Doe\",\"age\":57}}}';\n$data = $serialiser->deserialize($jsonData, Object::class, 'json', [\nUnwrappingDenormalizer::UNWRAP_PATH => '[data][person]',\n]);\n// $data is Person(name: 'Jane Doe', age: 57) The unwrap_path is a property path\nof the PropertyAccess component, applied on the denormalized array. Handling Constructor Arguments If the class constructor defines arguments, as usually happens with\n`Value Objects`_, the serializer will match the parameter names with the\ndeserialized attributes. If some parameters are missing, a\nSymfony\\\\Component\\\\Serializer\\\\Exception\\\\MissingConstructorArgumentsException\nis thrown. In these cases, use the default_constructor_arguments context option to\ndefine default values for the missing parameters:: use App\\Model\\Person;\nuse Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer;\n// ... $jsonData = '{\"age\":39,\"name\":\"Jane Doe\"}';\n$person = $serializer->deserialize($jsonData, Person::class, 'json', [\nAbstractNormalizer::DEFAULT_CONSTRUCTOR_ARGUMENTS => [\nPerson::class => ['sportsperson' => true],\n],\n]);\n// $person is Person(name: 'Jane Doe', age: 39, sportsperson: true); Recursive Denormalization and Type Safety When a PropertyTypeExtractor is available, the normalizer will also\ncheck that the data to denormalize matches the type of the property (even\nfor primitive types). For instance, if a string is provided, but the\ntype of the property is int, an\nSymfony\\\\Component\\\\Serializer\\\\Exception\\\\UnexpectedValueException\nwill be thrown. The type enforcement of the properties can be disabled by\nsetting the serializer context option\nObjectNormalizer::DISABLE_TYPE_ENFORCEMENT to true. Handling Boolean Values The AbstractNormalizer::FILTER_BOOL context option was introduced in Symfony 7.1. PHP considers many different values as true or false. For example, the\nstrings true, 1, and yes are considered true, while\nfalse, 0, and no are considered false. When deserializing, the Serializer component can take care of this\nautomatically. This can be done by using the AbstractNormalizer::FILTER_BOOL\ncontext option:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer;\n// ... $person = $serializer->denormalize(['sportsperson' => 'yes'], Person::class, context: [\nAbstractNormalizer::FILTER_BOOL => true\n]);\n// $person contains a Person instance with sportsperson set to true This context makes the deserialization process behave like the\nfilter_var function with the FILTER_VALIDATE_BOOL flag. Configuring the Metadata Cache", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_sem_15", "source": "serializer.rst", "text": "The metadata for the serializer is automatically cached to enhance application\nperformance. By default, the serializer uses the cache.system cache pool\nwhich is configured using the cache.system\noption. Going Further with the Serializer :glob:\n:maxdepth: 1 serializer/*", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "service_container.rst_sem_0", "source": "service_container.rst", "text": "Service Container :class: screencast Do you prefer video tutorials? Check out the `Symfony Fundamentals screencast series`_. Your application is *full* of useful objects: a \"Mailer\" object might help you\nsend emails while another object might help you save things to the database.\nAlmost *everything* that your app \"does\" is actually done by one of these objects.\nAnd each time you install a new bundle, you get access to even more! In Symfony, these useful objects are called **services** and each service lives\ninside a very special object called the **service container**. The container\nallows you to centralize the way objects are constructed. It makes your life\neasier, promotes a strong architecture and is super fast! Fetching and using Services The moment you start a Symfony app, your container *already* contains many services.\nThese are like *tools*: waiting for you to take advantage of them. In your controller,\nyou can \"ask\" for a service from the container by type-hinting an argument with the\nservice's class or interface name. Want to log something? No problem:: // src/Controller/ProductController.php\nnamespace App\\Controller; use Psr\\Log\\LoggerInterface;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route; class ProductController extends AbstractController\n{\n#[Route('/products')]\npublic function list(LoggerInterface $logger): Response\n{\n$logger->info('Look, I just used a service!'); // ...\n}\n} What other services are available? Find out by running: $ php bin/console debug:autowiring # this is just a *small* sample of the output... Autowirable Types The following classes & interfaces can be used as type-hints when autowiring: Describes a logger instance.\nPsr\\Log\\LoggerInterface - alias:logger Request stack that controls the lifecycle of requests.\nSymfony\\Component\\HttpFoundation\\RequestStack - alias:request_stack RouterInterface is the interface that all Router classes must implement.\nSymfony\\Component\\Routing\\RouterInterface - alias:router.default [...] When you use these type-hints in your controller methods or inside your\nown services , Symfony will automatically\npass you the service object matching that type. Throughout the docs, you'll see how to use the many different services that live\nin the container. There are actually *many* more services in the container, and each service has\na unique id in the container, like request_stack or router.default. For a full\nlist, you can run php bin/console debug:container. But most of the time,\nyou won't need to worry about this. See how to choose a specific service\n. See /service_container/debug. Creating/Configuring Services in the Container You can also organize your *own* code into services. For example, suppose you need\nto show your users a random, happy message. If you put this code in your controller,\nit can't be re-used. Instead, you decide to create a new class:: // src/Service/MessageGenerator.php\nnamespace App\\Service; class MessageGenerator\n{\npublic function getHappyMessage(): string\n{\n$messages = [\n'You did it! You updated the system! Amazing!',\n'That was one of the coolest updates I\\'ve seen all day!',\n'Great work! Keep going!',\n]; $index = array_rand($messages); return $messages[$index];\n}\n} Congratulations! You've created your first service class! You can use it immediately\ninside your controller:: // src/Controller/ProductController.php\nuse App\\Service\\MessageGenerator;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_1", "source": "service_container.rst", "text": "class ProductController extends AbstractController\n{\n#[Route('/products/new')]\npublic function new(MessageGenerator $messageGenerator): Response\n{\n// thanks to the type-hint, the container will instantiate a\n// new MessageGenerator and pass it to you!\n// ... $message = $messageGenerator->getHappyMessage();\n$this->addFlash('success', $message);\n// ...\n}\n} When you ask for the MessageGenerator service, the container constructs a new\nMessageGenerator object and returns it (see sidebar below). But if you never ask\nfor the service, it's *never* constructed: saving memory and speed. As a bonus, the\nMessageGenerator service is only created *once*: the same instance is returned\neach time you ask for it. The documentation assumes you're using the following service configuration,\nwhich is the default config for a new project: # config/services.yaml\nservices:\n# default configuration for services in *this* file\n_defaults:\nautowire: true # Automatically injects dependencies in your services.\nautoconfigure: true # Automatically registers your services as commands, event subscribers, etc. # makes classes in src/ available to be used as services\n# this creates a service per class whose id is the fully-qualified class name\nApp\\:\nresource: '../src/' # order is important in this file because service definitions\n# always *replace* previous ones; add your own service configuration below # ... <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- Default configuration for services in *this* file -->\n<defaults autowire=\"true\" autoconfigure=\"true\"/> <!-- makes classes in src/ available to be used as services -->\n<!-- this creates a service per class whose id is the fully-qualified class name -->\n<prototype namespace=\"App\\\" resource=\"../src/\"/> <!-- order is important in this file because service definitions\nalways *replace* previous ones; add your own service configuration below --> <!-- ... --> </services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void {\n// default configuration for services in *this* file\n$services = $container->services()\n->defaults()\n->autowire() // Automatically injects dependencies in your services.\n->autoconfigure() // Automatically registers your services as commands, event subscribers, etc.\n; // makes classes in src/ available to be used as services\n// this creates a service per class whose id is the fully-qualified class name\n$services->load('App\\\\', '../src/'); // order is important in this file because service definitions\n// always *replace* previous ones; add your own service configuration below\n}; The value of the resource option can be any valid `glob pattern`_. Thanks to this configuration, you can automatically use any classes from the\nsrc/ directory as a service, without needing to manually configure\nit. Later, you'll learn how to import many services at once\nwith resource. If some files or directories in your project should not become services, you\ncan exclude them using the exclude option: # config/services.yaml\nservices:\n# ...\nApp\\:\nresource: '../src/'\nexclude:\n- '../src/SomeDirectory/'\n- '../src/AnotherDirectory/'\n- '../src/SomeFile.php' <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<prototype namespace=\"App\\\" resource=\"../src/\" exclude=\"../src/{SomeDirectory,AnotherDirectory,Kernel.php}\"/>\n<!-- ... -->\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void {\n// ... $services->load('App\\\\', '../src/')\n->exclude('../src/{SomeDirectory,AnotherDirectory,Kernel.php}');\n};", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_2", "source": "service_container.rst", "text": "If you'd prefer to manually wire your service, you can\nuse explicit configuration . Limiting Services to a specific Symfony Environment You can use the #[When] attribute to only register the class\nas a service in some environments:: use Symfony\\Component\\DependencyInjection\\Attribute\\When; // SomeClass is only registered in the \"dev\" environment #[When(env: 'dev')]\nclass SomeClass\n{\n// ...\n} // you can also apply more than one When attribute to the same class #[When(env: 'dev')]\n#[When(env: 'test')]\nclass AnotherClass\n{\n// ...\n} If you want to exclude a service from being registered in a specific\nenvironment, you can use the #[WhenNot] attribute:: use Symfony\\Component\\DependencyInjection\\Attribute\\WhenNot; // SomeClass is registered in all environments except \"dev\" #[WhenNot(env: 'dev')]\nclass SomeClass\n{\n// ...\n} // you can apply more than one WhenNot attribute to the same class #[WhenNot(env: 'dev')]\n#[WhenNot(env: 'test')]\nclass AnotherClass\n{\n// ...\n} The #[WhenNot] attribute was introduced in Symfony 7.2. Injecting Services/Config into a Service What if you need to access the logger service from within MessageGenerator?\nNo problem! Create a __construct() method with a $logger argument that has\nthe LoggerInterface type-hint. Set this on a new $logger property\nand use it later:: // src/Service/MessageGenerator.php\nnamespace App\\Service; use Psr\\Log\\LoggerInterface; class MessageGenerator\n{\npublic function __construct(\nprivate LoggerInterface $logger,\n) {\n} public function getHappyMessage(): string\n{\n$this->logger->info('About to find a happy message!');\n// ...\n}\n} That's it! The container will *automatically* know to pass the logger service\nwhen instantiating the MessageGenerator. How does it know to do this?\nAutowiring . The key is the LoggerInterface\ntype-hint in your __construct() method and the autowire: true config in\nservices.yaml. When you type-hint an argument, the container will automatically\nfind the matching service. If it can't, you'll see a clear exception with a helpful\nsuggestion. By the way, this method of adding dependencies to your __construct() method is\ncalled *dependency injection*. How should you know to use LoggerInterface for the type-hint? You can either\nread the docs for whatever feature you're using, or get a list of autowireable\ntype-hints by running: $ php bin/console debug:autowiring # this is just a *small* sample of the output... Describes a logger instance.\nPsr\\Log\\LoggerInterface - alias:monolog.logger Request stack that controls the lifecycle of requests.\nSymfony\\Component\\HttpFoundation\\RequestStack - alias:request_stack RouterInterface is the interface that all Router classes must implement.\nSymfony\\Component\\Routing\\RouterInterface - alias:router.default [...] In addition to injecting services, you can also pass scalar values and collections\nas arguments of other services: # config/services.yaml\nservices:\nApp\\Service\\SomeService:\narguments:\n# string, numeric and boolean arguments can be passed \"as is\"\n- 'Foo'\n- true\n- 7\n- 3.14 # constants can be built-in, user-defined, or Enums\n- !php/const E_ALL\n- !php/const PDO::FETCH_NUM\n- !php/const Symfony\\Component\\HttpKernel\\Kernel::VERSION\n- !php/const App\\Config\\SomeEnum::SomeCase # when not using autowiring, you can pass service arguments explicitly\n- '@some-service-id' # the leading '@' tells this is a service ID, not a string\n- '@?some-service-id' # using '?' means to pass null if service doesn't exist # binary contents are passed encoded as base64 strings\n- !!binary VGhpcyBpcyBhIEJlbGwgY2hhciAH", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_3", "source": "service_container.rst", "text": "# collections (arrays) can include any type of argument\n-\nfirst: !php/const true\nsecond: 'Foo' <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <services>\n<service id=\"App\\Service\\SomeService\">\n<!-- arguments without a type can be strings or numbers -->\n<argument>Foo</argument>\n<argument>7</argument>\n<argument>3.14</argument>\n<!-- explicitly declare a string argument -->\n<argument type=\"string\">Foo</argument>\n<!-- booleans are passed as constants -->\n<argument type=\"constant\">true</argument> <!-- constants can be built-in, user-defined, or Enums -->\n<argument type=\"constant\">E_ALL</argument>\n<argument type=\"constant\">PDO::FETCH_NUM</argument>\n<argument type=\"constant\">Symfony\\Component\\HttpKernel\\Kernel::VERSION</argument>\n<argument type=\"constant\">App\\Config\\SomeEnum::SomeCase</argument> <!-- when not using autowiring, you can pass service arguments explicitly -->\n<argument type=\"service\"\nid=\"some-service-id\"\non-invalid=\"dependency_injection-ignore\"/> <!-- binary contents are passed encoded as base64 strings -->\n<argument type=\"binary\">VGhpcyBpcyBhIEJlbGwgY2hhciAH</argument> <!-- collections (arrays) can include any type of argument -->\n<argument type=\"collection\">\n<argument key=\"first\" type=\"constant\">true</argument>\n<argument key=\"second\" type=\"string\">Foo</argument>\n</argument>\n</service> <!-- ... -->\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\DependencyInjection\\Reference; return static function (ContainerConfigurator $container) {\n$services = $container->services(); $services->set(App\\Service\\SomeService::class)\n// string, numeric and boolean arguments can be passed \"as is\"\n->arg(0, 'Foo')\n->arg(1, true)\n->arg(2, 7)\n->arg(3, 3.14) // constants: built-in, user-defined, or Enums\n->arg(4, E_ALL)\n->arg(5, \\PDO::FETCH_NUM)\n->arg(6, Symfony\\Component\\HttpKernel\\Kernel::VERSION)\n->arg(7, App\\Config\\SomeEnum::SomeCase) // when not using autowiring, you can pass service arguments explicitly\n->arg(8, service('some-service-id')) # fails if service doesn't exist\n# passes null if service doesn't exist\n->arg(9, new Reference('some-service-id', Reference::IGNORE_ON_INVALID_REFERENCE)) // collection with mixed argument types\n->arg(10, [\n'first' => true,\n'second' => 'Foo',\n]); // ...\n}; Handling Multiple Services Suppose you also want to email a site administrator each time a site update is\nmade. To do that, you create a new class:: // src/Service/SiteUpdateManager.php\nnamespace App\\Service; use App\\Service\\MessageGenerator;\nuse Symfony\\Component\\Mailer\\MailerInterface;\nuse Symfony\\Component\\Mime\\Email; class SiteUpdateManager\n{\npublic function __construct(\nprivate MessageGenerator $messageGenerator,\nprivate MailerInterface $mailer,\n) {\n} public function notifyOfSiteUpdate(): bool\n{\n$happyMessage = $this->messageGenerator->getHappyMessage(); $email = (new Email())\n->from('admin@example.com')\n->to('manager@example.com')\n->subject('Site update just happened!')\n->text('Someone just updated the site. We told them: '.$happyMessage); $this->mailer->send($email); // ... return true;\n}\n} This needs the MessageGenerator *and* the Mailer service. That's no\nproblem, we ask them by type hinting their class and interface names!\nNow, this new service is ready to be used. In a controller, for example,\nyou can type-hint the new SiteUpdateManager class and use it:: // src/Controller/SiteController.php\nnamespace App\\Controller; use App\\Service\\SiteUpdateManager;\n// ... class SiteController extends AbstractController\n{\npublic function new(SiteUpdateManager $siteUpdateManager): Response\n{\n// ... if ($siteUpdateManager->notifyOfSiteUpdate()) {\n$this->addFlash('success', 'Notification mail was sent successfully.');\n} // ...\n}\n} Thanks to autowiring and your type-hints in __construct(), the container creates\nthe SiteUpdateManager object and passes it the correct argument. In most cases,\nthis works perfectly. Manually Wiring Arguments But there are a few cases when an argument to a service cannot be autowired. For\nexample, suppose you want to make the admin email configurable: // src/Service/SiteUpdateManager.php\n// ... class SiteUpdateManager\n{\n// ... public function __construct(\nprivate MessageGenerator $messageGenerator,\nprivate MailerInterface $mailer,\n+ private string $adminEmail\n) {\n} public function notifyOfSiteUpdate(): bool\n{\n// ...", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_4", "source": "service_container.rst", "text": "$email = (new Email())\n// ...\n- ->to('manager@example.com')\n+ ->to($this->adminEmail)\n// ...\n;\n// ...\n}\n} If you make this change and refresh, you'll see an error: Cannot autowire service \"App\\\\Service\\\\SiteUpdateManager\": argument \"$adminEmail\"\nof method \"__construct()\" must have a type-hint or be given a value explicitly. That makes sense! There is no way that the container knows what value you want to\npass here. No problem! In your configuration, you can explicitly set this argument: # config/services.yaml\nservices:\n# ... same as before # same as before\nApp\\:\nresource: '../src/'\nexclude: '../src/{DependencyInjection,Entity,Kernel.php}' # explicitly configure the service\nApp\\Service\\SiteUpdateManager:\narguments:\n$adminEmail: 'manager@example.com' <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... same as before --> <!-- Same as before --> <prototype namespace=\"App\\\"\nresource=\"../src/\"\nexclude=\"../src/{DependencyInjection,Entity,Kernel.php}\"\n/> <!-- Explicitly configure the service -->\n<service id=\"App\\Service\\SiteUpdateManager\">\n<argument key=\"$adminEmail\">manager@example.com</argument>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\SiteUpdateManager; return function(ContainerConfigurator $container): void {\n// ... // same as before\n$services->load('App\\\\', '../src/')\n->exclude('../src/{DependencyInjection,Entity,Kernel.php}'); $services->set(SiteUpdateManager::class)\n->arg('$adminEmail', 'manager@example.com')\n;\n}; Thanks to this, the container will pass manager@example.com to the $adminEmail\nargument of __construct when creating the SiteUpdateManager service. The\nother arguments will still be autowired. But, isn't this fragile? Fortunately, no! If you rename the $adminEmail argument\nto something else - e.g. $mainEmail - you will get a clear exception when you\nreload the next page (even if that page doesn't use this service). Service Parameters In addition to holding service objects, the container also holds configuration,\ncalled **parameters**. The main article about Symfony configuration explains the\nconfiguration parameters in detail and shows\nall their types (string, boolean, array, binary and PHP constant parameters). However, there is another type of parameter related to services. In YAML config,\nany string which starts with @ is considered as the ID of a service, instead\nof a regular string. In XML config, use the type=\"service\" type for the\nparameter and in PHP config use the service() function: # config/services.yaml\nservices:\nApp\\Service\\MessageGenerator:\narguments:\n# this is not a string, but a reference to a service called 'logger'\n- '@logger' # if the value of a string argument starts with '@', you need to escape\n# it by adding another '@' so Symfony doesn't consider it a service\n# the following example would be parsed as the string '@securepassword'\n# - '@@securepassword' <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<service id=\"App\\Service\\MessageGenerator\">\n<argument type=\"service\" id=\"logger\"/>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator; return function(ContainerConfigurator $container): void {\n$services = $container->services(); $services->set(MessageGenerator::class)\n->args([service('logger')])\n;\n}; Working with container parameters is straightforward using the container's\naccessor methods for parameters:: // checks if a parameter is defined (parameter names are case-sensitive)\n$container->hasParameter('mailer.transport'); // gets value of a parameter\n$container->getParameter('mailer.transport'); // adds a new parameter\n$container->setParameter('mailer.transport', 'sendmail'); The used . notation is a\nSymfony convention to make parameters\neasier to read. Parameters are flat key-value elements, they can't\nbe organized into a nested array", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_5", "source": "service_container.rst", "text": "You can only set a parameter before the container is compiled, not at run-time.\nTo learn more about compiling the container see\n/components/dependency_injection/compilation. Choose a Specific Service The MessageGenerator service created earlier requires a LoggerInterface argument:: // src/Service/MessageGenerator.php\nnamespace App\\Service; use Psr\\Log\\LoggerInterface; class MessageGenerator\n{\npublic function __construct(\nprivate LoggerInterface $logger,\n) {\n}\n// ...\n} However, there are *multiple* services in the container that implement LoggerInterface,\nsuch as logger, monolog.logger.request, monolog.logger.php, etc. How\ndoes the container know which one to use? In these situations, the container is usually configured to automatically choose\none of the services - logger in this case (read more about why in service-autowiring-alias).\nBut, you can control this and pass in a different logger: # config/services.yaml\nservices:\n# ... same code as before # explicitly configure the service\nApp\\Service\\MessageGenerator:\narguments:\n# the '@' symbol is important: that's what tells the container\n# you want to pass the *service* whose id is 'monolog.logger.request',\n# and not just the *string* 'monolog.logger.request'\n$logger: '@monolog.logger.request' <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... same code as before --> <!-- Explicitly configure the service -->\n<service id=\"App\\Service\\MessageGenerator\">\n<argument key=\"$logger\" type=\"service\" id=\"monolog.logger.request\"/>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator; return function(ContainerConfigurator $container): void {\n// ... same code as before // explicitly configure the service\n$services->set(MessageGenerator::class)\n->arg('$logger', service('monolog.logger.request'))\n;\n}; This tells the container that the $logger argument to __construct should use\nservice whose id is monolog.logger.request. For a list of possible logger services that can be used with autowiring, run: $ php bin/console debug:autowiring logger For a full list of *all* possible services in the container, run: $ php bin/console debug:container Remove Services A service can be removed from the service container if needed. This is useful\nfor example to make a service unavailable in some configuration environment\n(e.g. in the test environment): // config/services_test.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\RemovedService; return function(ContainerConfigurator $containerConfigurator) {\n$services = $containerConfigurator->services(); $services->remove(RemovedService::class);\n}; Now, the container will not contain the App\\RemovedService in the test\nenvironment. Injecting a Closure as an Argument It is possible to inject a callable as an argument of a service.\nLet's add an argument to our MessageGenerator constructor:: // src/Service/MessageGenerator.php\nnamespace App\\Service; use Psr\\Log\\LoggerInterface; class MessageGenerator\n{\nprivate string $messageHash; public function __construct(\nprivate LoggerInterface $logger,\ncallable $generateMessageHash,\n) {\n$this->messageHash = $generateMessageHash();\n}\n// ...\n} Now, we would add a new invokable service to generate the message hash:: // src/Hash/MessageHashGenerator.php\nnamespace App\\Hash; class MessageHashGenerator\n{\npublic function __invoke(): string\n{\n// Compute and return a message hash\n}\n} Our configuration looks like this: # config/services.yaml\nservices:\n# ... same code as before # explicitly configure the service\nApp\\Service\\MessageGenerator:\narguments:\n$logger: '@monolog.logger.request'\n$generateMessageHash: !closure '@App\\Hash\\MessageHashGenerator' <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... same code as before --> <!-- Explicitly configure the service -->\n<service id=\"App\\Service\\MessageGenerator\">\n<argument key=\"$logger\" type=\"service\" id=\"monolog.logger.request\"/>\n<argument key=\"$generateMessageHash\" type=\"closure\" id=\"App\\Hash\\MessageHashGenerator\"/>\n</service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_6", "source": "service_container.rst", "text": "use App\\Service\\MessageGenerator; return function(ContainerConfigurator $containerConfigurator): void {\n// ... same code as before // explicitly configure the service\n$services->set(MessageGenerator::class)\n->arg('$logger', service('monolog.logger.request'))\n->arg('$generateMessageHash', closure('App\\Hash\\MessageHashGenerator'))\n;\n}; Closures can be injected by using autowiring\nand its dedicated attributes. Binding Arguments by Name or Type You can also use the bind keyword to bind specific arguments by name or type: # config/services.yaml\nservices:\n_defaults:\nbind:\n# pass this value to any $adminEmail argument for any service\n# that's defined in this file (including controller arguments)\n$adminEmail: 'manager@example.com' # pass this service to any $requestLogger argument for any\n# service that's defined in this file\n$requestLogger: '@monolog.logger.request' # pass this service for any LoggerInterface type-hint for any\n# service that's defined in this file\nPsr\\Log\\LoggerInterface: '@monolog.logger.request' # optionally you can define both the name and type of the argument to match\nstring $adminEmail: 'manager@example.com'\nPsr\\Log\\LoggerInterface $requestLogger: '@monolog.logger.request'\niterable $rules: !tagged_iterator app.foo.rule # ... <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<defaults autowire=\"true\" autoconfigure=\"true\" public=\"false\">\n<bind key=\"$adminEmail\">manager@example.com</bind>\n<bind key=\"$requestLogger\"\ntype=\"service\"\nid=\"monolog.logger.request\"\n/>\n<bind key=\"Psr\\Log\\LoggerInterface\"\ntype=\"service\"\nid=\"monolog.logger.request\"\n/> <!-- optionally you can define both the name and type of the argument to match -->\n<bind key=\"string $adminEmail\">manager@example.com</bind>\n<bind key=\"Psr\\Log\\LoggerInterface $requestLogger\"\ntype=\"service\"\nid=\"monolog.logger.request\"\n/>\n<bind key=\"iterable $rules\"\ntype=\"tagged_iterator\"\ntag=\"app.foo.rule\"\n/>\n</defaults> <!-- ... -->\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Psr\\Log\\LoggerInterface; return function(ContainerConfigurator $container): void {\n$services = $container->services()\n->defaults()\n// pass this value to any $adminEmail argument for any service\n// that's defined in this file (including controller arguments)\n->bind('$adminEmail', 'manager@example.com') // pass this service to any $requestLogger argument for any\n// service that's defined in this file\n->bind('$requestLogger', service('monolog.logger.request')) // pass this service for any LoggerInterface type-hint for any\n// service that's defined in this file\n->bind(LoggerInterface::class, service('monolog.logger.request')) // optionally you can define both the name and type of the argument to match\n->bind('string $adminEmail', 'manager@example.com')\n->bind(LoggerInterface::class.' $requestLogger', service('monolog.logger.request'))\n->bind('iterable $rules', tagged_iterator('app.foo.rule'))\n; // ...\n}; By putting the bind key under _defaults, you can specify the value of *any*\nargument for *any* service defined in this file! You can bind arguments by name\n(e.g. $adminEmail), by type (e.g. Psr\\Log\\LoggerInterface) or both\n(e.g. Psr\\Log\\LoggerInterface $requestLogger). The bind config can also be applied to specific services or when\nloading many services at once ). Abstract Service Arguments Sometimes, the values of some service arguments can't be defined in the\nconfiguration files because they are calculated at runtime using a\ncompiler pass\nor bundle extension . In those cases, you can use the abstract argument type to define at least\nthe name of the argument and some short description about its purpose: # config/services.yaml\nservices:\n# ... App\\Service\\MyService:\narguments:\n$rootNamespace: !abstract 'should be defined by Pass' # ... <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<service id=\"App\\Service\\MyService\" class=\"App\\Service\\MyService\">\n<argument key=\"$rootNamespace\" type=\"abstract\">should be defined by Pass</argument>\n</service> <!-- ... -->\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MyService;\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\DependencyInjection\\Definition;\nuse Symfony\\Component\\DependencyInjection\\Reference; return function(ContainerConfigurator $container) {\n$services = $container->services();", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_7", "source": "service_container.rst", "text": "$services->set(MyService::class)\n->arg('$rootNamespace', abstract_arg('should be defined by Pass'))\n; // ...\n}; If you don't replace the value of an abstract argument during runtime, a\nRuntimeException will be thrown with a message like\nArgument \"$rootNamespace\" of service \"App\\Service\\MyService\" is abstract: should be defined by Pass. The autowire Option Above, the services.yaml file has autowire: true in the _defaults section\nso that it applies to all services defined in that file. With this setting, you're\nable to type-hint arguments in the __construct() method of your services and\nthe container will automatically pass you the correct arguments. This entire entry\nhas been written around autowiring. For more details about autowiring, check out /service_container/autowiring. The autoconfigure Option Above, the services.yaml file has autoconfigure: true in the _defaults\nsection so that it applies to all services defined in that file. With this setting,\nthe container will automatically apply certain configuration to your services, based\non your service's *class*. This is mostly used to *auto-tag* your services. For example, to create a Twig extension, you need to create a class, register it\nas a service, and tag it with twig.extension. But, with autoconfigure: true, you don't need the tag. In fact, if you're using\nthe default services.yaml config ,\nyou don't need to do *anything*: the service will be automatically loaded. Then,\nautoconfigure will add the twig.extension tag *for* you, because your class\nimplements Twig\\Extension\\ExtensionInterface. And thanks to autowire, you can even add\nconstructor arguments without any configuration. Autoconfiguration also works with attributes. Some attributes like\nSymfony\\\\Component\\\\Messenger\\\\Attribute\\\\AsMessageHandler,\nSymfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener and\nSymfony\\\\Component\\\\Console\\\\Attribute\\\\AsCommand are registered\nfor autoconfiguration. Any class using these attributes will have tags applied\nto them. Linting Service Definitions The lint:container command performs additional checks to ensure the container\nis properly configured. It is useful to run this command before deploying your\napplication to production (e.g. in your continuous integration server): $ php bin/console lint:container # optionally, you can force the resolution of environment variables;\n# the command will fail if any of those environment variables are missing\n$ php bin/console lint:container --resolve-env-vars The --resolve-env-vars option was introduced in Symfony 7.2. Performing those checks whenever the container is compiled can hurt performance.\nThat's why they are implemented in compiler passes\ncalled CheckTypeDeclarationsPass and CheckAliasValidityPass, which are\ndisabled by default and enabled only when executing the lint:container command.\nIf you don't mind the performance loss, you can enable these compiler passes in\nyour application. The CheckAliasValidityPass compiler pass was introduced in Symfony 7.1. Public Versus Private Services Every service defined is private by default. When a service is private, you\ncannot access it directly from the container using $container->get(). As a\nbest practice, you should only create *private* services and you should fetch\nservices using dependency injection instead of using $container->get(). If you need to fetch services lazily, instead of using public services you\nshould consider using a service locator . But, if you *do* need to make a service public, override the public\nsetting: # config/services.yaml\nservices:\n# ... same code as before", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_8", "source": "service_container.rst", "text": "# explicitly configure the service\nApp\\Service\\PublicService:\npublic: true <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... same code as before --> <!-- Explicitly configure the service -->\n<service id=\"App\\Service\\PublicService\" public=\"true\"></service>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\PublicService; return function(ContainerConfigurator $container): void {\n// ... same as code before // explicitly configure the service\n$services->set(Service\\PublicService::class)\n->public()\n;\n}; It is also possible to define a service as public thanks to the #[Autoconfigure]\nattribute. This attribute must be used directly on the class of the service\nyou want to configure:: // src/Service/PublicService.php\nnamespace App\\Service; use Symfony\\Component\\DependencyInjection\\Attribute\\Autoconfigure; #[Autoconfigure(public: true)]\nclass PublicService\n{\n// ...\n} Importing Many Services at once with resource You've already seen that you can import many services at once by using the resource\nkey. For example, the default Symfony configuration contains this: # config/services.yaml\nservices:\n# ... same as before # makes classes in src/ available to be used as services\n# this creates a service per class whose id is the fully-qualified class name\nApp\\:\nresource: '../src/'\nexclude: '../src/{DependencyInjection,Entity,Kernel.php}' <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... same as before --> <prototype namespace=\"App\\\" resource=\"../src/\" exclude=\"../src/{DependencyInjection,Entity,Kernel.php}\"/>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void {\n// ... // makes classes in src/ available to be used as services\n// this creates a service per class whose id is the fully-qualified class name\n$services->load('App\\\\', '../src/')\n->exclude('../src/{DependencyInjection,Entity,Kernel.php}');\n}; The value of the resource and exclude options can be any valid\n`glob pattern`_. If you want to exclude only a few services, you\nmay use the Symfony\\\\Component\\\\DependencyInjection\\\\Attribute\\\\Exclude\nattribute directly on your class to exclude it. This can be used to quickly make many classes available as services and apply some\ndefault configuration. The id of each service is its fully-qualified class name.\nYou can override any service that's imported by using its id (class name) below\n(e.g. see how to manually wire arguments ).\nIf you override a service, none of the options (e.g. public) are inherited\nfrom the import (but the overridden service *does* still inherit from _defaults). You can also exclude certain paths. This is optional, but will slightly increase\nperformance in the dev environment: excluded paths are not tracked and so modifying\nthem will not cause the container to be rebuilt. Wait, does this mean that *every* class in src/ is registered as\na service? Even model classes? Actually, no. As long as you keep your imported services as private , all\nclasses in src/ that are *not* explicitly used as services are\nautomatically removed from the final container. In reality, the import\nmeans that all classes are \"available to be *used* as services\" without needing\nto be manually configured. Multiple Service Definitions Using the Same Namespace If you define services using the YAML config format, the PHP namespace is used\nas the key of each configuration, so you can't define different service configs\nfor classes under the same namespace:", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_9", "source": "service_container.rst", "text": "# config/services.yaml\nservices:\nApp\\Domain\\:\nresource: '../src/Domain/*'\n# ... <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<prototype namespace=\"App\\Domain\"\nresource=\"../src/App/Domain/*\"/> <!-- ... -->\n</services>\n</container> // config/services.php\nuse Symfony\\Component\\DependencyInjection\\Definition; $defaults = new Definition(); // $this is a reference to the current loader\n$this->registerClasses(\n$defaults,\n'App\\\\Domain\\\\',\n'../src/App/Domain/*'\n); // ... In order to have multiple definitions, add the namespace option and use any\nunique string as the key of each service config: # config/services.yaml\nservices:\ncommand_handlers:\nnamespace: App\\Domain\\\nresource: '../src/Domain/*/CommandHandler'\ntags: [command_handler] event_subscribers:\nnamespace: App\\Domain\\\nresource: '../src/Domain/*/EventSubscriber'\ntags: [event_subscriber] Explicitly Configuring Services and Arguments Loading services automatically\nand autowiring are optional. And even if you use them, there may be some\ncases where you want to manually wire a service. For example, suppose that you want\nto register *2* services for the SiteUpdateManager class - each with a different\nadmin email. In this case, each needs to have a unique service id: # config/services.yaml\nservices:\n# ... # this is the service's id\nsite_update_manager.superadmin:\nclass: App\\Service\\SiteUpdateManager\n# you CAN still use autowiring: we just want to show what it looks like without\nautowire: false\n# manually wire all arguments\narguments:\n- '@App\\Service\\MessageGenerator'\n- '@mailer'\n- 'superadmin@example.com' site_update_manager.normal_users:\nclass: App\\Service\\SiteUpdateManager\nautowire: false\narguments:\n- '@App\\Service\\MessageGenerator'\n- '@mailer'\n- 'contact@example.com' # Create an alias, so that - by default - if you type-hint SiteUpdateManager,\n# the site_update_manager.superadmin will be used\nApp\\Service\\SiteUpdateManager: '@site_update_manager.superadmin' <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... --> <service id=\"site_update_manager.superadmin\" class=\"App\\Service\\SiteUpdateManager\" autowire=\"false\">\n<argument type=\"service\" id=\"App\\Service\\MessageGenerator\"/>\n<argument type=\"service\" id=\"mailer\"/>\n<argument>superadmin@example.com</argument>\n</service> <service id=\"site_update_manager.normal_users\" class=\"App\\Service\\SiteUpdateManager\" autowire=\"false\">\n<argument type=\"service\" id=\"App\\Service\\MessageGenerator\"/>\n<argument type=\"service\" id=\"mailer\"/>\n<argument>contact@example.com</argument>\n</service> <service id=\"App\\Service\\SiteUpdateManager\" alias=\"site_update_manager.superadmin\"/>\n</services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator;\nuse App\\Service\\SiteUpdateManager; return function(ContainerConfigurator $container): void {\n// ... // site_update_manager.superadmin is the service's id\n$services->set('site_update_manager.superadmin', SiteUpdateManager::class)\n// you CAN still use autowiring: we just want to show what it looks like without\n->autowire(false)\n// manually wire all arguments\n->args([\nservice(MessageGenerator::class),\nservice('mailer'),\n'superadmin@example.com',\n]); $services->set('site_update_manager.normal_users', SiteUpdateManager::class)\n->autowire(false)\n->args([\nservice(MessageGenerator::class),\nservice('mailer'),\n'contact@example.com',\n]); // Create an alias, so that - by default - if you type-hint SiteUpdateManager,\n// the site_update_manager.superadmin will be used\n$services->alias(SiteUpdateManager::class, 'site_update_manager.superadmin');\n}; In this case, *two* services are registered: site_update_manager.superadmin\nand site_update_manager.normal_users. Thanks to the alias, if you type-hint\nSiteUpdateManager the first (site_update_manager.superadmin) will be passed. If you want to pass the second, you'll need to manually wire the service\nor to create a named autowiring alias . If you do *not* create the alias and are loading all services from src/ ,\nthen *three* services have been created (the automatic service + your two services)\nand the automatically loaded service will be passed - by default - when you type-hint\nSiteUpdateManager. That's why creating the alias is a good idea. When using PHP closures to configure your services, it is possible to automatically\ninject the current environment value by adding a string argument named $env to\nthe closure:: // config/packages/my_config.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_sem_10", "source": "service_container.rst", "text": "return function(ContainerConfigurator $containerConfigurator, string $env): void {\n// `$env` is automatically filled in, so you can configure your\n// services depending on which environment you're on\n}; Generating Adapters for Functional Interfaces Functional interfaces are interfaces with a single method.\nThey are conceptually very similar to a closure except that their only method\nhas a name. Moreover, they can be used as type-hints across your code. The Symfony\\\\Component\\\\DependencyInjection\\\\Attribute\\\\AutowireCallable\nattribute can be used to generate an adapter for a functional interface.\nLet's say you have the following functional interface:: // src/Service/MessageFormatterInterface.php\nnamespace App\\Service; interface MessageFormatterInterface\n{\npublic function format(string $message, array $parameters): string;\n} You also have a service that defines many methods and one of them is the same\nformat() method of the previous interface:: // src/Service/MessageUtils.php\nnamespace App\\Service; class MessageUtils\n{\n// other methods... public function format(string $message, array $parameters): string\n{\n// ...\n}\n} Thanks to the #[AutowireCallable] attribute, you can now inject this\nMessageUtils service as a functional interface implementation:: namespace App\\Service\\Mail; use App\\Service\\MessageFormatterInterface;\nuse App\\Service\\MessageUtils;\nuse Symfony\\Component\\DependencyInjection\\Attribute\\AutowireCallable; class Mailer\n{\npublic function __construct(\n#[AutowireCallable(service: MessageUtils::class, method: 'format')]\nprivate MessageFormatterInterface $formatter\n) {\n} public function sendMail(string $message, array $parameters): string\n{\n$formattedMessage = $this->formatter->format($message, $parameters); // ...\n}\n} Instead of using the #[AutowireCallable] attribute, you can also generate\nan adapter for a functional interface through configuration: # config/services.yaml\nservices: # ... app.message_formatter:\nclass: App\\Service\\MessageFormatterInterface\nfrom_callable: [!service {class: 'App\\Service\\MessageUtils'}, 'format'] <!-- config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\"> <services>\n<!-- ... --> <service id=\"app.message_formatter\" class=\"App\\Service\\MessageFormatterInterface\">\n<from-callable method=\"format\">\n<service class=\"App\\Service\\MessageUtils\"/>\n</from-callable>\n</service> </services>\n</container> // config/services.php\nnamespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageFormatterInterface;\nuse App\\Service\\MessageUtils; return function(ContainerConfigurator $container) {\n// ... $container\n->set('app.message_formatter', MessageFormatterInterface::class)\n->fromCallable([inline_service(MessageUtils::class), 'format'])\n->alias(MessageFormatterInterface::class, 'app.message_formatter')\n;\n}; By doing so, Symfony will generate a class (also called an *adapter*)\nimplementing MessageFormatterInterface that will forward calls of\nMessageFormatterInterface::format() to your underlying service's method\nMessageUtils::format(), with all its arguments. Learn more :maxdepth: 1\n:glob: /service_container/*", "title": "Service Container", "category": "service_container"}
{"chunk_id": "translation.rst_sem_0", "source": "translation.rst", "text": "Translations The term \"internationalization\" (often abbreviated `i18n`_) refers to the\nprocess of abstracting strings and other locale-specific pieces out of your\napplication into a layer where they can be translated and converted based\non the user's locale (i.e. language and country). For text, this means\nwrapping each with a function capable of translating the text (or \"message\")\ninto the language of the user:: // text will *always* print out in English\necho 'Hello World'; // text can be translated into the end-user's language or\n// default to English\necho $translator->trans('Hello World'); The term *locale* refers roughly to the user's language and country. It\ncan be any string that your application uses to manage translations and\nother format differences (e.g. currency format). The `ISO 639-1`_\n*language* code, an underscore (_), then the `ISO 3166-1 alpha-2`_\n*country* code (e.g. fr_FR for French/France) is recommended. Translations can be organized into groups, called **domains**. By default, all\nmessages use the default messages domain:: echo $translator->trans('Hello World', domain: 'messages'); The translation process has several steps: #. Enable and configure Symfony's\ntranslation service; #. Abstract strings (i.e. \"messages\") by wrapping them in calls\nto the Translator; #. Create translation resources/files\nfor each supported locale that translate each message in the application; #. Determine, set and manage the user's locale\nfor the request and optionally\non the user's entire session . Installation First, run this command to install the translator before using it: $ composer require symfony/translation Symfony includes several internationalization polyfills (symfony/polyfill-intl-icu,\nsymfony/polyfill-intl-messageformatter, etc.) that allow you to use translation\nfeatures even without the `PHP intl extension`_. However, these polyfills only\nsupport English translations, so you must install the PHP intl extension\nwhen translating into other languages. Configuration The previous command creates an initial config file where you can define the\ndefault locale of the application and the directory where the translation files\nare located: # config/packages/translation.yaml\nframework:\ndefault_locale: 'en'\ntranslator:\ndefault_path: '%kernel.project_dir%/translations' <!-- config/packages/translation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config default-locale=\"en\">\n<framework:translator\ndefault-path=\"%kernel.project_dir%/translations\"\n/>\n</framework:config>\n</container> // config/packages/translation.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n// ...\n$framework\n->defaultLocale('en')\n->translator()\n->defaultPath('%kernel.project_dir%/translations')\n;\n}; You can also define the enabled_locales option\nto restrict the locales that your application is available in. Basic Translation Translation of text is done through the translator service\n(Symfony\\\\Component\\\\Translation\\\\Translator). To translate a block of\ntext (called a *message*), use the\nSymfony\\\\Component\\\\Translation\\\\Translator::trans method. Suppose,\nfor example, that you're translating a static message from inside a\ncontroller:: // ...\nuse Symfony\\Contracts\\Translation\\TranslatorInterface; public function index(TranslatorInterface $translator): Response\n{\n$translated = $translator->trans('Symfony is great'); // ...\n} When this code is run, Symfony will attempt to translate the message\n\"Symfony is great\" based on the locale of the user. For this to work,\nyou need to tell Symfony how to translate the message via a \"translation\nresource\", which is usually a file that contains a collection of translations\nfor a given locale. This \"dictionary\" of translations can be created in several\ndifferent formats:", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_1", "source": "translation.rst", "text": "# translations/messages.fr.yaml\nSymfony is great: Symfony est génial <!-- translations/messages.fr.xlf -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">\n<file source-language=\"en\" datatype=\"plaintext\" original=\"file.ext\">\n<body>\n<trans-unit id=\"symfony_is_great\">\n<source>Symfony is great</source>\n<target>Symfony est génial</target>\n</trans-unit>\n</body>\n</file>\n</xliff> // translations/messages.fr.php\nreturn [\n'Symfony is great' => 'Symfony est génial',\n]; You can find more information on where these files\nshould be located . Now, if the language of the user's locale is French (e.g. fr_FR or fr_BE),\nthe message will be translated into Symfony est génial. You can also translate\nthe message inside your templates . Using Real or Keyword Messages This example illustrates the two different philosophies when creating\nmessages to be translated:: $translator->trans('Symfony is great'); $translator->trans('symfony.great'); In the first method, messages are written in the language of the default\nlocale (English in this case). That message is then used as the \"id\"\nwhen creating translations. In the second method, messages are actually \"keywords\" that convey the\nidea of the message. The keyword message is then used as the \"id\" for\nany translations. In this case, translations must be made for the default\nlocale (i.e. to translate symfony.great to Symfony is great). The second method is handy because the message key won't need to be changed\nin every translation file if you decide that the message should actually\nread \"Symfony is really great\" in the default locale. The choice of which method to use is entirely up to you, but the \"keyword\"\nformat is often recommended for multi-language applications, whereas for\nshared bundles that contain translation resources we recommend the real\nmessage, so your application can choose to disable the translator layer\nand you will see a readable message. Additionally, the php and yaml file formats support nested ids to\navoid repeating yourself if you use keywords instead of real text for your\nids: symfony:\nis:\n# id is symfony.is.great\ngreat: Symfony is great\n# id is symfony.is.amazing\namazing: Symfony is amazing\nhas:\n# id is symfony.has.bundles\nbundles: Symfony has bundles\nuser:\n# id is user.login\nlogin: Login [\n'symfony' => [\n'is' => [\n// id is symfony.is.great\n'great' => 'Symfony is great',\n// id is symfony.is.amazing\n'amazing' => 'Symfony is amazing',\n],\n'has' => [\n// id is symfony.has.bundles\n'bundles' => 'Symfony has bundles',\n],\n],\n'user' => [\n// id is user.login\n'login' => 'Login',\n],\n]; The Translation Process To actually translate the message, Symfony uses the following process when\nusing the trans() method: #. The locale of the current user, which is stored on the request is\ndetermined; this is typically set via a _locale attribute on\nyour routes ; #. A catalog of translated messages is loaded from translation resources\ndefined for the locale (e.g. fr_FR). Messages from the\nfallback locale and the\nenabled locales are also\nloaded and added to the catalog if they don't already exist. The end result\nis a large \"dictionary\" of translations.", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_2", "source": "translation.rst", "text": "#. If the message is located in the catalog, the translation is returned. If\nnot, the translator returns the original message. Message Format Sometimes, a message containing a variable needs to be translated:: // ...\n$translated = $translator->trans('Hello '.$name); However, creating a translation for this string is impossible since the\ntranslator will try to look up the message including the variable portions\n(e.g. *\"Hello Ryan\"* or *\"Hello Fabien\"*). Another complication is when you have translations that may or may not be\nplural, based on some variable: There is one apple.\nThere are 5 apples. To manage these situations, Symfony follows the `ICU MessageFormat`_ syntax by\nusing PHP's MessageFormatter class. Read more about this in\n/reference/formats/message_format. Translatable Objects Sometimes translating contents in templates is cumbersome because you need the\noriginal message, the translation parameters and the translation domain for\neach content. Making the translation in the controller or services simplifies\nyour templates, but requires injecting the translator service in different\nparts of your application and mocking it in your tests. Instead of translating a string at the time of creation, you can use a\n\"translatable object\", which is an instance of the\nSymfony\\\\Component\\\\Translation\\\\TranslatableMessage class. This object stores\nall the information needed to fully translate its contents when needed:: use Symfony\\Component\\Translation\\TranslatableMessage; // the first argument is required and it's the original message\n$message = new TranslatableMessage('Symfony is great!');\n// the optional second argument defines the translation parameters and\n// the optional third argument is the translation domain\n$status = new TranslatableMessage('order.status', ['%status%' => $order->getStatus()], 'store'); Templates are now much simpler because you can pass translatable objects to the\ntrans filter: <h1>{{ message|trans }}</h1>\n<p>{{ status|trans }}</p> The translation parameters can also be a Symfony\\\\Component\\\\Translation\\\\TranslatableMessage. There's also a function called t() ,\navailable both in Twig and PHP, as a shortcut to create translatable objects. Translations in Templates Most of the time, translation occurs in templates. Symfony provides native\nsupport for both Twig and PHP templates. Using Twig Filters The trans filter can be used to translate *variable texts* and complex expressions: {{ message|trans }} {{ message|trans({'%name%': 'Fabien'}, 'app') }} You can set the translation domain for an entire Twig template with a single tag: {% trans_default_domain 'app' %} Note that this only influences the current template, not any \"included\"\ntemplate (in order to avoid side effects). By default, the translated messages are output escaped; apply the raw\nfilter after the translation filter to avoid the automatic escaping: {% set message = '<h3>foo</h3>' %} {# strings and variables translated via a filter are escaped by default #}\n{{ message|trans|raw }}\n{{ '<h3>bar</h3>'|trans|raw }} Using Twig Tags Symfony provides a specialized Twig tag trans to help with message\ntranslation of *static blocks of text*: {% trans %}Hello %name%{% endtrans %} The %var% notation of placeholders is required when translating in\nTwig templates using the tag. If you need to use the percent character (%) in a string, escape it by\ndoubling it: {% trans %}Percent: %percent%%%{% endtrans %}", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_3", "source": "translation.rst", "text": "You can also specify the message domain and pass some additional variables: {% trans with {'%name%': 'Fabien'} from 'app' %}Hello %name%{% endtrans %} {% trans with {'%name%': 'Fabien'} from 'app' into 'fr' %}Hello %name%{% endtrans %} Using the translation tag has the same effect as the filter, but with one\nmajor difference: automatic output escaping is **not** applied to translations\nusing a tag. Global Translation Parameters The global translation parameters feature was introduced in Symfony 7.3. If the content of a translation parameter is repeated across multiple\ntranslation messages (e.g. a company name, or a version number), you can define\nit as a global translation parameter. This helps you avoid repeating the same\nvalues manually in each message. You can configure these global parameters in the translations.globals option\nof your main configuration file using either %...% or {...} syntax: # config/packages/translator.yaml\ntranslator:\n# ...\nglobals:\n# when using the '%' wrapping characters, you must escape them\n'%%app_name%%': 'My application'\n'{app_version}': '1.2.3'\n'{url}': { message: 'url', parameters: { scheme: 'https://' }, domain: 'global' } <!-- config/packages/translation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:translator>\n<!-- ... -->\n<!-- when using the '%' wrapping characters, you must escape them -->\n<framework:global name=\"%%app_name%%\">My application</framework:global>\n<framework:global name=\"{app_version}\" value=\"1.2.3\"/>\n<framework:global name=\"{url}\" message=\"url\" domain=\"global\">\n<framework:parameter name=\"scheme\">https://</framework:parameter>\n</framework:global>\n</framework:translator>\n</framework:config>\n</container> // config/packages/translator.php\nuse Symfony\\Config\\TwigConfig; return static function (TwigConfig $translator): void {\n// ...\n// when using the '%' wrapping characters, you must escape them\n$translator->globals('%%app_name%%')->value('My application');\n$translator->globals('{app_version}')->value('1.2.3');\n$translator->globals('{url}')->value(['message' => 'url', 'parameters' => ['scheme' => 'https://']]);\n}; Once defined, you can use these parameters in translation messages anywhere in\nyour application: {{ 'Application version: {app_version}'|trans }}\n{# output: \"Application version: 1.2.3\" #} {# parameters passed to the message override global parameters #}\n{{ 'Package version: {app_version}'|trans({'{app_version}': '2.3.4'}) }}\n# Displays \"Package version: 2.3.4\" Forcing the Translator Locale When translating a message, the translator uses the specified locale or the\nfallback locale if necessary. You can also manually specify the locale to\nuse for translation:: $translator->trans('Symfony is great', locale: 'fr_FR'); Extracting Translation Contents and Updating Catalogs Automatically The most time-consuming task when translating an application is to extract all\nthe template contents to be translated and to keep all the translation files in\nsync. Symfony includes a command called translation:extract that helps you\nwith these tasks: # shows all the messages that should be translated for the French language\n$ php bin/console translation:extract --dump-messages fr # updates the French translation files with the missing strings for that locale\n$ php bin/console translation:extract --force fr # check out the command help to see its options (prefix, output format, domain, sorting, etc.)\n$ php bin/console translation:extract --help The translation:extract command looks for missing translations in:", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_4", "source": "translation.rst", "text": "* Templates stored in the templates/ directory (or any other directory\ndefined in the twig.default_path and\ntwig.paths config options);\n* Any PHP file/class that injects or autowires\nthe translator service and makes calls to the trans() method;\n* Any PHP file/class stored in the src/ directory that creates\ntranslatable objects using the constructor or\nthe t() method or calls the trans() method;\n* Any PHP file/class stored in the src/ directory that uses\nConstraints Attributes with *message named argument(s). Install the nikic/php-parser package in your project to improve the\nresults of the translation:extract command. This package enables an\n`AST`_ parser that can find many more translatable items: $ composer require nikic/php-parser By default, when the translation:extract command creates new entries in the\ntranslation file, it uses the same content as both the source and the pending\ntranslation. The only difference is that the pending translation is prefixed by\n__. You can customize this prefix using the --prefix option: $ php bin/console translation:extract --force --prefix=\"NEW_\" fr Alternatively, you can use the --no-fill option to leave the pending translation\ncompletely empty when creating new entries in the translation catalog. This is\nparticularly useful when using external translation tools, as it makes it easier\nto spot untranslated strings: # when using the --no-fill option, the --prefix option is ignored\n$ php bin/console translation:extract --force --no-fill fr The --no-fill option was introduced in Symfony 7.2. Translation Resource/File Names and Locations Symfony looks for message files (i.e. translations) in the following default locations: * the translations/ directory (at the root of the project);\n* the translations/ directory inside of any bundle (and also their\nResources/translations/ directory, which is no longer recommended for bundles). The locations are listed here with the highest priority first. That is, you can\noverride the translation messages of a bundle in the first directory. Bundles are\nprocessed in the order in which they are listed in the config/bundles.php file,\nso bundles appearing earlier have higher priority. The override mechanism works at a key level: only the overridden keys need\nto be listed in a higher priority message file. When a key is not found\nin a message file, the translator will automatically fall back to the lower\npriority message files. The filename of the translation files is also important: each message file\nmust be named according to the following path: domain.locale.loader: * **domain**: The translation domain; * **locale**: The locale that the translations are for (e.g. en_GB, en, etc); * **loader**: How Symfony should load and parse the file (e.g. xlf,\nphp, yaml, etc). The loader can be the name of any registered loader. By default, Symfony\nprovides many loaders which are selected based on the following file extensions:", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_5", "source": "translation.rst", "text": "* .yaml: YAML file (you can also use the .yml file extension);\n* .xlf: XLIFF file (you can also use the .xliff file extension);\n* .php: a PHP file that returns an array with the translations;\n* .csv: CSV file;\n* .json: JSON file;\n* .ini: INI file;\n* .dat, .res: `ICU resource bundle`_;\n* .mo: `Machine object format`_;\n* .po: `Portable object format`_;\n* .qt: `QT Translations TS XML`_ file; The choice of which loader to use is entirely up to you and is a matter of\ntaste. The recommended option is to use YAML for simple projects and use XLIFF\nif you're generating translations with specialized programs or teams. Each time you create a *new* message catalog (or install a bundle\nthat includes a translation catalog), be sure to clear your cache so\nthat Symfony can discover the new translation resources: $ php bin/console cache:clear You can add other directories with the paths\noption in the configuration: # config/packages/translation.yaml\nframework:\ntranslator:\npaths:\n- '%kernel.project_dir%/custom/path/to/translations' <!-- config/packages/translation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-Instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:translator>\n<framework:path>%kernel.project_dir%/custom/path/to/translations</framework:path>\n</framework:translator>\n</framework:config>\n</container> // config/packages/translation.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->translator()\n->paths(['%kernel.project_dir%/custom/path/to/translations'])\n;\n}; Translations of Doctrine Entities Unlike the contents of templates, it's not practical to translate the contents\nstored in Doctrine Entities using translation catalogs. Instead, use the\nDoctrine `Translatable Extension`_. Custom Translation Resources If your translations use a format not supported by Symfony or you store them\nin a special way (e.g. not using files or Doctrine entities), you need to provide\na custom class implementing the Symfony\\\\Component\\\\Translation\\\\Loader\\\\LoaderInterface\ninterface. See the dic-tags-translation-loader tag for more information. Translation Providers When using external translators to translate your application, you must send\nthem the new contents to translate frequently and merge the results back in the\napplication. Instead of doing this manually, Symfony provides integration with several\nthird-party translation services. You can upload and download (called \"push\"\nand \"pull\") translations to/from these services and merge the results\nautomatically in the application. Installing and Configuring a Third Party Provider Before pushing/pulling translations to a third-party provider, you must install\nthe package that provides integration with that provider: ====================== ===========================================================\nProvider Install with\n====================== ===========================================================\n`Crowdin`_ composer require symfony/crowdin-translation-provider\n`Loco (localise.biz)`_ composer require symfony/loco-translation-provider\n`Lokalise`_ composer require symfony/lokalise-translation-provider\n`Phrase`_ composer require symfony/phrase-translation-provider\n====================== =========================================================== Each library includes a Symfony Flex recipe that will add\na configuration example to your .env file. For example, suppose you want to\nuse Loco. First, install it: $ composer require symfony/loco-translation-provider You'll now have a new line in your .env file that you can uncomment: # .env\nLOCO_DSN=loco://API_KEY@default The LOCO_DSN isn't a *real* address: it's a convenient format that offloads\nmost of the configuration work to Symfony. The loco scheme activates the\nLoco provider that you installed, which knows all about how to push and\npull translations via Loco. The *only* part you need to change is the\nAPI_KEY placeholder.", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_6", "source": "translation.rst", "text": "This table shows the full list of available DSN formats for each provider: ====================== ==============================================================\nProvider DSN\n====================== ==============================================================\n`Crowdin`_ crowdin://PROJECT_ID:API_TOKEN@ORGANIZATION_DOMAIN.default\n`Loco (localise.biz)`_ loco://API_KEY@default\n`Lokalise`_ lokalise://PROJECT_ID:API_KEY@default\n`Phrase`_ phrase://PROJECT_ID:API_TOKEN@default?userAgent=myProject\n====================== ============================================================== To enable a translation provider, customize the DSN in your .env file and\nconfigure the providers option: # config/packages/translation.yaml\nframework:\ntranslator:\nproviders:\nloco:\ndsn: '%env(LOCO_DSN)%'\ndomains: ['messages']\nlocales: ['en', 'fr'] <!-- config/packages/translation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:translator>\n<framework:provider name=\"loco\" dsn=\"%env(LOCO_DSN)%\">\n<framework:domain>messages</framework:domain>\n<!-- ... -->\n<framework:locale>en</framework:locale>\n<framework:locale>fr</framework:locale>\n<!-- ... -->\n</framework:provider>\n</framework:translator>\n</framework:config>\n</container> # config/packages/translation.php\n$container->loadFromExtension('framework', [\n'translator' => [\n'providers' => [\n'loco' => [\n'dsn' => env('LOCO_DSN'),\n'domains' => ['messages'],\n'locales' => ['en', 'fr'],\n],\n],\n],\n]); If you use Phrase as a provider you must configure a user agent in your dsn. See\n`Identification via User-Agent`_ for reasoning and some examples. Also make the locale _names_ in Phrase should be as defined in RFC4646 (e.g. pt-BR rather than pt_BR).\nNot doing so will result in Phrase creating a new locale for the imported keys. If you use Crowdin as a provider and some of your locales are different from\nthe `Crowdin Language Codes`_, you have to set the `Custom Language Codes`_ in the Crowdin project\nfor each of your locales, in order to override the default value. You need to select the\n\"locale\" placeholder and specify the custom code in the \"Custom Code\" field. If you use Lokalise as a provider and a locale format following the `ISO\n639-1`_ (e.g. \"en\" or \"fr\"), you have to set the `Custom Language Name setting`_\nin Lokalise for each of your locales, in order to override the\ndefault value (which follow the `ISO 639-1`_ succeeded by a sub-code in\ncapital letters that specifies the national variety (e.g. \"GB\" or \"US\"\naccording to `ISO 3166-1 alpha-2`_)). The Phrase provider uses Phrase's tag feature to map translations to Symfony's translation\ndomains. If you need some assistance with organising your tags in Phrase, you might want\nto consider the `Phrase Tag Bundle`_ which provides some commands helping you with that. Pushing and Pulling Translations After configuring the credentials to access the translation provider, you can\nnow use the following commands to push (upload) and pull (download) translations: # push all local translations to the Loco provider for the locales and domains\n# configured in config/packages/translation.yaml file.\n# it will update existing translations already on the provider.\n$ php bin/console translation:push loco --force # push new local translations to the Loco provider for the French locale\n# and the validators domain.\n# it will **not** update existing translations already on the provider.\n$ php bin/console translation:push loco --locales fr --domains validators # push new local translations and delete provider's translations that not\n# exists anymore in local files for the French locale and the validators domain.\n# it will **not** update existing translations already on the provider.\n$ php bin/console translation:push loco --delete-missing --locales fr --domains validators", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_7", "source": "translation.rst", "text": "# check out the command help to see its options (format, domains, locales, etc.)\n$ php bin/console translation:push --help # pull all provider's translations to local files for the locales and domains\n# configured in config/packages/translation.yaml file.\n# it will overwrite completely your local files.\n$ php bin/console translation:pull loco --force # pull new translations from the Loco provider to local files for the French\n# locale and the validators domain.\n# it will **not** overwrite your local files, only add new translations.\n$ php bin/console translation:pull loco --locales fr --domains validators # check out the command help to see its options (format, domains, locales, intl-icu, etc.)\n$ php bin/console translation:pull --help # the \"--as-tree\" option will write YAML messages as a tree-like structure instead\n# of flat keys\n$ php bin/console translation:pull loco --force --as-tree Creating Custom Providers In addition to using Symfony's built-in translation providers, you can create\nyour own providers. To do so, you need to create two classes: #. The first class must implement Symfony\\\\Component\\\\Translation\\\\Provider\\\\ProviderInterface;\n#. The second class needs to be a factory which will create instances of the first class. It must implement\nSymfony\\\\Component\\\\Translation\\\\Provider\\\\ProviderFactoryInterface (you can extend Symfony\\\\Component\\\\Translation\\\\Provider\\\\AbstractProviderFactory to simplify its creation). After creating these two classes, you need to register your factory as a service\nand tag it with translation.provider_factory . Handling the User's Locale Translating happens based on the user's locale. The locale of the current user\nis stored in the request and is accessible via the Request object:: use Symfony\\Component\\HttpFoundation\\Request; public function index(Request $request): void\n{\n$locale = $request->getLocale();\n} To set the user's locale, you may want to create a custom event listener so\nthat it's set before any other parts of the system (i.e. the translator) need\nit:: public function onKernelRequest(RequestEvent $event): void\n{\n$request = $event->getRequest(); // some logic to determine the $locale\n$request->setLocale($locale);\n} The custom listener must be called **before** LocaleListener, which\ninitializes the locale based on the current request. To do so, set your\nlistener priority to a higher value than LocaleListener priority (which\nyou can obtain by running the debug:event kernel.request command). Read locale-sticky-session for more information on making the user's\nlocale \"sticky\" to their session. Setting the locale using $request->setLocale() in the controller is\ntoo late to affect the translator. Either set the locale via a listener\n(like above), the URL (see next) or call setLocale() directly on the\ntranslator service. See the translation-locale-url section below about setting the\nlocale via routing. The Locale and the URL Since you can store the locale of the user in the session, it may be tempting\nto use the same URL to display a resource in different languages based on the\nuser's locale. For example, http://www.example.com/contact could show\ncontent in English for one user and French for another user. Unfortunately,\nthis violates a fundamental rule of the Web: that a particular URL returns the\nsame resource regardless of the user. To further muddy the problem, which\nversion of the content would be indexed by search engines?", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_8", "source": "translation.rst", "text": "A better policy is to include the locale in the URL using the\nspecial _locale parameter : // src/Controller/ContactController.php\nnamespace App\\Controller; // ...\nclass ContactController extends AbstractController\n{\n#[Route(\npath: '/{_locale}/contact',\nname: 'contact',\nrequirements: [\n'_locale' => 'en|fr|de',\n],\n)]\npublic function contact(): Response\n{\n// ...\n}\n} # config/routes.yaml\ncontact:\npath: /{_locale}/contact\ncontroller: App\\Controller\\ContactController::index\nrequirements:\n_locale: en|fr|de <!-- config/routes.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/routing\nhttps://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"contact\" path=\"/{_locale}/contact\">\ncontroller=\"App\\Controller\\ContactController::index\">\n<requirement key=\"_locale\">en|fr|de</requirement>\n</route>\n</routes> // config/routes.php\nuse App\\Controller\\ContactController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void {\n$routes->add('contact', '/{_locale}/contact')\n->controller([ContactController::class, 'index'])\n->requirements([\n'_locale' => 'en|fr|de',\n])\n;\n}; When using the special _locale parameter in a route, the matched locale\nis *automatically set on the Request* and can be retrieved via the\nSymfony\\\\Component\\\\HttpFoundation\\\\Request::getLocale method. In\nother words, if a user visits the URI /fr/contact, the locale fr will\nautomatically be set as the locale for the current request. You can now use the locale to create routes to other translated pages in your\napplication. Define the locale requirement as a container parameter\nto avoid hardcoding its value in all your routes. Setting a Default Locale What if the user's locale hasn't been determined? You can guarantee that a\nlocale is set on each user's request by defining a default_locale for\nthe framework: # config/packages/translation.yaml\nframework:\ndefault_locale: en <!-- config/packages/translation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config default-locale=\"en\"/>\n</container> // config/packages/translation.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n$framework->defaultLocale('en');\n}; This default_locale is also relevant for the translator, as shown in the\nnext section. Selecting the Language Preferred by the User If your application supports multiple languages, the first time a user visits your\nsite it's common to redirect them to the best possible language according to their\npreferences. This is achieved with the getPreferredLanguage() method of the\nRequest object :: // get the Request object somehow (e.g. as a controller argument)\n$request = ...\n// pass an array of the locales (their script and region parts are optional) supported\n// by your application and the method returns the best locale for the current user\n$locale = $request->getPreferredLanguage(['pt', 'fr_Latn_CH', 'en_US'] ); Symfony finds the best possible language based on the locales passed as argument\nand the value of the Accept-Language HTTP header. If it can't find a perfect\nmatch between them, Symfony will try to find a partial match based on the language\n(e.g. fr_CA would match fr_Latn_CH because their language is the same).\nIf there's no perfect or partial match, this method returns the first locale passed\nas argument (that's why the order of the passed locales is important). The feature to match locales partially was introduced in Symfony 7.1. Fallback Translation Locales Imagine that the user's locale is es_AR and that you're translating the\nkey Symfony is great. To find the Spanish translation, Symfony actually\nchecks translation resources for several locales:", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_9", "source": "translation.rst", "text": "#. First, Symfony looks for the translation in a es_AR (Argentinean\nSpanish) translation resource (e.g. messages.es_AR.yaml); #. If it wasn't found, Symfony looks for the translation in the\nparent locale, which is automatically defined only for some locales. In\nthis example, the parent locale is es_419 (Latin American Spanish); #. If it wasn't found, Symfony looks for the translation in a es\n(Spanish) translation resource (e.g. messages.es.yaml); #. If the translation still isn't found, Symfony uses the fallbacks option,\nwhich can be configured as follows. When this option is not defined, it\ndefaults to the default_locale setting mentioned in the previous section. # config/packages/translation.yaml\nframework:\ntranslator:\nfallbacks: ['en']\n# ... <!-- config/packages/translation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config>\n<framework:translator>\n<framework:fallback>en</framework:fallback>\n<!-- ... -->\n</framework:translator>\n</framework:config>\n</container> // config/packages/translation.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {\n// ...\n$framework->translator()\n->fallbacks(['en'])\n;\n}; When Symfony can't find a translation in the given locale, it will\nadd the missing translation to the log file. For details,\nsee reference-framework-translator-logging. Switch Locale Programmatically Sometimes you need to change the application's locale dynamically while running\nsome code. For example, a console command that renders email templates in\ndifferent languages. In such cases, you only need to switch the locale temporarily. The LocaleSwitcher class allows you to do that:: use Symfony\\Component\\Translation\\LocaleSwitcher; class SomeService\n{\npublic function __construct(\nprivate LocaleSwitcher $localeSwitcher,\n) {\n} public function someMethod(): void\n{\n$currentLocale = $this->localeSwitcher->getLocale(); // set the application locale programmatically to 'fr' (French):\n// this affects translation, URL generation, etc.\n$this->localeSwitcher->setLocale('fr'); // reset the locale to the default one configured via the\n// 'default_locale' option in config/packages/translation.yaml\n$this->localeSwitcher->reset(); // run some code with a specific locale, temporarily, without\n// changing the locale for the rest of the application\n$this->localeSwitcher->runWithLocale('es', function() {\n// e.g. render templates, send emails, etc. using the 'es' (Spanish) locale\n}); // optionally, receive the current locale as an argument:\n$this->localeSwitcher->runWithLocale('es', function(string $locale) { // here, the $locale argument will be set to 'es' }); // ...\n}\n} The LocaleSwitcher class changes the locale of: * All services tagged with kernel.locale_aware;\n* The default locale set via \\Locale::setDefault();\n* The _locale parameter of the RequestContext service (if available),\nso generated URLs reflect the new locale. The LocaleSwitcher applies the new locale only for the current request,\nand its effect is lost on subsequent requests, such as after a redirect. See how to make the locale persist across requests . When using autowiring , type-hint any controller or\nservice argument with the Symfony\\\\Component\\\\Translation\\\\LocaleSwitcher\nclass to inject the locale switcher service. Otherwise, configure your services\nmanually and inject the translation.locale_switcher service. How to Find Missing or Unused Translation Messages When you work with many translation messages in different languages, it can be\nhard to keep track which translations are missing and which are not used\nanymore. The debug:translation command helps you to find these missing or\nunused translation messages templates:", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_10", "source": "translation.rst", "text": "{# messages can be found when using the trans filter and tag #}\n{% trans %}Symfony is great{% endtrans %} {{ 'Symfony is great'|trans }} The extractors can't find messages translated outside templates (like form\nlabels or controllers) unless using translatable objects\nor calling the trans() method on a translator\n(since Symfony 5.3). Dynamic translations using variables or expressions in\ntemplates are not detected either: {# this translation uses a Twig variable, so it won't be detected #}\n{% set message = 'Symfony is great' %}\n{{ message|trans }} Suppose your application's default_locale is fr and you have configured\nen as the fallback locale (see configuration\nand fallback for\nhow to configure these). And suppose you've already set up some translations\nfor the fr locale: <!-- translations/messages.fr.xlf -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">\n<file source-language=\"en\" datatype=\"plaintext\" original=\"file.ext\">\n<body>\n<trans-unit id=\"1\">\n<source>Symfony is great</source>\n<target>Symfony est génial</target>\n</trans-unit>\n</body>\n</file>\n</xliff> # translations/messages.fr.yaml\nSymfony is great: Symfony est génial // translations/messages.fr.php\nreturn [\n'Symfony is great' => 'Symfony est génial',\n]; and for the en locale: <!-- translations/messages.en.xlf -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">\n<file source-language=\"en\" datatype=\"plaintext\" original=\"file.ext\">\n<body>\n<trans-unit id=\"1\">\n<source>Symfony is great</source>\n<target>Symfony is great</target>\n</trans-unit>\n</body>\n</file>\n</xliff> # translations/messages.en.yaml\nSymfony is great: Symfony is great // translations/messages.en.php\nreturn [\n'Symfony is great' => 'Symfony is great',\n]; To inspect all messages in the fr locale for the application, run: $ php bin/console debug:translation fr --------- ------------------ ---------------------- -------------------------------\nState Id Message Preview (fr) Fallback Message Preview (en)\n--------- ------------------ ---------------------- -------------------------------\nunused Symfony is great Symfony est génial Symfony is great\n--------- ------------------ ---------------------- ------------------------------- It shows you a table with the result when translating the message in the fr\nlocale and the result when the fallback locale en would be used. On top\nof that, it will also show you when the translation is the same as the fallback\ntranslation (this could indicate that the message was not correctly translated).\nFurthermore, it indicates that the message Symfony is great is unused\nbecause it is translated, but you haven't used it anywhere yet. Now, if you translate the message in one of your templates, you will get this\noutput: $ php bin/console debug:translation fr --------- ------------------ ---------------------- -------------------------------\nState Id Message Preview (fr) Fallback Message Preview (en)\n--------- ------------------ ---------------------- -------------------------------\nSymfony is great Symfony est génial Symfony is great\n--------- ------------------ ---------------------- ------------------------------- The state is empty which means the message is translated in the fr locale\nand used in one or more templates. If you delete the message Symfony is great from your translation file\nfor the fr locale and run the command, you will get: $ php bin/console debug:translation fr --------- ------------------ ---------------------- -------------------------------\nState Id Message Preview (fr) Fallback Message Preview (en)\n--------- ------------------ ---------------------- -------------------------------\nmissing Symfony is great Symfony is great Symfony is great\n--------- ------------------ ---------------------- -------------------------------", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_11", "source": "translation.rst", "text": "The state indicates the message is missing because it is not translated in\nthe fr locale but it is still used in the template. Moreover, the message\nin the fr locale equals to the message in the en locale. This is a\nspecial case because the untranslated message id equals its translation in\nthe en locale. If you copy the content of the translation file in the en locale to the\ntranslation file in the fr locale and run the command, you will get: $ php bin/console debug:translation fr ---------- ------------------ ---------------------- -------------------------------\nState Id Message Preview (fr) Fallback Message Preview (en)\n---------- ------------------ ---------------------- -------------------------------\nfallback Symfony is great Symfony is great Symfony is great\n---------- ------------------ ---------------------- ------------------------------- You can see that the translations of the message are identical in the fr\nand en locales which means this message was probably copied from English\nto French and maybe you forgot to translate it. By default, all domains are inspected, but it is possible to specify a single\ndomain: $ php bin/console debug:translation en --domain=messages When the application has a lot of messages, it is useful to display only the\nunused or only the missing messages, by using the --only-unused or\n--only-missing options: $ php bin/console debug:translation en --only-unused\n$ php bin/console debug:translation en --only-missing Debug Command Exit Codes The exit code of the debug:translation command changes depending on the\nstatus of the translations. Use the following public constants to check it:: use Symfony\\Bundle\\FrameworkBundle\\Command\\TranslationDebugCommand; // generic failure (e.g. there are no translations)\nTranslationDebugCommand::EXIT_CODE_GENERAL_ERROR; // there are missing translations\nTranslationDebugCommand::EXIT_CODE_MISSING; // there are unused translations\nTranslationDebugCommand::EXIT_CODE_UNUSED; // some translations are using the fallback translation\nTranslationDebugCommand::EXIT_CODE_FALLBACK; These constants are defined as \"bit masks\", so you can combine them as follows:: if (TranslationDebugCommand::EXIT_CODE_MISSING | TranslationDebugCommand::EXIT_CODE_UNUSED) {\n// ... there are missing and/or unused translations\n} How to Find Errors in Translation Files Symfony processes all the application translation files as part of the process\nthat compiles the application code before executing it. If there's an error in\nany translation file, you'll see an error message explaining the problem. If you prefer, you can also validate the syntax of any YAML and XLIFF\ntranslation file using the lint:yaml and lint:xliff commands: # lint a single file\n$ php bin/console lint:yaml translations/messages.en.yaml\n$ php bin/console lint:xliff translations/messages.en.xlf # lint a whole directory\n$ php bin/console lint:yaml translations\n$ php bin/console lint:xliff translations # lint multiple files or directories\n$ php bin/console lint:yaml translations path/to/trans\n$ php bin/console lint:xliff translations/messages.en.xlf translations/messages.es.xlf The linter results can be exported to JSON using the --format option: $ php bin/console lint:yaml translations/ --format=json\n$ php bin/console lint:xliff translations/ --format=json When running these linters inside `GitHub Actions`_, the output is automatically\nadapted to the format required by GitHub, but you can force that format too: $ php bin/console lint:yaml translations/ --format=github\n$ php bin/console lint:xliff translations/ --format=github The Yaml component provides a stand-alone yaml-lint binary allowing\nyou to lint YAML files without having to create a console application:", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_12", "source": "translation.rst", "text": "$ php vendor/bin/yaml-lint translations/ The lint:yaml and lint:xliff commands validate the YAML and XML syntax\nof the translation files, but not their contents. Use the following command\nto check that the translation contents are also correct: # checks the contents of all the translation catalogues in all locales\n$ php bin/console lint:translations # checks the contents of the translation catalogues for Italian (it) and Japanese (ja) locales\n$ php bin/console lint:translations --locale=it --locale=ja The lint:translations command was introduced in Symfony 7.2. Pseudo-localization translator The pseudolocalization translator is meant to be used for development only. The following image shows a typical menu on a webpage: :alt: A menu showing multiple items nicely aligned next to eachother. This other image shows the same menu when the user switches the language to\nSpanish. Unexpectedly, some text is cut and other contents are so long that\nthey overflow and you can't see them: :alt: In Spanish, some menu items contain more letters which result in them being cut. These kind of errors are very common, because different languages can be longer\nor shorter than the original application language. Another common issue is to\nonly check if the application works when using basic accented letters, instead\nof checking for more complex characters such as the ones found in Polish,\nCzech, etc. These problems can be solved with `pseudolocalization`_, a software testing method\nused for testing internationalization. In this method, instead of translating\nthe text of the software into a foreign language, the textual elements of an\napplication are replaced with an altered version of the original language. For example, Account Settings is *translated* as [!!! Àççôûñţ\nŠéţţîñĝš !!!]. First, the original text is expanded in length with characters\nlike [!!! !!!] to test the application when using languages more verbose\nthan the original one. This solves the first problem. In addition, the original characters are replaced by similar but accented\ncharacters. This makes the text highly readable, while allowing to test the\napplication with all kinds of accented and special characters. This solves the\nsecond problem. Full support for pseudolocalization was added to help you debug\ninternationalization issues in your applications. You can enable and configure\nit in the translator configuration: # config/packages/translation.yaml\nframework:\ntranslator:\npseudo_localization:\n# replace characters by their accented version\naccents: true\n# wrap strings with brackets\nbrackets: true\n# controls how many extra characters are added to make text longer\nexpansion_factor: 1.4\n# maintain the original HTML tags of the translated contents\nparse_html: true\n# also translate the contents of these HTML attributes\nlocalizable_html_attributes: ['title'] <!-- config/packages/translation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:framework=\"http://symfony.com/schema/dic/symfony\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/services\nhttps://symfony.com/schema/dic/services/services-1.0.xsd\nhttp://symfony.com/schema/dic/symfony\nhttps://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_sem_13", "source": "translation.rst", "text": "<framework:config>\n<framework:translator>\n<!-- accents: replace characters by their accented version -->\n<!-- brackets: wrap strings with brackets -->\n<!-- expansion_factor: controls how many extra characters are added to make text longer -->\n<!-- parse_html: maintain the original HTML tags of the translated contents -->\n<framework:pseudo-localization\naccents=\"true\"\nbrackets=\"true\"\nexpansion_factor=\"1.4\"\nparse_html=\"true\"\n>\n<!-- also translate the contents of these HTML attributes -->\n<framework:localizable-html-attribute>title</framework:localizable-html-attribute>\n</framework:pseudo-localization>\n</framework:translator>\n</framework:config>\n</container> // config/packages/translation.php\nuse Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework) {\n// ...\n$framework\n->translator()\n->pseudoLocalization()\n// replace characters by their accented version\n->accents(true)\n// wrap strings with brackets\n->brackets(true)\n// controls how many extra characters are added to make text longer\n->expansionFactor(1.4)\n// maintain the original HTML tags of the translated contents\n->parseHtml(true)\n// also translate the contents of these HTML attributes\n->localizableHtmlAttributes(['title'])\n;\n}; That's all. The application will now start displaying those strange, but\nreadable, contents to help you internationalize it. See for example the\ndifference in the `Symfony Demo`_ application. This is the original page: :alt: The Symfony demo login page.\n:class: with-browser And this is the same page with pseudolocalization enabled: :alt: The Symfony demo login page with pseudolocalization.\n:class: with-browser Summary With the Symfony Translation component, creating an internationalized application\nno longer needs to be a painful process and boils down to these steps: * Abstract messages in your application by wrapping each in the\nSymfony\\\\Component\\\\Translation\\\\Translator::trans method; * Translate each message into multiple locales by creating translation message\nfiles. Symfony discovers and processes each file because its name follows\na specific convention; * Manage the user's locale, which is stored on the request, but can also\nbe set on the user's session. Learn more :maxdepth: 1 reference/formats/message_format\nreference/formats/xliff", "title": "Translations", "category": "translation"}
{"chunk_id": "validation.rst_sem_0", "source": "validation.rst", "text": "Validation Validation is a very common task in web applications. Data entered in forms\nneeds to be validated. Data also needs to be validated before it is written\ninto a database or passed to a web service. Symfony provides a `Validator`_ component to handle this for you. This\ncomponent is based on the `JSR303 Bean Validation specification`_. Installation In applications using Symfony Flex , run this command to\ninstall the validator before using it: $ composer require symfony/validator If your application doesn't use Symfony Flex, you might need to do some\nmanual configuration to enable validation. Check out the\nValidation configuration reference . The Basics of Validation The best way to understand validation is to see it in action. To start, suppose\nyou've created a plain-old-PHP object that you need to use somewhere in\nyour application:: // src/Entity/Author.php\nnamespace App\\Entity; class Author\n{\nprivate string $name;\n} So far, this is an ordinary class that serves some purpose inside your\napplication. The goal of validation is to tell you if the data of an object is\nvalid. For this to work, you'll configure a list of rules (called\nconstraints ) that the object must follow in\norder to be valid. These rules are usually defined using PHP code or\nattributes but they can also be defined as .yaml or .xml files inside\nthe config/validator/ directory: For example, to indicate that the $name property must not be empty, add the\nfollowing: // src/Entity/Author.php\nnamespace App\\Entity; // ...\nuse Symfony\\Component\\Validator\\Constraints as Assert; class Author\n{\n#[Assert\\NotBlank]\nprivate string $name;\n} # config/validator/validation.yaml\nApp\\Entity\\Author:\nproperties:\nname:\n- NotBlank: ~ <!-- config/validator/validation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\nhttps://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Author\">\n<property name=\"name\">\n<constraint name=\"NotBlank\"/>\n</property>\n</class>\n</constraint-mapping> // src/Entity/Author.php\nnamespace App\\Entity;\n// ...\nuse Symfony\\Component\\Validator\\Constraints\\NotBlank;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Author\n{\nprivate string $name; public static function loadValidatorMetadata(ClassMetadata $metadata): void\n{\n$metadata->addPropertyConstraint('name', new NotBlank());\n}\n} Adding this configuration by itself does not yet guarantee that the value will\nnot be blank; you can still set it to a blank value if you want.\nTo actually guarantee that the value adheres to the constraint, the object must\nbe passed to the validator service to be checked. Symfony's validator uses PHP reflection, as well as *\"getter\"* methods, to\nget the value of any property, so they can be public, private or protected\n(see validator-constraint-targets). Using the Validator Service Next, to actually validate an Author object, use the validate() method\non the validator service (which implements Symfony\\\\Component\\\\Validator\\\\Validator\\\\ValidatorInterface).\nThe job of the validator is to read the constraints (i.e. rules)\nof a class and verify if the data on the object satisfies those\nconstraints. If validation fails, a non-empty list of errors\n(Symfony\\\\Component\\\\Validator\\\\ConstraintViolationList class) is\nreturned. Take this simple example from inside a controller:: // ...\nuse App\\Entity\\Author;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface; // ...\npublic function author(ValidatorInterface $validator): Response\n{\n$author = new Author(); // ... do something to the $author object $errors = $validator->validate($author);", "title": "Validation", "category": "validation"}
{"chunk_id": "validation.rst_sem_1", "source": "validation.rst", "text": "if (count($errors) > 0) {\n/*\n* Uses a __toString method on the $errors variable which is a\n* ConstraintViolationList object. This gives us a nice string\n* for debugging.\n*/\n$errorsString = (string) $errors; return new Response($errorsString);\n} return new Response('The author is valid! Yes!');\n} If the $name property is empty, you will see the following error\nmessage: Object(App\\Entity\\Author).name:\nThis value should not be blank. If you insert a value into the name property, the happy success message\nwill appear. Most of the time, you won't interact directly with the validator\nservice or need to worry about printing out the errors. Most of the time,\nyou'll use validation indirectly when handling submitted form data. For\nmore information, see how to validate Symfony forms . You could also pass the collection of errors into a template:: if (count($errors) > 0) {\nreturn $this->render('author/validation.html.twig', [\n'errors' => $errors,\n]);\n} Inside the template, you can output the list of errors exactly as needed: {# templates/author/validation.html.twig #}\n<h3>The author has the following errors</h3>\n<ul>\n{% for error in errors %}\n<li>{{ error.message }}</li>\n{% endfor %}\n</ul> Each validation error (called a \"constraint violation\"), is represented by\na Symfony\\\\Component\\\\Validator\\\\ConstraintViolation object. This\nobject allows you, among other things, to get the constraint that caused this\nviolation thanks to the ConstraintViolation::getConstraint() method. Validation Callables The Validation also allows you to create a closure to validate values\nagainst a set of constraints (useful for example when\nvalidating Console command answers or\nwhen validating OptionsResolver values ): Symfony\\\\Component\\\\Validator\\\\Validation::createCallable\nThis returns a closure that throws ValidationFailedException when the\nconstraints aren't matched.\nSymfony\\\\Component\\\\Validator\\\\Validation::createIsValidCallable\nThis returns a closure that returns false when the constraints aren't matched. Constraints The validator is designed to validate objects against *constraints* (i.e.\nrules). In order to validate an object, simply map one or more constraints\nto its class and then pass it to the validator service. Behind the scenes, a constraint is simply a PHP object that makes an assertive\nstatement. In real life, a constraint could be: 'The cake must not be burned'.\nIn Symfony, constraints are similar: they are assertions that a condition\nis true. Given a value, a constraint will tell you if that value\nadheres to the rules of the constraint. Supported Constraints Symfony packages many of the most commonly-needed constraints: You can also create your own custom constraints. This topic is covered in\nthe /validation/custom_constraint article. Constraint Configuration Some constraints, like NotBlank ,\nare simple whereas others, like the Choice\nconstraint, have several configuration options available. Suppose that the\nAuthor class has another property called genre that defines the\nliterature genre mostly associated with the author, which can be set to either\n\"fiction\" or \"non-fiction\": // src/Entity/Author.php\nnamespace App\\Entity; // ...\nuse Symfony\\Component\\Validator\\Constraints as Assert; class Author\n{\n#[Assert\\Choice(\nchoices: ['fiction', 'non-fiction'],\nmessage: 'Choose a valid genre.',\n)]\nprivate string $genre; // ...\n} # config/validator/validation.yaml\nApp\\Entity\\Author:\nproperties:\ngenre:\n- Choice: { choices: [fiction, non-fiction], message: Choose a valid genre. }\n# ...", "title": "Validation", "category": "validation"}
{"chunk_id": "validation.rst_sem_2", "source": "validation.rst", "text": "<!-- config/validator/validation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\nhttps://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Author\">\n<property name=\"genre\">\n<constraint name=\"Choice\">\n<option name=\"choices\">\n<value>fiction</value>\n<value>non-fiction</value>\n</option>\n<option name=\"message\">Choose a valid genre.</option>\n</constraint>\n</property> <!-- ... -->\n</class>\n</constraint-mapping> // src/Entity/Author.php\nnamespace App\\Entity; // ...\nuse Symfony\\Component\\Validator\\Constraints as Assert;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Author\n{\nprivate string $genre; // ... public static function loadValidatorMetadata(ClassMetadata $metadata): void\n{\n// ... $metadata->addPropertyConstraint('genre', new Assert\\Choice(\nchoices: ['fiction', 'non-fiction'],\nmessage: 'Choose a valid genre.',\n));\n}\n} Constraints in Form Classes Constraints can be defined while building the form via the constraints option\nof the form fields:: public function buildForm(FormBuilderInterface $builder, array $options): void\n{\n$builder\n->add('myField', TextType::class, [\n'required' => true,\n'constraints' => [new Length(['min' => 3])],\n])\n;\n} Constraint Targets Constraints can be applied to a class property (e.g. name),\na getter method (e.g. getFullName()) or an entire class. Property constraints\nare the most common and easy to use. Getter constraints allow you to specify\nmore complex validation rules. Finally, class constraints are intended\nfor scenarios where you want to validate a class as a whole. Properties Validating class properties is the most basic validation technique. Symfony\nallows you to validate private, protected or public properties. The next\nlisting shows you how to configure the $firstName property of an Author\nclass to have at least 3 characters. // src/Entity/Author.php // ...\nuse Symfony\\Component\\Validator\\Constraints as Assert; class Author\n{\n#[Assert\\NotBlank]\n#[Assert\\Length(min: 3)]\nprivate string $firstName;\n} # config/validator/validation.yaml\nApp\\Entity\\Author:\nproperties:\nfirstName:\n- NotBlank: ~\n- Length:\nmin: 3 <!-- config/validator/validation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\nhttps://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Author\">\n<property name=\"firstName\">\n<constraint name=\"NotBlank\"/>\n<constraint name=\"Length\">\n<option name=\"min\">3</option>\n</constraint>\n</property>\n</class>\n</constraint-mapping> // src/Entity/Author.php\nnamespace App\\Entity; // ...\nuse Symfony\\Component\\Validator\\Constraints as Assert;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Author\n{\nprivate string $firstName; public static function loadValidatorMetadata(ClassMetadata $metadata): void\n{\n$metadata->addPropertyConstraint('firstName', new Assert\\NotBlank());\n$metadata->addPropertyConstraint(\n'firstName',\nnew Assert\\Length(min: 3)\n);\n}\n} The validator will use a value null if a typed property is uninitialized.\nThis can cause unexpected behavior if the property holds a value when initialized.\nIn order to avoid this, make sure all properties are initialized before validating them. Getters Constraints can also be applied to the return value of a method. Symfony\nallows you to add a constraint to any private, protected or public method whose name starts with\n\"get\", \"is\" or \"has\". In this guide, these types of methods are referred to\nas \"getters\". The benefit of this technique is that it allows you to validate your object\ndynamically. For example, suppose you want to make sure that a password field\ndoesn't match the first name of the user (for security reasons). You can\ndo this by creating an isPasswordSafe() method, and then asserting that\nthis method must return true: // src/Entity/Author.php\nnamespace App\\Entity; // ...\nuse Symfony\\Component\\Validator\\Constraints as Assert; class Author\n{\n#[Assert\\IsTrue(message: 'The password cannot match your first name')]\npublic function isPasswordSafe(): bool\n{\n// ... return true or false\n}\n}", "title": "Validation", "category": "validation"}
{"chunk_id": "validation.rst_sem_3", "source": "validation.rst", "text": "# config/validator/validation.yaml\nApp\\Entity\\Author:\ngetters:\npasswordSafe:\n- 'IsTrue': { message: 'The password cannot match your first name' } <!-- config/validator/validation.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\nhttps://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Author\">\n<getter property=\"passwordSafe\">\n<constraint name=\"IsTrue\">\n<option name=\"message\">The password cannot match your first name</option>\n</constraint>\n</getter>\n</class>\n</constraint-mapping> // src/Entity/Author.php\nnamespace App\\Entity; // ...\nuse Symfony\\Component\\Validator\\Constraints as Assert;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Author\n{\npublic static function loadValidatorMetadata(ClassMetadata $metadata): void\n{\n$metadata->addGetterConstraint('passwordSafe', new Assert\\IsTrue(\nmessage: 'The password cannot match your first name',\n));\n}\n} Now, create the isPasswordSafe() method and include the logic you need:: public function isPasswordSafe(): bool\n{\nreturn $this->firstName !== $this->password;\n} The keen-eyed among you will have noticed that the prefix of the getter\n(\"get\", \"is\" or \"has\") is omitted in the mappings for the YAML, XML and PHP\nformats. This allows you to move the constraint to a property with the same\nname later (or vice versa) without changing your validation logic. Classes Some constraints apply to the entire class being validated. For example,\nthe Callback constraint is a generic\nconstraint that's applied to the class itself. When that class is validated,\nmethods specified by that constraint are simply executed so that each can\nprovide more custom validation. Validating Object With Inheritance When you validate an object that extends another class, the validator\nautomatically validates constraints defined in the parent class as well. **The constraints defined in the parent properties will be applied to the child\nproperties even if the child properties override those constraints**. Symfony\nwill always merge the parent constraints for each property. You can't change this behavior, but you can overcome it by defining the parent\nand the child constraints in different validation groups\nand then select the appropriate group when validating each object. Debugging the Constraints Use the debug:validator command to list the validation constraints of a\ngiven class: $ php bin/console debug:validator 'App\\Entity\\SomeClass' App\\Entity\\SomeClass | Property | Name | Groups | Options |\n| firstArgument | Symfony\\Component\\Validator\\Constraints\\NotBlank | Default | [ |\n| | | | \"message\" => \"This value should not be blank.\", |\n| | | | \"allowNull\" => false, |\n| | | | \"normalizer\" => null, |\n| | | | \"payload\" => null |\n| | | | ] |\n| firstArgument | Symfony\\Component\\Validator\\Constraints\\Email | Default | [ |\n| | | | \"message\" => \"This value is not a valid email address.\", |\n| | | | \"mode\" => null, |\n| | | | \"normalizer\" => null, |\n| | | | \"payload\" => null |\n| | | | ] | You can also validate all the classes stored in a given directory: $ php bin/console debug:validator src/Entity Final Thoughts", "title": "Validation", "category": "validation"}
{"chunk_id": "validation.rst_sem_4", "source": "validation.rst", "text": "The Symfony validator is a powerful tool that can be leveraged to\nguarantee that the data of any object is \"valid\". The power behind validation\nlies in \"constraints\", which are rules that you can apply to properties or\ngetter methods of your object. And while you'll most commonly use the validation\nframework indirectly when using forms, remember that it can be used anywhere\nto validate any object. Learn more :maxdepth: 1\n:glob: /validation/*", "title": "Validation", "category": "validation"}
