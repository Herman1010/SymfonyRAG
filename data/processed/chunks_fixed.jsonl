{"chunk_id": "best_practices.rst_fixed_0", "source": "best_practices.rst", "text": "The Symfony Framework Best Practices This article describes the **best practices for developing web applications with Symfony** that fit the philosophy envisioned by the original Symfony creators. If you don't agree with some of these recommendations, they might be a good **starting point** that you can then **extend and fit to your specific needs**. You can even ignore them completely and continue using your own best practices and methodologies. Symfony is flexible enough to adapt to your needs. This article assumes that you already have experience developing Symfony applications. If you don't, first read the Getting Started section of the documentation. Symfony provides a sample application called `Symfony Demo`_ that follows all these best practices, so you can experience them in practice. Creating the Project Use the Symfony Binary to Create Symfony Applications The Symfony binary is an executable command created in your machine when you `download Symfony`_. It provides multiple utilities, including the simplest way to create new Symfony applications: $ symfony new my_project_directory Under the hood, this Symfony binary command executes the needed `Composer`_ command to create a new Symfony application based on the current stable version. Use the Default Directory Structure Unless your project follows a development practice that imposes a certain directory structure, follow the default Symfony directory structure. It's flat, self-explanatory and not coupled to Symfony: your_project/ ├─ assets/ ├─ bin/ │ └─ console ├─ config/ │ ├─ packages/ │ ├─ routes/ │ └─ services.yaml ├─ migrations/ ├─ public/ │ ├─ build/ │ └─ index.php ├─ src/ │ ├─ Kernel.php │ ├─ Command/ │ ├─ Controller/ │ ├─ DataFixtures/ │ ├─ Entity/ │ ├─ EventSubscriber/ │ ├─ Form/ │ ├─ Repository/ │ ├─ Security/ │ └─ Twig/ ├─ templates/ ├─ tests/ ├─ translations/ ├─ var/ │ ├─ cache/ │ └─ log/ └─ vendor/ Configuration Use Environment Variables for Infrastructure Configuration The values of these options change from one machine to another (e.g. from your development machine to the production server), but they don't modify the application behavior. Use env vars in your project to define these options and create multiple .env files to configure env vars per environment . Use Secrets for Sensitive Information When your application has sensitive configuration, like an API key, you should store those securely via Symfony's secrets management system . Use Parameters for Application Configuration These are the options used to modify the application behavior, such as the sender of email notifications, or the enabled `feature toggles`_. Their value doesn't change per machine, so don't define them as environment variables. Define these options as parameters in the config/services.yaml file. You can override these options per environment in the config/services_dev.yaml and config/services_prod.yaml files. Unless the application configuration is reused multiple times and needs rigid validation, do *not* use the Config component to define the options. Use Short and Prefixed Parameter Names Consider using app. as the prefix of your parameters to avoid collisions with Symfony and third-party bundles/libraries parameters. Then, use only one or two words to describe the purpose of", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "best_practices.rst_fixed_1", "source": "best_practices.rst", "text": "email notifications, or the enabled `feature toggles`_. Their value doesn't change per machine, so don't define them as environment variables. Define these options as parameters in the config/services.yaml file. You can override these options per environment in the config/services_dev.yaml and config/services_prod.yaml files. Unless the application configuration is reused multiple times and needs rigid validation, do *not* use the Config component to define the options. Use Short and Prefixed Parameter Names Consider using app. as the prefix of your parameters to avoid collisions with Symfony and third-party bundles/libraries parameters. Then, use only one or two words to describe the purpose of the parameter: # config/services.yaml parameters: # don't do this: 'dir' is too generic, and it doesn't convey any meaning app.dir: '...' # do this: short but easy to understand names app.contents_dir: '...' # it's OK to use dots, underscores, dashes or nothing, but always # be consistent and use the same format for all the parameters app.dir.contents: '...' app.contents-dir: '...' Use Constants to Define Options that Rarely Change Configuration options like the number of items to display in some listing rarely change. Instead of defining them as configuration parameters , define them as PHP constants in the related classes. Example:: // src/Entity/Post.php namespace App\\Entity; class Post { public const NUMBER_OF_ITEMS = 10; // ... } The main advantage of constants is that you can use them everywhere, including Twig templates and Doctrine entities, whereas parameters are only available from places with access to the service container . The only notable disadvantage of using constants for this kind of configuration values is that it's complicated to redefine their values in your tests. Business Logic Don't Create any Bundle to Organize your Application Logic When Symfony 2.0 was released, applications used bundles to divide their code into logical features: UserBundle, ProductBundle, InvoiceBundle, etc. However, a bundle is meant to be something that can be reused as a stand-alone piece of software. If you need to reuse some feature in your projects, create a bundle for it (in a private repository, do not make it publicly available). For the rest of your application code, use PHP namespaces to organize code instead of bundles. Use Autowiring to Automate the Configuration of Application Services Service autowiring is a feature that reads the type-hints on your constructor (or other methods) and automatically passes the correct services to each method, making it unnecessary to configure services explicitly and simplifying the application maintenance. Use it in combination with service autoconfiguration to also add service tags to the services needing them, such as Twig extensions, event subscribers, etc. Services Should be Private Whenever Possible Make services private to prevent you from accessing those services via $container->get(). Instead, you will need to use proper dependency injection. Use the YAML Format to Configure your own Services If you use the default services.yaml configuration , most services will be configured automatically. However, in some edge cases you'll need to configure services (or parts of them) manually. YAML is the format recommended configuring", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "best_practices.rst_fixed_2", "source": "best_practices.rst", "text": "and simplifying the application maintenance. Use it in combination with service autoconfiguration to also add service tags to the services needing them, such as Twig extensions, event subscribers, etc. Services Should be Private Whenever Possible Make services private to prevent you from accessing those services via $container->get(). Instead, you will need to use proper dependency injection. Use the YAML Format to Configure your own Services If you use the default services.yaml configuration , most services will be configured automatically. However, in some edge cases you'll need to configure services (or parts of them) manually. YAML is the format recommended configuring services because it's friendly to newcomers and concise, but Symfony also supports XML and PHP configuration. Use Attributes to Define the Doctrine Entity Mapping Doctrine entities are plain PHP objects that you store in some \"database\". Doctrine only knows about your entities through the mapping metadata configured for your model classes. Doctrine supports several metadata formats, but it's recommended to use PHP attributes because they are by far the most convenient and agile way of setting up and looking for mapping information. Controllers Make your Controller Extend the AbstractController Base Controller Symfony provides a base controller which includes shortcuts for the most common needs such as rendering templates or checking security permissions. Extending your controllers from this base controller couples your application to Symfony. Coupling is generally wrong, but it may be OK in this case because controllers shouldn't contain any business logic. Controllers should contain nothing more than a few lines of *glue-code*, so you are not coupling the important parts of your application. Use Attributes to Configure Routing, Caching, and Security Using attributes for routing, caching, and security simplifies configuration. You don't need to browse several files created with different formats (YAML, XML, PHP): all the configuration is just where you require it, and it only uses one format. Use Dependency Injection to Get Services If you extend the base AbstractController, you can only get access to the most common services (e.g twig, router, doctrine, etc.), directly from the container via $this->container->get(). Instead, you must use dependency injection to fetch services by type-hinting action method arguments or constructor arguments. Use Entity Value Resolvers If They Are Convenient If you're using Doctrine , then you can *optionally* use the EntityValueResolver to automatically query for an entity and pass it as an argument to your controller. It will also show a 404 page if no entity can be found. If the logic to get an entity from a route variable is more complex, instead of configuring the EntityValueResolver, it's better to make the Doctrine query inside the controller (e.g. by calling to a Doctrine repository method ). Templates Use Snake Case for Template Names and Variables Use lowercase snake_case for template names, directories, and variables (e.g. user_profile instead of userProfile and product/edit_form.html.twig instead of Product/EditForm.html.twig). Prefix Template Fragments with an Underscore Template fragments, also called *\"partial templates\"*, allow to reuse template contents . Prefix their names with an underscore to", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "best_practices.rst_fixed_3", "source": "best_practices.rst", "text": "a 404 page if no entity can be found. If the logic to get an entity from a route variable is more complex, instead of configuring the EntityValueResolver, it's better to make the Doctrine query inside the controller (e.g. by calling to a Doctrine repository method ). Templates Use Snake Case for Template Names and Variables Use lowercase snake_case for template names, directories, and variables (e.g. user_profile instead of userProfile and product/edit_form.html.twig instead of Product/EditForm.html.twig). Prefix Template Fragments with an Underscore Template fragments, also called *\"partial templates\"*, allow to reuse template contents . Prefix their names with an underscore to better differentiate them from complete templates (e.g. _user_metadata.html.twig or _caution_message.html.twig). Forms Define your Forms as PHP Classes Creating forms in classes allows reusing them in different parts of the application. Besides, not creating forms in controllers simplifies the code and maintenance of the controllers. Add Form Buttons in Templates Form classes should be agnostic to where they will be used. For example, the button of a form used to both create and edit items should change from \"Add new\" to \"Save changes\" depending on where it's used. Instead of adding buttons in form classes or the controllers, it's recommended to add buttons in the templates. This also improves the separation of concerns because the button styling (CSS class and other attributes) is defined in the template instead of in a PHP class. However, if you create a form with multiple submit buttons you should define them in the controller instead of the template. Otherwise, you won't be able to check which button was clicked when handling the form in the controller. Define Validation Constraints on the Underlying Object Attaching validation constraints to form fields instead of to the mapped object prevents the validation from being reused in other forms or other places where the object is used. Use a Single Action to Render and Process the Form Rendering forms and processing forms are two of the main tasks when handling forms. Both are too similar (most of the time, almost identical), so it's much simpler to let a single controller action handle both. Internationalization Use the XLIFF Format for Your Translation Files Of all the translation formats supported by Symfony (PHP, Qt, .po, .mo, JSON, CSV, INI, etc.), XLIFF and gettext have the best support in the tools used by professional translators. And since it's based on XML, you can validate XLIFF file contents as you write them. Symfony also supports notes in XLIFF files, making them more user-friendly for translators. At the end, good translations are all about context, and these XLIFF notes allow you to define that context. Use Keys for Translations Instead of Content Strings Using keys simplifies the management of the translation files because you can change the original contents in templates, controllers, and services without having to update all the translation files. Keys should always describe their *purpose* and *not* their location. For example, if a form has a field with the label \"Username\", then", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "best_practices.rst_fixed_4", "source": "best_practices.rst", "text": "validate XLIFF file contents as you write them. Symfony also supports notes in XLIFF files, making them more user-friendly for translators. At the end, good translations are all about context, and these XLIFF notes allow you to define that context. Use Keys for Translations Instead of Content Strings Using keys simplifies the management of the translation files because you can change the original contents in templates, controllers, and services without having to update all the translation files. Keys should always describe their *purpose* and *not* their location. For example, if a form has a field with the label \"Username\", then a nice key would be label.username, *not* edit_form.label.username. Security Define a Single Firewall Unless you have two legitimately different authentication systems and users (e.g. form login for the main site and a token system for your API only), it's recommended to have only one firewall to keep things simple. Use the auto Password Hasher The auto password hasher automatically selects the best possible encoder/hasher depending on your PHP installation. Currently, the default auto hasher is bcrypt. Use Voters to Implement Fine-grained Security Restrictions If your security logic is complex, you should create custom security voters instead of defining long expressions inside the #[Security] attribute. Web Assets Use AssetMapper to Manage Web Assets Web assets are the CSS, JavaScript, and image files that make the frontend of your site look and work great. AssetMapper lets you write modern JavaScript and CSS without the complexity of using a bundler such as `Webpack`_ (directly or via Webpack Encore ). Tests Smoke Test your URLs In software engineering, `smoke testing`_ consists of *\"preliminary testing to reveal simple failures severe enough to reject a prospective software release\"*. Using `PHPUnit data providers`_ you can define a functional test that checks that all application URLs load successfully:: // tests/ApplicationAvailabilityFunctionalTest.php namespace App\\Tests; use PHPUnit\\Framework\\Attributes\\DataProvider; use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase; class ApplicationAvailabilityFunctionalTest extends WebTestCase { #[DataProvider('urlProvider')] public function testPageIsSuccessful($url): void { $client = self::createClient(); $client->request('GET', $url); $this->assertResponseIsSuccessful(); } public static function urlProvider(): \\Generator { yield ['/']; yield ['/posts']; yield ['/post/fixture-post-1']; yield ['/blog/category/fixture-category']; yield ['/archives']; // ... } } Add this test while creating your application because it requires little effort and checks that none of your pages returns an error. Later, you'll add more specific tests for each page. Hard-code URLs in a Functional Test In Symfony applications, it's recommended to generate URLs using routes to automatically update all links when a URL changes. However, if a public URL changes, users won't be able to browse it unless you set up a redirection to the new URL. That's why it's recommended to use raw URLs in tests instead of generating them from routes. Whenever a route changes, tests will fail, and you'll know that you must set up a redirection.", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "best_practices.rst_fixed_5", "source": "best_practices.rst", "text": "URL changes. However, if a public URL changes, users won't be able to browse it unless you set up a redirection to the new URL. That's why it's recommended to use raw URLs in tests instead of generating them from routes. Whenever a route changes, tests will fail, and you'll know that you must set up a redirection.", "title": "The Symfony Framework Best Practices", "category": "best_practices"}
{"chunk_id": "bundles.rst_fixed_0", "source": "bundles.rst", "text": "The Bundle System In Symfony versions prior to 4.0, it was recommended to organize your own application code using bundles. This is no longer recommended and bundles should only be used to share code and features between multiple applications. Do you prefer video tutorials? Check out the `Symfony Bundle Development screencast series`_. A bundle is similar to a plugin in other software, but even better. The core features of Symfony framework are implemented with bundles (FrameworkBundle, SecurityBundle, DebugBundle, etc.) Bundles are also used to add new features in your application via `third-party bundles`_. Bundles used in your applications must be enabled per environment in the config/bundles.php file:: // config/bundles.php return [ // 'all' means that the bundle is enabled for any Symfony environment Symfony\\Bundle\\FrameworkBundle\\FrameworkBundle::class => ['all' => true], // ... // this bundle is enabled only in 'dev' Symfony\\Bundle\\DebugBundle\\DebugBundle::class => ['dev' => true], // ... // this bundle is enabled only in 'dev' and 'test', so you can't use it in 'prod' Symfony\\Bundle\\WebProfilerBundle\\WebProfilerBundle::class => ['dev' => true, 'test' => true], // ... ]; In a default Symfony application that uses Symfony Flex , bundles are enabled/disabled automatically for you when installing/removing them, so you don't need to look at or edit this bundles.php file. Creating a Bundle This section creates and enables a new bundle to show that only a few steps are required. The new bundle is called AcmeBlogBundle, where the Acme portion is an example name that should be replaced by some \"vendor\" name that represents you or your organization (e.g. AbcBlogBundle for some company named Abc). Start by creating a new class called AcmeBlogBundle:: // src/AcmeBlogBundle.php namespace Acme\\BlogBundle; use Symfony\\Component\\HttpKernel\\Bundle\\AbstractBundle; class AcmeBlogBundle extends AbstractBundle { } If your bundle must be compatible with previous Symfony versions you have to extend from the Symfony\\\\Component\\\\HttpKernel\\\\Bundle\\\\Bundle instead. The name AcmeBlogBundle follows the standard Bundle naming conventions . You could also choose to shorten the name of the bundle to simply BlogBundle by naming this class BlogBundle (and naming the file BlogBundle.php). This empty class is the only piece you need to create the new bundle. Though commonly empty, this class is powerful and can be used to customize the behavior of the bundle. Now that you've created the bundle, enable it:: // config/bundles.php return [ // ... Acme\\BlogBundle\\AcmeBlogBundle::class => ['all' => true], ]; And while it doesn't do anything yet, AcmeBlogBundle is now ready to be used. Bundle Directory Structure The directory structure of a bundle is meant to help to keep code consistent between all Symfony bundles. It follows a set of conventions, but is flexible to be adjusted if needed: assets/ Contains the web asset sources like JavaScript and TypeScript files, CSS and Sass files, but also images and other assets related to the bundle that are not in public/ (e.g. Stimulus controllers). config/ Houses configuration, including routing configuration (e.g. routes.php). public/ Contains web assets (images, compiled CSS and JavaScript files, etc.) and is copied or symbolically linked into the project public/ directory via the assets:install console command.", "title": "The Bundle System", "category": "bundles"}
{"chunk_id": "bundles.rst_fixed_1", "source": "bundles.rst", "text": "The directory structure of a bundle is meant to help to keep code consistent between all Symfony bundles. It follows a set of conventions, but is flexible to be adjusted if needed: assets/ Contains the web asset sources like JavaScript and TypeScript files, CSS and Sass files, but also images and other assets related to the bundle that are not in public/ (e.g. Stimulus controllers). config/ Houses configuration, including routing configuration (e.g. routes.php). public/ Contains web assets (images, compiled CSS and JavaScript files, etc.) and is copied or symbolically linked into the project public/ directory via the assets:install console command. src/ Contains all PHP classes related to the bundle logic (e.g. Controller/CategoryController.php). templates/ Holds templates organized by controller name (e.g. category/show.html.twig). tests/ Holds all tests for the bundle. translations/ Holds translations organized by domain and locale (e.g. AcmeBlogBundle.en.xlf). The recommended bundle structure was changed in Symfony 5, read the `Symfony 4.4 bundle documentation`_ for information about the old structure. When using the new AbstractBundle class, the bundle defaults to the new structure. Override the Bundle::getPath() method to change to the old structure:: class AcmeBlogBundle extends AbstractBundle { public function getPath(): string { return __DIR__; } } It's recommended to use the `PSR-4`_ autoload standard on your bundle's composer.json file. Use the namespace as key, and the location of the bundle's main class (relative to composer.json) as value. As the main class is located in the src/ directory of the bundle: { \"autoload\": { \"psr-4\": { \"Acme\\\\BlogBundle\\\\\": \"src/\" } }, \"autoload-dev\": { \"psr-4\": { \"Acme\\\\BlogBundle\\\\Tests\\\\\": \"tests/\" } } } Developing a Reusable Bundle Bundles are meant to be reusable pieces of code that live independently from any particular Symfony application. However, a bundle cannot run on its own: it must be registered inside an application to execute its code. This can be a bit challenging during development. When working on a bundle in its own repository, there's no Symfony application around it, so you need a way to test your changes inside a real application environment. There are two common approaches to do this, depending on whether your bundle has already been published or is still under development. Using a Local Path Repository If your bundle hasn't been published yet (for example, it's not available on Packagist), you can point Composer to your local bundle directory from any Symfony application you use for testing. Edit the composer.json file of your application and add this: { \"repositories\": [ { \"type\": \"path\", \"url\": \"/path/to/your/AcmeBlogBundle\" } ], \"require\": { \"acme/blog-bundle\": \"*\" } } Then, in your application, install the bundle as usual: $ composer require acme/blog-bundle Composer will create a symbolic link (symlink) to your local bundle directory, so any change you make in the AcmeBlogBundle/ directory is immediately visible in the application. You can now enable the bundle in config/bundles.php:: return [ // ... Acme\\BlogBundle\\AcmeBlogBundle::class => ['all' => true], ]; This setup is ideal during early development because it allows quick iteration without publishing or rebuilding archives. Linking an Already Published Bundle If", "title": "The Bundle System", "category": "bundles"}
{"chunk_id": "bundles.rst_fixed_2", "source": "bundles.rst", "text": "and add this: { \"repositories\": [ { \"type\": \"path\", \"url\": \"/path/to/your/AcmeBlogBundle\" } ], \"require\": { \"acme/blog-bundle\": \"*\" } } Then, in your application, install the bundle as usual: $ composer require acme/blog-bundle Composer will create a symbolic link (symlink) to your local bundle directory, so any change you make in the AcmeBlogBundle/ directory is immediately visible in the application. You can now enable the bundle in config/bundles.php:: return [ // ... Acme\\BlogBundle\\AcmeBlogBundle::class => ['all' => true], ]; This setup is ideal during early development because it allows quick iteration without publishing or rebuilding archives. Linking an Already Published Bundle If your bundle is already public (for example, it's published on Packagist), you can still develop it locally while testing it inside a Symfony application. In your application, replace the installed bundle with a symlink to your local development copy. For example, if your bundle is installed under vendor/acme/blog-bundle/ and your local copy is in ~/Projects/AcmeBlogBundle/: $ rm -rf vendor/acme/blog-bundle/ $ ln -s ~/Projects/AcmeBlogBundle/ vendor/acme/blog-bundle Symfony will now use your local bundle directly. You can edit its code, run tests, and see the changes immediately. When you're done, restore the vendor folder or reinstall the package with Composer to go back to the published version. Learn more * /bundles/override * /bundles/best_practices * /bundles/configuration * /bundles/extension * /bundles/prepend_extension", "title": "The Bundle System", "category": "bundles"}
{"chunk_id": "cache.rst_fixed_0", "source": "cache.rst", "text": "Cache Using a cache is a great way of making your application run quicker. The Symfony cache component ships with many adapters to different storages. Every adapter is developed for high performance. The following example shows a typical usage of the cache:: use Symfony\\Contracts\\Cache\\ItemInterface; // The callable will only be executed on a cache miss. $value = $pool->get('my_cache_key', function (ItemInterface $item): string { $item->expiresAfter(3600); // ... do some HTTP request or heavy computations $computedValue = 'foobar'; return $computedValue; }); echo $value; // 'foobar' // ... and to remove the cache key $pool->delete('my_cache_key'); Symfony supports Cache Contracts and PSR-6/16 interfaces. You can read more about these at the component documentation . Configuring Cache with FrameworkBundle When configuring the cache component there are a few concepts you should know: **Pool** This is a service that you will interact with. Each pool will always have its own namespace and cache items. There are never conflicts between pools. **Adapter** An adapter is a *template* that you use to create pools. **Provider** A provider is a service that some adapters use to connect to the storage. Redis and Memcached are examples of such adapters. If a DSN is used as the provider then a service is automatically created. There are two pools that are always enabled by default. They are cache.app and cache.system. The system cache is used for things like annotations, serializer, and validation. The cache.app can be used in your code. You can configure which adapter (template) they use by using the app and system key like: # config/packages/cache.yaml framework: cache: app: cache.adapter.filesystem system: cache.adapter.system <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <framework:cache app=\"cache.adapter.filesystem\" system=\"cache.adapter.system\" /> </framework:config> </container> // config/packages/cache.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->cache() ->app('cache.adapter.filesystem') ->system('cache.adapter.system') ; }; While it is possible to reconfigure the system cache, it's recommended to keep the default configuration applied to it by Symfony. The Cache component comes with a series of adapters pre-configured: * cache.adapter.apcu * cache.adapter.array * cache.adapter.doctrine_dbal * cache.adapter.filesystem * cache.adapter.memcached * cache.adapter.pdo * cache.adapter.psr6 * cache.adapter.redis * cache.adapter.redis_tag_aware (Redis adapter optimized to work with tags) There's also a special cache.adapter.system adapter. It's recommended to use it for the system cache . This adapter uses some logic to dynamically select the best possible storage based on your system (either PHP files or APCu). Some of these adapters could be configured via shortcuts. # config/packages/cache.yaml framework: cache: directory: '%kernel.cache_dir%/pools' # Only used with cache.adapter.filesystem default_doctrine_dbal_provider: 'doctrine.dbal.default_connection' default_psr6_provider: 'app.my_psr6_service' default_redis_provider: 'redis://localhost' default_memcached_provider: 'memcached://localhost' default_pdo_provider: 'pgsql:host=localhost' <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <!-- \"directory\" attribute is only used with cache.adapter.filesystem --> <framework:cache directory=\"%kernel.cache_dir%/pools\" default-doctrine-dbal-provider=\"doctrine.dbal.default_connection\" default-psr6-provider=\"app.my_psr6_service\" default-redis-provider=\"redis://localhost\" default-memcached-provider=\"memcached://localhost\" default-pdo-provider=\"pgsql:host=localhost\" /> </framework:config> </container> // config/packages/cache.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->cache() // Only used with cache.adapter.filesystem ->directory('%kernel.cache_dir%/pools') ->defaultDoctrineDbalProvider('doctrine.dbal.default_connection') ->defaultPsr6Provider('app.my_psr6_service') ->defaultRedisProvider('redis://localhost') ->defaultMemcachedProvider('memcached://localhost') ->defaultPdoProvider('pgsql:host=localhost') ; }; Using a DSN as the provider for the PDO adapter was introduced in Symfony 7.1.", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_fixed_1", "source": "cache.rst", "text": "configured via shortcuts. # config/packages/cache.yaml framework: cache: directory: '%kernel.cache_dir%/pools' # Only used with cache.adapter.filesystem default_doctrine_dbal_provider: 'doctrine.dbal.default_connection' default_psr6_provider: 'app.my_psr6_service' default_redis_provider: 'redis://localhost' default_memcached_provider: 'memcached://localhost' default_pdo_provider: 'pgsql:host=localhost' <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <!-- \"directory\" attribute is only used with cache.adapter.filesystem --> <framework:cache directory=\"%kernel.cache_dir%/pools\" default-doctrine-dbal-provider=\"doctrine.dbal.default_connection\" default-psr6-provider=\"app.my_psr6_service\" default-redis-provider=\"redis://localhost\" default-memcached-provider=\"memcached://localhost\" default-pdo-provider=\"pgsql:host=localhost\" /> </framework:config> </container> // config/packages/cache.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->cache() // Only used with cache.adapter.filesystem ->directory('%kernel.cache_dir%/pools') ->defaultDoctrineDbalProvider('doctrine.dbal.default_connection') ->defaultPsr6Provider('app.my_psr6_service') ->defaultRedisProvider('redis://localhost') ->defaultMemcachedProvider('memcached://localhost') ->defaultPdoProvider('pgsql:host=localhost') ; }; Using a DSN as the provider for the PDO adapter was introduced in Symfony 7.1. Creating Custom (Namespaced) Pools You can also create more customized pools: # config/packages/cache.yaml framework: cache: default_memcached_provider: 'memcached://localhost' pools: # creates a \"custom_thing.cache\" service # autowireable via \"CacheInterface $customThingCache\" # uses the \"app\" cache configuration custom_thing.cache: adapter: cache.app # creates a \"my_cache_pool\" service # autowireable via \"CacheInterface $myCachePool\" my_cache_pool: adapter: cache.adapter.filesystem # uses the default_memcached_provider from above acme.cache: adapter: cache.adapter.memcached # control adapter's configuration foobar.cache: adapter: cache.adapter.memcached provider: 'memcached://user:password@example.com' # uses the \"foobar.cache\" pool as its backend but controls # the lifetime and (like all pools) has a separate cache namespace short_cache: adapter: foobar.cache default_lifetime: 60 <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <framework:cache default-memcached-provider=\"memcached://localhost\"> <!-- creates a \"custom_thing.cache\" service autowireable via \"CacheInterface $customThingCache\" uses the \"app\" cache configuration --> <framework:pool name=\"custom_thing.cache\" adapter=\"cache.app\"/> <!-- creates a \"my_cache_pool\" service autowireable via \"CacheInterface $myCachePool\" --> <framework:pool name=\"my_cache_pool\" adapter=\"cache.adapter.filesystem\"/> <!-- uses the default_memcached_provider from above --> <framework:pool name=\"acme.cache\" adapter=\"cache.adapter.memcached\"/> <!-- control adapter's configuration --> <framework:pool name=\"foobar.cache\" adapter=\"cache.adapter.memcached\" provider=\"memcached://user:password@example.com\" /> <!-- uses the \"foobar.cache\" pool as its backend but controls the lifetime and (like all pools) has a separate cache namespace --> <framework:pool name=\"short_cache\" adapter=\"foobar.cache\" default-lifetime=\"60\"/> </framework:cache> </framework:config> </container> // config/packages/cache.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $cache = $framework->cache(); $cache->defaultMemcachedProvider('memcached://localhost'); // creates a \"custom_thing.cache\" service // autowireable via \"CacheInterface $customThingCache\" // uses the \"app\" cache configuration $cache->pool('custom_thing.cache') ->adapters(['cache.app']); // creates a \"my_cache_pool\" service // autowireable via \"CacheInterface $myCachePool\" $cache->pool('my_cache_pool') ->adapters(['cache.adapter.filesystem']); // uses the default_memcached_provider from above $cache->pool('acme.cache') ->adapters(['cache.adapter.memcached']); // control adapter's configuration $cache->pool('foobar.cache') ->adapters(['cache.adapter.memcached']) ->provider('memcached://user:password@example.com'); $cache->pool('short_cache') ->adapters(['foobar.cache']) ->defaultLifetime(60); }; Each pool manages a set of independent cache keys: keys from different pools *never* collide, even if they share the same backend. This is achieved by prefixing keys with a namespace that's generated by hashing the name of the pool, the name of the cache adapter class and a configurable seed that defaults to the project directory and compiled container class. Each custom pool becomes a service whose service ID is the name of the pool (e.g. custom_thing.cache). An autowiring alias is also created for each pool using the camel case version of its name - e.g. custom_thing.cache can be injected automatically by naming the argument $customThingCache and type-hinting it with either Symfony\\\\Contracts\\\\Cache\\\\CacheInterface or Psr\\Cache\\CacheItemPoolInterface:: use Symfony\\Contracts\\Cache\\CacheInterface; // ... // from a controller method public function listProducts(CacheInterface $customThingCache): Response { // ... } // in a service public function __construct(private CacheInterface $customThingCache)", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_fixed_2", "source": "cache.rst", "text": "of the cache adapter class and a configurable seed that defaults to the project directory and compiled container class. Each custom pool becomes a service whose service ID is the name of the pool (e.g. custom_thing.cache). An autowiring alias is also created for each pool using the camel case version of its name - e.g. custom_thing.cache can be injected automatically by naming the argument $customThingCache and type-hinting it with either Symfony\\\\Contracts\\\\Cache\\\\CacheInterface or Psr\\Cache\\CacheItemPoolInterface:: use Symfony\\Contracts\\Cache\\CacheInterface; // ... // from a controller method public function listProducts(CacheInterface $customThingCache): Response { // ... } // in a service public function __construct(private CacheInterface $customThingCache) { // ... } If you need the namespace to be interoperable with a third-party app, you can take control over auto-generation by setting the namespace attribute of the cache.pool service tag. For example, you can override the service definition of the adapter: # config/services.yaml services: # ... app.cache.adapter.redis: parent: 'cache.adapter.redis' tags: - { name: 'cache.pool', namespace: 'my_custom_namespace' } <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\" > <services> <!-- ... --> <service id=\"app.cache.adapter.redis\" parent=\"cache.adapter.redis\"> <tag name=\"cache.pool\" namespace=\"my_custom_namespace\"/> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void { $container->services() // ... ->set('app.cache.adapter.redis') ->parent('cache.adapter.redis') ->tag('cache.pool', ['namespace' => 'my_custom_namespace']) ; }; Custom Provider Options Some providers have specific options that can be configured. The RedisAdapter allows you to create providers with the options timeout, retry_interval. etc. To use these options with non-default values you need to create your own \\Redis provider and use that when configuring the pool. # config/packages/cache.yaml framework: cache: pools: cache.my_redis: adapter: cache.adapter.redis provider: app.my_custom_redis_provider services: app.my_custom_redis_provider: class: \\Redis factory: ['Symfony\\Component\\Cache\\Adapter\\RedisAdapter', 'createConnection'] arguments: - 'redis://localhost' - { retry_interval: 2, timeout: 10 } <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <framework:cache> <framework:pool name=\"cache.my_redis\" adapter=\"cache.adapter.redis\" provider=\"app.my_custom_redis_provider\" /> </framework:cache> </framework:config> <services> <service id=\"app.my_custom_redis_provider\" class=\"\\Redis\"> <factory class=\"Symfony\\Component\\Cache\\Adapter\\RedisAdapter\" method=\"createConnection\"/> <argument>redis://localhost</argument> <argument type=\"collection\"> <argument key=\"retry_interval\">2</argument> <argument key=\"timeout\">10</argument> </argument> </service> </services> </container> // config/packages/cache.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\Cache\\Adapter\\RedisAdapter; use Symfony\\Component\\DependencyInjection\\ContainerBuilder; use Symfony\\Config\\FrameworkConfig; return static function (ContainerBuilder $container, FrameworkConfig $framework): void { $framework->cache() ->pool('cache.my_redis') ->adapters(['cache.adapter.redis']) ->provider('app.my_custom_redis_provider'); $container->register('app.my_custom_redis_provider', \\Redis::class) ->setFactory([RedisAdapter::class, 'createConnection']) ->addArgument('redis://localhost') ->addArgument([ 'retry_interval' => 2, 'timeout' => 10 ]) ; }; Creating a Cache Chain Different cache adapters have different strengths and weaknesses. Some might be really quick but optimized to store small items and some may be able to contain a lot of data but are quite slow. To get the best of both worlds you may use a chain of adapters. A cache chain combines several cache pools into a single one. When storing an item in a cache chain, Symfony stores it in all pools sequentially. When retrieving an item, Symfony tries to get it from the first pool. If it's not found, it tries the next pools until the item is found or an exception is thrown. Because of this behavior, it's recommended to define the adapters in the chain in order from fastest to slowest. If an error happens when storing an item in a pool,", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_fixed_3", "source": "cache.rst", "text": "the best of both worlds you may use a chain of adapters. A cache chain combines several cache pools into a single one. When storing an item in a cache chain, Symfony stores it in all pools sequentially. When retrieving an item, Symfony tries to get it from the first pool. If it's not found, it tries the next pools until the item is found or an exception is thrown. Because of this behavior, it's recommended to define the adapters in the chain in order from fastest to slowest. If an error happens when storing an item in a pool, Symfony stores it in the other pools and no exception is thrown. Later, when the item is retrieved, Symfony stores the item automatically in all the missing pools. # config/packages/cache.yaml framework: cache: pools: my_cache_pool: default_lifetime: 31536000 # One year adapters: - cache.adapter.array - cache.adapter.apcu - {name: cache.adapter.redis, provider: 'redis://user:password@example.com'} <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <framework:cache> <framework:pool name=\"my_cache_pool\" default-lifetime=\"31536000\"> <!-- One year --> <framework:adapter name=\"cache.adapter.array\"/> <framework:adapter name=\"cache.adapter.apcu\"/> <framework:adapter name=\"cache.adapter.redis\" provider=\"redis://user:password@example.com\"/> </framework:pool> </framework:cache> </framework:config> </container> // config/packages/cache.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->cache() ->pool('my_cache_pool') ->defaultLifetime(31536000) // One year ->adapters([ 'cache.adapter.array', 'cache.adapter.apcu', ['name' => 'cache.adapter.redis', 'provider' => 'redis://user:password@example.com'], ]) ; }; Using Cache Tags In applications with many cache keys it could be useful to organize the data stored to be able to invalidate the cache more efficiently. One way to achieve that is to use cache tags. One or more tags could be added to the cache item. All items with the same tag could be invalidated with one function call:: use Symfony\\Contracts\\Cache\\ItemInterface; use Symfony\\Contracts\\Cache\\TagAwareCacheInterface; class SomeClass { // using autowiring to inject the cache pool public function __construct( private TagAwareCacheInterface $myCachePool, ) { } public function someMethod(): void { $value0 = $this->myCachePool->get('item_0', function (ItemInterface $item): string { $item->tag(['foo', 'bar']); return 'debug'; }); $value1 = $this->myCachePool->get('item_1', function (ItemInterface $item): string { $item->tag('foo'); return 'debug'; }); // Remove all cache keys tagged with \"bar\" $this->myCachePool->invalidateTags(['bar']); } } The cache adapter needs to implement Symfony\\\\Contracts\\\\Cache\\\\TagAwareCacheInterface to enable this feature. This could be added by using the following configuration. # config/packages/cache.yaml framework: cache: pools: my_cache_pool: adapter: cache.adapter.redis_tag_aware tags: true <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <framework:cache> <framework:pool name=\"my_cache_pool\" adapter=\"cache.adapter.redis_tag_aware\" tags=\"true\" /> </framework:cache> </framework:config> </container> // config/packages/cache.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->cache() ->pool('my_cache_pool') ->tags(true) ->adapters(['cache.adapter.redis_tag_aware']) ; }; Tags are stored in the same pool by default. This is good in most scenarios. But sometimes it might be better to store the tags in a different pool. That could be achieved by specifying the adapter. # config/packages/cache.yaml framework: cache: pools: my_cache_pool: adapter: cache.adapter.redis tags: tag_pool tag_pool: adapter: cache.adapter.apcu <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <framework:cache> <framework:pool name=\"my_cache_pool\" adapter=\"cache.adapter.redis\" tags=\"tag_pool\" /> <framework:pool name=\"tag_pool\" adapter=\"cache.adapter.apcu\"/> </framework:cache> </framework:config> </container> // config/packages/cache.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_fixed_4", "source": "cache.rst", "text": "return static function (FrameworkConfig $framework): void { $framework->cache() ->pool('my_cache_pool') ->tags(true) ->adapters(['cache.adapter.redis_tag_aware']) ; }; Tags are stored in the same pool by default. This is good in most scenarios. But sometimes it might be better to store the tags in a different pool. That could be achieved by specifying the adapter. # config/packages/cache.yaml framework: cache: pools: my_cache_pool: adapter: cache.adapter.redis tags: tag_pool tag_pool: adapter: cache.adapter.apcu <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <framework:cache> <framework:pool name=\"my_cache_pool\" adapter=\"cache.adapter.redis\" tags=\"tag_pool\" /> <framework:pool name=\"tag_pool\" adapter=\"cache.adapter.apcu\"/> </framework:cache> </framework:config> </container> // config/packages/cache.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->cache() ->pool('my_cache_pool') ->tags('tag_pool') ->adapters(['cache.adapter.redis']) ; $framework->cache() ->pool('tag_pool') ->adapters(['cache.adapter.apcu']) ; }; The interface Symfony\\\\Contracts\\\\Cache\\\\TagAwareCacheInterface is autowired to the cache.app service. Clearing the Cache To clear the cache you can use the bin/console cache:pool:clear [pool] command. That will remove all the entries from your storage and you will have to recalculate all the values. You can also group your pools into \"cache clearers\". There are 3 cache clearers by default: * cache.global_clearer * cache.system_clearer * cache.app_clearer The global clearer clears all the cache items in every pool. The system cache clearer is used in the bin/console cache:clear command. The app clearer is the default clearer. To see all available cache pools: $ php bin/console cache:pool:list Clear one pool: $ php bin/console cache:pool:clear my_cache_pool Clear all custom pools: $ php bin/console cache:pool:clear cache.app_clearer Clear all cache pools: $ php bin/console cache:pool:clear --all Clear all cache pools except some: $ php bin/console cache:pool:clear --all --exclude=my_cache_pool --exclude=another_cache_pool Clear all caches everywhere: $ php bin/console cache:pool:clear cache.global_clearer Clear cache by tag(s): # invalidate tag1 from all taggable pools $ php bin/console cache:pool:invalidate-tags tag1 # invalidate tag1 & tag2 from all taggable pools $ php bin/console cache:pool:invalidate-tags tag1 tag2 # invalidate tag1 & tag2 from cache.app pool $ php bin/console cache:pool:invalidate-tags tag1 tag2 --pool=cache.app # invalidate tag1 & tag2 from cache1 & cache2 pools $ php bin/console cache:pool:invalidate-tags tag1 tag2 -p cache1 -p cache2 Encrypting the Cache To encrypt the cache using libsodium, you can use the Symfony\\\\Component\\\\Cache\\\\Marshaller\\\\SodiumMarshaller. First, you need to generate a secure key and add it to your secret store as CACHE_DECRYPTION_KEY: $ php -r 'echo base64_encode(sodium_crypto_box_keypair());' Then, register the SodiumMarshaller service using this key: # config/packages/cache.yaml # ... services: Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller: decorates: cache.default_marshaller arguments: - ['%env(base64:CACHE_DECRYPTION_KEY)%'] # use multiple keys in order to rotate them #- ['%env(base64:CACHE_DECRYPTION_KEY)%', '%env(base64:OLD_CACHE_DECRYPTION_KEY)%'] - '@.inner' <!-- config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <services> <service id=\"Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller\" decorates=\"cache.default_marshaller\"> <argument type=\"collection\"> <argument>env(base64:CACHE_DECRYPTION_KEY)</argument> <!-- use multiple keys in order to rotate them --> <!-- <argument>env(base64:OLD_CACHE_DECRYPTION_KEY)</argument> --> </argument> <argument type=\"service\" id=\".inner\"/> </service> </services> </container> // config/packages/cache.php use Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller; use Symfony\\Component\\DependencyInjection\\ChildDefinition; use Symfony\\Component\\DependencyInjection\\Reference; // ... $container->setDefinition(SodiumMarshaller::class, new ChildDefinition('cache.default_marshaller')) ->addArgument(['env(base64:CACHE_DECRYPTION_KEY)']) // use multiple keys in order to rotate them //->addArgument(['env(base64:CACHE_DECRYPTION_KEY)', 'env(base64:OLD_CACHE_DECRYPTION_KEY)']) ->addArgument(new Reference('.inner')); This will encrypt the values of the cache items, but not the cache keys. Be careful not to leak sensitive data in the keys. When configuring multiple keys, the", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_fixed_5", "source": "cache.rst", "text": "config/packages/cache.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <services> <service id=\"Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller\" decorates=\"cache.default_marshaller\"> <argument type=\"collection\"> <argument>env(base64:CACHE_DECRYPTION_KEY)</argument> <!-- use multiple keys in order to rotate them --> <!-- <argument>env(base64:OLD_CACHE_DECRYPTION_KEY)</argument> --> </argument> <argument type=\"service\" id=\".inner\"/> </service> </services> </container> // config/packages/cache.php use Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller; use Symfony\\Component\\DependencyInjection\\ChildDefinition; use Symfony\\Component\\DependencyInjection\\Reference; // ... $container->setDefinition(SodiumMarshaller::class, new ChildDefinition('cache.default_marshaller')) ->addArgument(['env(base64:CACHE_DECRYPTION_KEY)']) // use multiple keys in order to rotate them //->addArgument(['env(base64:CACHE_DECRYPTION_KEY)', 'env(base64:OLD_CACHE_DECRYPTION_KEY)']) ->addArgument(new Reference('.inner')); This will encrypt the values of the cache items, but not the cache keys. Be careful not to leak sensitive data in the keys. When configuring multiple keys, the first key will be used for reading and writing, and the additional key(s) will only be used for reading. Once all cache items encrypted with the old key have expired, you can completely remove OLD_CACHE_DECRYPTION_KEY. Computing Cache Values Asynchronously The Cache component uses the `probabilistic early expiration`_ algorithm to protect against the cache stampede problem. This means that some cache items are elected for early-expiration while they are still fresh. By default, expired cache items are computed synchronously. However, you can compute them asynchronously by delegating the value computation to a background worker using the Messenger component . In this case, when an item is queried, its cached value is immediately returned and a Symfony\\\\Component\\\\Cache\\\\Messenger\\\\EarlyExpirationMessage is dispatched through a Messenger bus. When this message is handled by a message consumer, the refreshed cache value is computed asynchronously. The next time the item is queried, the refreshed value will be fresh and returned. First, create a service that will compute the item's value:: // src/Cache/CacheComputation.php namespace App\\Cache; use Psr\\Cache\\CacheItemInterface; use Symfony\\Contracts\\Cache\\CallbackInterface; class CacheComputation implements CallbackInterface { public function __invoke(CacheItemInterface $item, bool &$save): string { $item->expiresAfter(5); // this is just a random example; here you must do your own calculation return sprintf('#%06X', mt_rand(0, 0xFFFFFF)); } } This cache value will be requested from a controller, another service, etc. In the following example, the value is requested from a controller:: // src/Controller/CacheController.php namespace App\\Controller; use App\\Cache\\CacheComputation; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\Routing\\Attribute\\Route; use Symfony\\Contracts\\Cache\\CacheInterface; use Symfony\\Contracts\\Cache\\ItemInterface; class CacheController extends AbstractController { #[Route('/cache', name: 'cache')] public function index(CacheInterface $asyncCache, CacheComputation $cacheComputation): Response { // pass to the cache the service method that refreshes the item $cachedValue = $asyncCache->get('my_value', $cacheComputation) // ... } } Finally, configure a new cache pool (e.g. called async.cache) that will use a message bus to compute values in a worker: # config/packages/framework.yaml framework: cache: pools: async.cache: early_expiration_message_bus: messenger.default_bus messenger: transports: async_bus: '%env(MESSENGER_TRANSPORT_DSN)%' routing: 'Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage': async_bus <!-- config/packages/framework.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <framework:cache> <framework:pool name=\"async.cache\" early-expiration-message-bus=\"messenger.default_bus\"/> </framework:cache> <framework:messenger> <framework:transport name=\"async_bus\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport> <framework:routing message-class=\"Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage\"> <framework:sender service=\"async_bus\"/> </framework:routing> </framework:messenger> </framework:config> </container> // config/framework/framework.php use Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage; use Symfony\\Config\\FrameworkConfig; use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env; return static function (FrameworkConfig $framework): void { $framework->cache() ->pool('async.cache') ->earlyExpirationMessageBus('messenger.default_bus'); $framework->messenger() ->transport('async_bus') ->dsn(env('MESSENGER_TRANSPORT_DSN')) ->routing(EarlyExpirationMessage::class) ->senders(['async_bus']); }; You can now start the consumer: $ php bin/console messenger:consume async_bus That's it! Now, whenever an item is queried from this cache pool, its cached value will be returned", "title": "Cache", "category": "cache"}
{"chunk_id": "cache.rst_fixed_6", "source": "cache.rst", "text": "framework: cache: pools: async.cache: early_expiration_message_bus: messenger.default_bus messenger: transports: async_bus: '%env(MESSENGER_TRANSPORT_DSN)%' routing: 'Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage': async_bus <!-- config/packages/framework.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\" > <framework:config> <framework:cache> <framework:pool name=\"async.cache\" early-expiration-message-bus=\"messenger.default_bus\"/> </framework:cache> <framework:messenger> <framework:transport name=\"async_bus\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport> <framework:routing message-class=\"Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage\"> <framework:sender service=\"async_bus\"/> </framework:routing> </framework:messenger> </framework:config> </container> // config/framework/framework.php use Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage; use Symfony\\Config\\FrameworkConfig; use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env; return static function (FrameworkConfig $framework): void { $framework->cache() ->pool('async.cache') ->earlyExpirationMessageBus('messenger.default_bus'); $framework->messenger() ->transport('async_bus') ->dsn(env('MESSENGER_TRANSPORT_DSN')) ->routing(EarlyExpirationMessage::class) ->senders(['async_bus']); }; You can now start the consumer: $ php bin/console messenger:consume async_bus That's it! Now, whenever an item is queried from this cache pool, its cached value will be returned immediately. If it is elected for early-expiration, a message will be sent through to bus to schedule a background computation to refresh the value.", "title": "Cache", "category": "cache"}
{"chunk_id": "configuration.rst_fixed_0", "source": "configuration.rst", "text": "Configuring Symfony Configuration Files Symfony applications are configured with the files stored in the config/ directory, which has this default structure: your-project/ ├─ config/ │ ├─ packages/ │ ├─ bundles.php │ ├─ routes.yaml │ └─ services.yaml * The routes.yaml file defines the routing configuration ; * The services.yaml file configures the services of the service container ; * The bundles.php file enables/disables packages in your application; * The config/packages/ directory stores the configuration of every package installed in your application. Packages (also called \"bundles\" in Symfony and \"plugins/modules\" in other projects) add ready-to-use features to your projects. When using Symfony Flex , which is enabled by default in Symfony applications, packages update the bundles.php file and create new files in config/packages/ automatically during their installation. For example, this is the default file created by the \"API Platform\" bundle: # config/packages/api_platform.yaml api_platform: mapping: paths: ['%kernel.project_dir%/src/Entity'] Splitting the configuration into lots of small files might seem intimidating to some Symfony newcomers. However, you'll get used to them quickly and you rarely need to change these files after package installation. To learn about all the available configuration options, check out the Symfony Configuration Reference or run the config:dump-reference command. Configuration Formats Unlike other frameworks, Symfony doesn't impose a specific format on you to configure your applications, but lets you choose between YAML, XML and PHP. Throughout the Symfony documentation, all configuration examples will be shown in these three formats. There isn't any practical difference between formats. In fact, Symfony transforms all of them into PHP and caches them before running the application, so there's not even any performance difference. YAML is used by default when installing packages because it's concise and very readable. These are the main advantages and disadvantages of each format: * **YAML**: simple, clean and readable, but not all IDEs support autocompletion and validation for it. Learn the YAML syntax ; * **XML**: autocompleted/validated by most IDEs and is parsed natively by PHP, but sometimes it generates configuration considered too verbose. `Learn the XML syntax`_; * **PHP**: very powerful and it allows you to create dynamic configuration with arrays or a ConfigBuilder . By default Symfony loads the configuration files defined in YAML and PHP formats. If you define configuration in XML format, update the Symfony\\\\Bundle\\\\FrameworkBundle\\\\Kernel\\\\MicroKernelTrait::configureContainer and/or Symfony\\\\Bundle\\\\FrameworkBundle\\\\Kernel\\\\MicroKernelTrait::configureRoutes methods in the src/Kernel.php file to add support for the .xml file extension. Importing Configuration Files Symfony loads configuration files using the Config component , which provides advanced features such as importing other configuration files, even if they use a different format: # config/services.yaml imports: - { resource: 'legacy_config.php' } # glob expressions are also supported to load multiple files - { resource: '/etc/myapp/*.yaml' } # ignore_errors: not_found silently discards errors if the loaded file doesn't exist - { resource: 'my_config_file.xml', ignore_errors: not_found } # ignore_errors: true silently discards all errors (including invalid code and not found) - { resource: 'my_other_config_file.xml', ignore_errors: true } # ... <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <imports> <import", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_1", "source": "configuration.rst", "text": "Config component , which provides advanced features such as importing other configuration files, even if they use a different format: # config/services.yaml imports: - { resource: 'legacy_config.php' } # glob expressions are also supported to load multiple files - { resource: '/etc/myapp/*.yaml' } # ignore_errors: not_found silently discards errors if the loaded file doesn't exist - { resource: 'my_config_file.xml', ignore_errors: not_found } # ignore_errors: true silently discards all errors (including invalid code and not found) - { resource: 'my_other_config_file.xml', ignore_errors: true } # ... <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <imports> <import resource=\"legacy_config.php\"/> <!-- glob expressions are also supported to load multiple files --> <import resource=\"/etc/myapp/*.yaml\"/> <!-- ignore-errors=\"not_found\" silently discards errors if the loaded file doesn't exist --> <import resource=\"my_config_file.yaml\" ignore-errors=\"not_found\"/> <!-- ignore-errors=\"true\" silently discards all errors (including invalid code and not found) --> <import resource=\"my_other_config_file.yaml\" ignore-errors=\"true\"/> </imports> <!-- ... --> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return static function (ContainerConfigurator $container): void { $container->import('legacy_config.php'); // glob expressions are also supported to load multiple files $container->import('/etc/myapp/*.yaml'); // the third optional argument of import() is 'ignore_errors' // 'ignore_errors' set to 'not_found' silently discards errors if the loaded file doesn't exist $container->import('my_config_file.yaml', null, 'not_found'); // 'ignore_errors' set to true silently discards all errors (including invalid code and not found) $container->import('my_config_file.yaml', null, true); }; // ... Configuration Parameters Sometimes the same configuration value is used in several configuration files. Instead of repeating it, you can define it as a \"parameter\", which is like a reusable configuration value. By convention, parameters are defined under the parameters key in the config/services.yaml file: # config/services.yaml parameters: # the parameter name is an arbitrary string (the 'app.' prefix is recommended # to better differentiate your parameters from Symfony parameters). app.admin_email: 'something@example.com' # boolean parameters app.enable_v2_protocol: true # array/collection parameters app.supported_locales: ['en', 'es', 'fr'] # binary content parameters (encode the contents with base64_encode()) app.some_parameter: !!binary VGhpcyBpcyBhIEJlbGwgY2hhciAH # PHP constants as parameter values app.some_constant: !php/const GLOBAL_CONSTANT app.another_constant: !php/const App\\Entity\\BlogPost::MAX_ITEMS # Enum case as parameter values app.some_enum: !php/enum App\\Enum\\PostState::Published # ... <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <parameters> <!-- the parameter name is an arbitrary string (the 'app.' prefix is recommended to better differentiate your parameters from Symfony parameters). --> <parameter key=\"app.admin_email\">something@example.com</parameter> <!-- boolean parameters --> <parameter key=\"app.enable_v2_protocol\">true</parameter> <!-- if you prefer to store the boolean value as a string in the parameter --> <parameter key=\"app.enable_v2_protocol\" type=\"string\">true</parameter> <!-- array/collection parameters --> <parameter key=\"app.supported_locales\" type=\"collection\"> <parameter>en</parameter> <parameter>es</parameter> <parameter>fr</parameter> </parameter> <!-- binary content parameters (encode the contents with base64_encode()) --> <parameter key=\"app.some_parameter\" type=\"binary\">VGhpcyBpcyBhIEJlbGwgY2hhciAH</parameter> <!-- PHP constants as parameter values --> <parameter key=\"app.some_constant\" type=\"constant\">GLOBAL_CONSTANT</parameter> <parameter key=\"app.another_constant\" type=\"constant\">App\\Entity\\BlogPost::MAX_ITEMS</parameter> <!-- Enum case as parameter values --> <parameter key=\"app.some_enum\" type=\"constant\">App\\Enum\\PostState::Published</parameter> </parameters> <!-- ... --> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Entity\\BlogPost; use App\\Enum\\PostState; return static function (ContainerConfigurator $container): void { $container->parameters() // the parameter name is an arbitrary string (the 'app.' prefix is recommended // to better differentiate your parameters from Symfony parameters). ->set('app.admin_email', 'something@example.com') // boolean parameters ->set('app.enable_v2_protocol', true)", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_2", "source": "configuration.rst", "text": "<parameter key=\"app.enable_v2_protocol\" type=\"string\">true</parameter> <!-- array/collection parameters --> <parameter key=\"app.supported_locales\" type=\"collection\"> <parameter>en</parameter> <parameter>es</parameter> <parameter>fr</parameter> </parameter> <!-- binary content parameters (encode the contents with base64_encode()) --> <parameter key=\"app.some_parameter\" type=\"binary\">VGhpcyBpcyBhIEJlbGwgY2hhciAH</parameter> <!-- PHP constants as parameter values --> <parameter key=\"app.some_constant\" type=\"constant\">GLOBAL_CONSTANT</parameter> <parameter key=\"app.another_constant\" type=\"constant\">App\\Entity\\BlogPost::MAX_ITEMS</parameter> <!-- Enum case as parameter values --> <parameter key=\"app.some_enum\" type=\"constant\">App\\Enum\\PostState::Published</parameter> </parameters> <!-- ... --> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Entity\\BlogPost; use App\\Enum\\PostState; return static function (ContainerConfigurator $container): void { $container->parameters() // the parameter name is an arbitrary string (the 'app.' prefix is recommended // to better differentiate your parameters from Symfony parameters). ->set('app.admin_email', 'something@example.com') // boolean parameters ->set('app.enable_v2_protocol', true) // array/collection parameters ->set('app.supported_locales', ['en', 'es', 'fr']) // binary content parameters (use the PHP escape sequences) ->set('app.some_parameter', 'This is a Bell char: \\x07') // PHP constants as parameter values ->set('app.some_constant', GLOBAL_CONSTANT) ->set('app.another_constant', BlogPost::MAX_ITEMS) // Enum case as parameter values ->set('app.some_enum', PostState::Published); }; // ... By default and when using XML configuration, the values between <parameter> tags are not trimmed. This means that the value of the following parameter will be '\\n something@example.com\\n': <parameter key=\"app.admin_email\"> something@example.com </parameter> If you want to trim the value of your parameter, use the trim attribute. When using it, the value of the following parameter will be something@example.com: <parameter key=\"app.admin_email\" trim=\"true\"> something@example.com </parameter> Once defined, you can reference this parameter value from any other configuration file using a special syntax: wrap the parameter name in two % (e.g. %app.admin_email%): # config/packages/some_package.yaml some_package: # any string surrounded by two % is replaced by that parameter value email_address: '%app.admin_email%' <!-- config/packages/some_package.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- any string surrounded by two % is replaced by that parameter value --> <some-package:config email-address=\"%app.admin_email%\"> <!-- ... --> </some-package:config> </container> // config/packages/some_package.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\param; return static function (ContainerConfigurator $container): void { $container->extension('some_package', [ // when using the param() function, you only have to pass the parameter name... 'email_address' => param('app.admin_email'), // ... but if you prefer it, you can also pass the name as a string // surrounded by two % (same as in YAML and XML formats) and Symfony will // replace it by that parameter value 'email_address' => '%app.admin_email%', ]); }; If some parameter value includes the % character, you need to escape it by adding another %, so Symfony doesn't consider it a reference to a parameter name: # config/services.yaml parameters: # Parsed as 'https://symfony.com/?foo=%s&amp;bar=%d' url_pattern: 'https://symfony.com/?foo=%%s&amp;bar=%%d' <!-- config/services.xml --> <parameters> <parameter key=\"url_pattern\">http://symfony.com/?foo=%%s&amp;bar=%%d</parameter> </parameters> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return static function (ContainerConfigurator $container): void { $container->parameters() ->set('url_pattern', 'http://symfony.com/?foo=%%s&amp;bar=%%d'); }; Configuration parameters are very common in Symfony applications. Some packages even define their own parameters (e.g. when installing the translation package, a new locale parameter is added to the config/services.yaml file). By convention, parameters whose names start with a dot . (for example, .mailer.transport), are available only during the container compilation. They are useful when working with Compiler Passes to declare some temporary parameters that won't be available later in the application. Configuration parameters are usually validation-free, but", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_3", "source": "configuration.rst", "text": "<!-- config/services.xml --> <parameters> <parameter key=\"url_pattern\">http://symfony.com/?foo=%%s&amp;bar=%%d</parameter> </parameters> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return static function (ContainerConfigurator $container): void { $container->parameters() ->set('url_pattern', 'http://symfony.com/?foo=%%s&amp;bar=%%d'); }; Configuration parameters are very common in Symfony applications. Some packages even define their own parameters (e.g. when installing the translation package, a new locale parameter is added to the config/services.yaml file). By convention, parameters whose names start with a dot . (for example, .mailer.transport), are available only during the container compilation. They are useful when working with Compiler Passes to declare some temporary parameters that won't be available later in the application. Configuration parameters are usually validation-free, but you can ensure that essential parameters for your application's functionality are not empty:: /** @var ContainerBuilder $container */ $container->parameterCannotBeEmpty('app.private_key', 'Did you forget to set a value for the \"app.private_key\" parameter?'); If a non-empty parameter is null, an empty string '', or an empty array [], Symfony will throw an exception. This validation is **not** made at compile time but when attempting to retrieve the value of the parameter. Validating non-empty parameters was introduced in Symfony 7.2. Later in this article you can read how to get configuration parameters in controllers and services . Configuration Environments You have only one application, but whether you realize it or not, you need it to behave differently at different times: * While **developing**, you want to log everything and expose nice debugging tools; * After deploying to **production**, you want that same application to be optimized for speed and only log errors. The files stored in config/packages/ are used by Symfony to configure the application services . In other words, you can change the application behavior by changing which configuration files are loaded. That's the idea of Symfony's **configuration environments**. A typical Symfony application begins with three environments: * dev for local development, * prod for production servers, * test for automated tests . When running the application, Symfony loads the configuration files in this order (the last files can override the values set in the previous ones): #. The files in config/packages/*.<extension>; #. the files in config/packages/<environment-name>/*.<extension>; #. config/services.<extension>; #. config/services_<environment-name>.<extension>. Take the framework package, installed by default, as an example: * First, config/packages/framework.yaml is loaded in all environments and it configures the framework with some options; * In the **prod** environment, nothing extra will be set as there is no config/packages/prod/framework.yaml file; * In the **dev** environment, there is no file either ( config/packages/dev/framework.yaml does not exist). * In the **test** environment, the config/packages/test/framework.yaml file is loaded to override some of the settings previously configured in config/packages/framework.yaml. In reality, each environment differs only somewhat from others. This means that all environments share a large base of common configuration, which is put in files directly in the config/packages/ directory. You can also define options for different environments in a single configuration file using the special when keyword: # config/packages/webpack_encore.yaml webpack_encore: # ... output_path: '%kernel.project_dir%/public/build' strict_mode: true cache: false # cache is enabled only in the \"prod\" environment when@prod: webpack_encore: cache: true # disable", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_4", "source": "configuration.rst", "text": "( config/packages/dev/framework.yaml does not exist). * In the **test** environment, the config/packages/test/framework.yaml file is loaded to override some of the settings previously configured in config/packages/framework.yaml. In reality, each environment differs only somewhat from others. This means that all environments share a large base of common configuration, which is put in files directly in the config/packages/ directory. You can also define options for different environments in a single configuration file using the special when keyword: # config/packages/webpack_encore.yaml webpack_encore: # ... output_path: '%kernel.project_dir%/public/build' strict_mode: true cache: false # cache is enabled only in the \"prod\" environment when@prod: webpack_encore: cache: true # disable strict mode only in the \"test\" environment when@test: webpack_encore: strict_mode: false # YAML syntax allows to reuse contents using \"anchors\" (&some_name) and \"aliases\" (*some_name). # In this example, 'test' configuration uses the exact same configuration as in 'prod' when@prod: &webpack_prod webpack_encore: # ... when@test: *webpack_prod <!-- config/packages/webpack_encore.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <webpack-encore:config output-path=\"%kernel.project_dir%/public/build\" strict-mode=\"true\" cache=\"false\" /> <!-- cache is enabled only in the \"test\" environment --> <when env=\"prod\"> <webpack-encore:config cache=\"true\"/> </when> <!-- disable strict mode only in the \"test\" environment --> <when env=\"test\"> <webpack-encore:config strict-mode=\"false\"/> </when> </container> // config/packages/framework.php use Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator; use Symfony\\Config\\WebpackEncoreConfig; return static function (WebpackEncoreConfig $webpackEncore, ContainerConfigurator $container): void { $webpackEncore ->outputPath('%kernel.project_dir%/public/build') ->strictMode(true) ->cache(false) ; // cache is enabled only in the \"prod\" environment if ('prod' === $container->env()) { $webpackEncore->cache(true); } // disable strict mode only in the \"test\" environment if ('test' === $container->env()) { $webpackEncore->strictMode(false); } }; See the configureContainer() method of the Kernel class to learn everything about the loading order of configuration files. Selecting the Active Environment Symfony applications come with a file called .env located at the project root directory. This file is used to define the value of environment variables and it's explained in detail later in this article . Open the .env file (or better, the .env.local file if you created one) and edit the value of the APP_ENV variable to change the environment in which the application runs. For example, to run the application in production: # .env (or .env.local) APP_ENV=prod This value is used both for the web and for the console commands. However, you can override it for commands by setting the APP_ENV value before running them: # Use the environment defined in the .env file $ php bin/console command_name # Ignore the .env file and run this command in production $ APP_ENV=prod php bin/console command_name Creating a New Environment The default three environments provided by Symfony are enough for most projects, but you can define your own environments too. For example, this is how you can define a staging environment where the client can test the project before going to production: #. Create a configuration directory with the same name as the environment (in this case, config/packages/staging/); #. Add the needed configuration files in config/packages/staging/ to define the behavior of the new environment. Symfony loads the config/packages/*.yaml files first, so you only need to configure the differences to those files;", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_5", "source": "configuration.rst", "text": "$ APP_ENV=prod php bin/console command_name Creating a New Environment The default three environments provided by Symfony are enough for most projects, but you can define your own environments too. For example, this is how you can define a staging environment where the client can test the project before going to production: #. Create a configuration directory with the same name as the environment (in this case, config/packages/staging/); #. Add the needed configuration files in config/packages/staging/ to define the behavior of the new environment. Symfony loads the config/packages/*.yaml files first, so you only need to configure the differences to those files; #. Select the staging environment using the APP_ENV env var as explained in the previous section. It's common for environments to be similar to each other, so you can use `symbolic links`_ between config/packages/<environment-name>/ directories to reuse the same configuration. Instead of creating new environments, you can use environment variables as explained in the following section. This way you can use the same application and environment (e.g. prod) but change its behavior thanks to the configuration based on environment variables (e.g. to run the application in different scenarios: staging, quality assurance, client review, etc.) Configuration Based on Environment Variables Using `environment variables`_ (or \"env vars\" for short) is a common practice to: * Configure options that depend on where the application is run (e.g. the database credentials are usually different in production versus your local machine); * Configure options that can change dynamically in a production environment (e.g. to update the value of an expired API key without having to redeploy the entire application). In other cases, it's recommended to keep using configuration parameters . Use the special syntax %env(ENV_VAR_NAME)% to reference environment variables. The values of these options are resolved at runtime (only once per request, to not impact performance) so you can change the application behavior without having to clear the cache. This example shows how you could configure the application secret using an env var: # config/packages/framework.yaml framework: # by convention the env var names are always uppercase secret: '%env(APP_SECRET)%' # ... <!-- config/packages/framework.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/framework\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- by convention the env var names are always uppercase --> <framework:config secret=\"%env(APP_SECRET)%\"/> </container> // config/packages/framework.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return static function (ContainerConfigurator $container): void { $container->extension('framework', [ // by convention the env var names are always uppercase 'secret' => '%env(APP_SECRET)%', ]); }; Your env vars can also be accessed via the PHP super globals $_ENV and $_SERVER (both are equivalent):: $databaseUrl = $_ENV['DATABASE_URL']; // mysql://db_user:db_password@127.0.0.1:3306/db_name $env = $_SERVER['APP_ENV']; // prod However, in Symfony applications there's no need to use this, because the configuration system provides a better way of working with env vars. The values of env vars can only be strings, but Symfony includes some env var processors to transform their contents (e.g. to turn a string value into an integer). To define the value of an env var, you have several options: * Add the value to a", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_6", "source": "configuration.rst", "text": "]); }; Your env vars can also be accessed via the PHP super globals $_ENV and $_SERVER (both are equivalent):: $databaseUrl = $_ENV['DATABASE_URL']; // mysql://db_user:db_password@127.0.0.1:3306/db_name $env = $_SERVER['APP_ENV']; // prod However, in Symfony applications there's no need to use this, because the configuration system provides a better way of working with env vars. The values of env vars can only be strings, but Symfony includes some env var processors to transform their contents (e.g. to turn a string value into an integer). To define the value of an env var, you have several options: * Add the value to a .env file ; * Encrypt the value as a secret ; * Set the value as a real environment variable in your shell or your web server. If your application tries to use an env var that hasn't been defined, you'll see an exception. You can prevent that by defining a default value for the env var. To do so, define a parameter with the same name as the env var using this syntax: # config/packages/framework.yaml parameters: # if the SECRET env var value is not defined anywhere, Symfony uses this value env(SECRET): 'some_secret' # ... <!-- config/packages/framework.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <parameters> <!-- if the SECRET env var value is not defined anywhere, Symfony uses this value --> <parameter key=\"env(SECRET)\">some_secret</parameter> </parameters> <!-- ... --> </container> // config/packages/framework.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\DependencyInjection\\ContainerBuilder; use Symfony\\Config\\FrameworkConfig; return static function (ContainerBuilder $container, FrameworkConfig $framework) { // if the SECRET env var value is not defined anywhere, Symfony uses this value $container->setParameter('env(SECRET)', 'some_secret'); // ... }; Some hosts - like Upsun - offer easy `utilities to manage env vars`_ in production. Some configuration features are not compatible with env vars. For example, defining some container parameters conditionally based on the existence of another configuration option. When using an env var, the configuration option always exists, because its value will be null when the related env var is not defined. Beware that dumping the contents of the $_SERVER and $_ENV variables or outputting the phpinfo() contents will display the values of the environment variables, exposing sensitive information such as the database credentials. The values of the env vars are also exposed in the web interface of the Symfony profiler . In practice this shouldn't be a problem because the web profiler must **never** be enabled in production. Configuring Environment Variables in .env Files Instead of defining env vars in your shell or your web server, Symfony provides a convenient way to define them inside a .env (with a leading dot) file located at the root of your project. The .env file is read and parsed on every request and its env vars are added to the $_ENV & $_SERVER PHP variables. Any existing env vars are *never* overwritten by the values defined in .env, so you can combine both. For example, to define the DATABASE_URL env var shown earlier in this article, you can add: #", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_7", "source": "configuration.rst", "text": "production. Configuring Environment Variables in .env Files Instead of defining env vars in your shell or your web server, Symfony provides a convenient way to define them inside a .env (with a leading dot) file located at the root of your project. The .env file is read and parsed on every request and its env vars are added to the $_ENV & $_SERVER PHP variables. Any existing env vars are *never* overwritten by the values defined in .env, so you can combine both. For example, to define the DATABASE_URL env var shown earlier in this article, you can add: # .env DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name\" This file should be committed to your repository and (due to that fact) should only contain \"default\" values that are good for local development. This file should not contain production values. In addition to your own env vars, this .env file also contains the env vars defined by the third-party packages installed in your application (they are added automatically by Symfony Flex when installing packages). Since the .env file is read and parsed on every request, you don't need to clear the Symfony cache or restart the PHP container if you're using Docker. .env File Syntax ................ Add comments by prefixing them with #: # database credentials DB_USER=root DB_PASS=pass # this is the secret password Use environment variables in values by prefixing variables with $: DB_USER=root DB_PASS=${DB_USER}pass # include the user as a password prefix The order is important when some env var depends on the value of other env vars. In the above example, DB_PASS must be defined after DB_USER. Moreover, if you define multiple .env files and put DB_PASS first, its value will depend on the DB_USER value defined in other files instead of the value defined in this file. Define a default value in case the environment variable is not set: DB_USER= DB_PASS=${DB_USER:-root}pass # results in DB_PASS=rootpass Embed commands via $() (not supported on Windows): START_TIME=$(date) Using $() might not work depending on your shell. As a .env file is a regular shell script, you can source it in your own shell scripts: $ source .env Overriding Environment Values via .env.local If you need to override an environment value (e.g. to a different value on your local machine), you can do that in a .env.local file: # .env.local DATABASE_URL=\"mysql://root:@127.0.0.1:3306/my_database_name\" This file should be ignored by git and should *not* be committed to your repository. Several other .env files are available to set environment variables in *just* the right situation: * .env: defines the default values of the env vars needed by the application; * .env.local: overrides the default values for all environments but only on the machine which contains the file. This file should not be committed to the repository and it's ignored in the test environment (because tests should produce the same results for everyone); * .env.<environment> (e.g. .env.test): overrides env vars only for one environment but for all machines (these files *are* committed); * .env.<environment>.local (e.g. .env.test.local): defines machine-specific env var overrides only", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_8", "source": "configuration.rst", "text": "other .env files are available to set environment variables in *just* the right situation: * .env: defines the default values of the env vars needed by the application; * .env.local: overrides the default values for all environments but only on the machine which contains the file. This file should not be committed to the repository and it's ignored in the test environment (because tests should produce the same results for everyone); * .env.<environment> (e.g. .env.test): overrides env vars only for one environment but for all machines (these files *are* committed); * .env.<environment>.local (e.g. .env.test.local): defines machine-specific env var overrides only for one environment. It's similar to .env.local, but the overrides only apply to one environment. *Real* environment variables always win over env vars created by any of the .env files. Note that this behavior depends on the `variables_order <http://php.net/manual/en/ini.core.php#ini.variables-order>`_ configuration, which must contain an E to expose the $_ENV superglobal. This is the default configuration in PHP. The .env and .env.<environment> files should be committed to the repository because they are the same for all developers and machines. However, the env files ending in .local (.env.local and .env.<environment>.local) **should not be committed** because only you will use them. In fact, the .gitignore file that comes with Symfony prevents them from being committed. Overriding Environment Variables Defined By The System If you need to override an environment variable defined by the system, use the overrideExistingVars parameter defined by the Symfony\\\\Component\\\\Dotenv\\\\Dotenv::loadEnv, Symfony\\\\Component\\\\Dotenv\\\\Dotenv::bootEnv, and Symfony\\\\Component\\\\Dotenv\\\\Dotenv::populate methods:: use Symfony\\Component\\Dotenv\\Dotenv; $dotenv = new Dotenv(); $dotenv->loadEnv(__DIR__.'/.env', overrideExistingVars: true); // ... This will override environment variables defined by the system but it **won't** override environment variables defined in .env files. Configuring Environment Variables in Production In production, the .env files are also parsed and loaded on each request. So the easiest way to define env vars is by creating a .env.local file on your production server(s) with your production values. To improve performance, you can optionally run the dump-env Composer command: # parses ALL .env files and dumps their final values to .env.local.php $ composer dump-env prod If you don't have Composer installed in production, you can use the dotenv:dump command instead (available in Symfony Flex 1.2 or later). The command is not registered by default, so you must register first in your services: # config/services.yaml services: Symfony\\Component\\Dotenv\\Command\\DotenvDumpCommand: ~ Then, run the command: # parses ALL .env files and dumps their final values to .env.local.php $ APP_ENV=prod APP_DEBUG=0 php bin/console dotenv:dump After running this command, Symfony will load the .env.local.php file to get the environment variables and will not spend time parsing the .env files. Update your deployment tools/workflow to run the dotenv:dump command after each deploy to improve the application performance. Storing Environment Variables In Other Files By default, the environment variables are stored in the .env file located at the root of your project. However, you can store them in other files in multiple ways. If you use the Runtime component , the dotenv path is part of the options you can set in your", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_9", "source": "configuration.rst", "text": "APP_DEBUG=0 php bin/console dotenv:dump After running this command, Symfony will load the .env.local.php file to get the environment variables and will not spend time parsing the .env files. Update your deployment tools/workflow to run the dotenv:dump command after each deploy to improve the application performance. Storing Environment Variables In Other Files By default, the environment variables are stored in the .env file located at the root of your project. However, you can store them in other files in multiple ways. If you use the Runtime component , the dotenv path is part of the options you can set in your composer.json file: { // ... \"extra\": { // ... \"runtime\": { \"dotenv_path\": \"my/custom/path/to/.env\" } } } As an alternate option, you can directly invoke the Dotenv class in your bootstrap.php file or any other file of your application:: use Symfony\\Component\\Dotenv\\Dotenv; (new Dotenv())->bootEnv(dirname(__DIR__).'my/custom/path/to/.env'); Symfony will then look for the environment variables in that file, but also in the local and environment-specific files (e.g. .*.local and .*.<environment>.local). Read how to override environment variables to learn more about this. If you need to know the path to the .env file that Symfony is using, you can read the SYMFONY_DOTENV_PATH environment variable in your application. The SYMFONY_DOTENV_PATH environment variable was introduced in Symfony 7.1. Encrypting Environment Variables (Secrets) Instead of defining a real environment variable or adding it to a .env file, if the value of a variable is sensitive (e.g. an API key or a database password), you can encrypt the value using the secrets management system . Listing Environment Variables Use the debug:dotenv command to understand how Symfony parses the different .env files to set the value of each environment variable: $ php bin/console debug:dotenv Dotenv Variables & Files Scanned Files (in descending priority) * ⨯ .env.local.php * ⨯ .env.dev.local * ✓ .env.dev * ⨯ .env.local * ✓ .env Variables ---------- ------- ---------- ------ Variable Value .env.dev .env ---------- ------- ---------- ------ FOO BAR n/a BAR ALICE BOB BOB bob ---------- ------- ---------- ------ # look for a specific variable passing its full or partial name as an argument $ php bin/console debug:dotenv foo Additionally, and regardless of how you set environment variables, you can see all environment variables, with their values, referenced in Symfony's container configuration, you can also see the number of occurrences of each environment variable in the container: $ php bin/console debug:container --env-vars ------------ ----------------- ------------------------------------ ------------- Name Default value Real value Usage count ------------ ----------------- ------------------------------------ ------------- APP_SECRET n/a \"471a62e2d601a8952deb186e44186cb3\" 2 BAR n/a n/a 1 BAZ n/a \"value\" 0 FOO \"[1, \"2.5\", 3]\" n/a 1 ------------ ----------------- ------------------------------------ ------------- # you can also filter the list of env vars by name: $ php bin/console debug:container --env-vars foo # run this command to show all the details for a specific env var: $ php bin/console debug:container --env-var=FOO Creating Your Own Logic To Load Env Vars You can implement your own logic to load environment variables if the default Symfony behavior doesn't fit your needs. To do so, create", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_10", "source": "configuration.rst", "text": "Default value Real value Usage count ------------ ----------------- ------------------------------------ ------------- APP_SECRET n/a \"471a62e2d601a8952deb186e44186cb3\" 2 BAR n/a n/a 1 BAZ n/a \"value\" 0 FOO \"[1, \"2.5\", 3]\" n/a 1 ------------ ----------------- ------------------------------------ ------------- # you can also filter the list of env vars by name: $ php bin/console debug:container --env-vars foo # run this command to show all the details for a specific env var: $ php bin/console debug:container --env-var=FOO Creating Your Own Logic To Load Env Vars You can implement your own logic to load environment variables if the default Symfony behavior doesn't fit your needs. To do so, create a service whose class implements Symfony\\\\Component\\\\DependencyInjection\\\\EnvVarLoaderInterface. If you're using the default services.yaml configuration , the autoconfiguration feature will enable and tag this service automatically. Otherwise, you need to register and tag your service with the container.env_var_loader tag. Let's say you have a JSON file named env.json containing your environment variables: { \"vars\": { \"APP_ENV\": \"prod\", \"APP_DEBUG\": false } } You can define a class like the following JsonEnvVarLoader to populate the environment variables from the file:: namespace App\\DependencyInjection; use Symfony\\Component\\DependencyInjection\\EnvVarLoaderInterface; final class JsonEnvVarLoader implements EnvVarLoaderInterface { private const ENV_VARS_FILE = 'env.json'; public function loadEnvVars(): array { $fileName = __DIR__.\\DIRECTORY_SEPARATOR.self::ENV_VARS_FILE; if (!is_file($fileName)) { // throw an exception or just ignore this loader, depending on your needs } $content = json_decode(file_get_contents($fileName), true); return $content['vars']; } } That's it! Now the application will look for a env.json file in the current directory to populate environment variables (in addition to the already existing .env files). If you want an env var to have a value on a certain environment but to fallback on loaders on another environment, assign an empty value to the env var for the environment you want to use loaders: # .env (or .env.local) APP_ENV=prod # .env.prod (or .env.prod.local) - this will fallback on the loaders you defined APP_ENV= Accessing Configuration Parameters Controllers and services can access all the configuration parameters. This includes both the parameters defined by yourself and the parameters created by packages/bundles. Run the following command to see all the parameters that exist in your application: $ php bin/console debug:container --parameters In controllers extending from the AbstractController , use the getParameter() helper:: // src/Controller/UserController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; class UserController extends AbstractController { // ... public function index(): Response { $projectDir = $this->getParameter('kernel.project_dir'); $adminEmail = $this->getParameter('app.admin_email'); // ... } } In services and controllers not extending from AbstractController, inject the parameters as arguments of their constructors. You must inject them explicitly because service autowiring doesn't work for parameters: # config/services.yaml parameters: app.contents_dir: '...' services: App\\Service\\MessageGenerator: arguments: $contentsDir: '%app.contents_dir%' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters> <parameter key=\"app.contents_dir\">...</parameter> </parameters> <services> <service id=\"App\\Service\\MessageGenerator\"> <argument key=\"$contentsDir\">%app.contents_dir%</argument> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator; return static function (ContainerConfigurator $container): void { $container->parameters() ->set('app.contents_dir', '...'); $container->services() ->get(MessageGenerator::class) ->arg('$contentsDir', '%app.contents_dir%'); }; If you inject the same parameters over and over again, use the services._defaults.bind option instead. The arguments defined in that option are injected", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_11", "source": "configuration.rst", "text": "from AbstractController, inject the parameters as arguments of their constructors. You must inject them explicitly because service autowiring doesn't work for parameters: # config/services.yaml parameters: app.contents_dir: '...' services: App\\Service\\MessageGenerator: arguments: $contentsDir: '%app.contents_dir%' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters> <parameter key=\"app.contents_dir\">...</parameter> </parameters> <services> <service id=\"App\\Service\\MessageGenerator\"> <argument key=\"$contentsDir\">%app.contents_dir%</argument> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator; return static function (ContainerConfigurator $container): void { $container->parameters() ->set('app.contents_dir', '...'); $container->services() ->get(MessageGenerator::class) ->arg('$contentsDir', '%app.contents_dir%'); }; If you inject the same parameters over and over again, use the services._defaults.bind option instead. The arguments defined in that option are injected automatically whenever a service constructor or controller action defines an argument with that exact name. For example, to inject the value of the kernel.project_dir parameter whenever a service/controller defines a $projectDir argument, use this: # config/services.yaml services: _defaults: bind: # pass this value to any $projectDir argument for any service # that's created in this file (including controller arguments) $projectDir: '%kernel.project_dir%' # ... <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <defaults autowire=\"true\" autoconfigure=\"true\" public=\"false\"> <!-- pass this value to any $projectDir argument for any service that's created in this file (including controller arguments) --> <bind key=\"$projectDir\">%kernel.project_dir%</bind> </defaults> <!-- ... --> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return static function (ContainerConfigurator $container): void { $container->services() ->defaults() // pass this value to any $projectDir argument for any service // that's created in this file (including controller arguments) ->bind('$projectDir', '%kernel.project_dir%'); // ... }; Read the article about binding arguments by name and/or type to learn more about this powerful feature. Finally, if some service needs access to lots of parameters, instead of injecting each of them individually, you can inject all the application parameters at once by type-hinting any of its constructor arguments with the Symfony\\\\Component\\\\DependencyInjection\\\\ParameterBag\\\\ContainerBagInterface:: // src/Service/MessageGenerator.php namespace App\\Service; // ... use Symfony\\Component\\DependencyInjection\\ParameterBag\\ContainerBagInterface; class MessageGenerator { public function __construct( private ContainerBagInterface $params, ) { } public function someMethod(): void { // get any container parameter from $this->params, which stores all of them $sender = $this->params->get('mailer_sender'); // ... } } Using PHP ConfigBuilders Writing PHP config is sometimes difficult because you end up with large nested arrays and you have no autocompletion help from your favorite IDE. A way to address this is to use \"ConfigBuilders\". They are objects that will help you build these arrays. Symfony generates the ConfigBuilder classes automatically in the kernel build directory for all the bundles installed in your application. By convention they all live in the namespace Symfony\\Config:: // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $security->firewall('main') ->pattern('^/*') ->lazy(true) ->security(false); $security ->roleHierarchy('ROLE_ADMIN', ['ROLE_USER']) ->roleHierarchy('ROLE_SUPER_ADMIN', ['ROLE_ADMIN', 'ROLE_ALLOWED_TO_SWITCH']) ->accessControl() ->path('^/user') ->roles('ROLE_USER'); $security->accessControl(['path' => '^/admin', 'roles' => 'ROLE_ADMIN']); }; Only root classes in the namespace Symfony\\Config are ConfigBuilders. Nested configs (e.g. \\Symfony\\Config\\Framework\\CacheConfig) are regular PHP objects which aren't autowired when using them as an argument type. In order to get ConfigBuilders autocompletion in your IDE/editor, make sure to not exclude the directory where these classes are generated (by default, in var/cache/dev/Symfony/Config/).", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "configuration.rst_fixed_12", "source": "configuration.rst", "text": "for all the bundles installed in your application. By convention they all live in the namespace Symfony\\Config:: // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $security->firewall('main') ->pattern('^/*') ->lazy(true) ->security(false); $security ->roleHierarchy('ROLE_ADMIN', ['ROLE_USER']) ->roleHierarchy('ROLE_SUPER_ADMIN', ['ROLE_ADMIN', 'ROLE_ALLOWED_TO_SWITCH']) ->accessControl() ->path('^/user') ->roles('ROLE_USER'); $security->accessControl(['path' => '^/admin', 'roles' => 'ROLE_ADMIN']); }; Only root classes in the namespace Symfony\\Config are ConfigBuilders. Nested configs (e.g. \\Symfony\\Config\\Framework\\CacheConfig) are regular PHP objects which aren't autowired when using them as an argument type. In order to get ConfigBuilders autocompletion in your IDE/editor, make sure to not exclude the directory where these classes are generated (by default, in var/cache/dev/Symfony/Config/). Keep Going! Congratulations! You've tackled the basics of Symfony. Next, learn about *each* part of Symfony individually by following the guides. Check out: * /forms * /doctrine * /service_container * /security * /mailer * /logging And all the other topics related to configuration: :maxdepth: 1 :glob: configuration/*", "title": "Configuring Symfony", "category": "configuration"}
{"chunk_id": "console.rst_fixed_0", "source": "console.rst", "text": "Console Commands The Symfony framework provides lots of commands through the bin/console script (e.g. the well-known bin/console cache:clear command). These commands are created with the Console component . You can also use it to create your own commands. Running Commands Each Symfony application comes with a large set of commands. You can use the list command to view all available commands in the application: $ php bin/console list ... Available commands: about Display information about the current project completion Dump the shell completion script help Display help for a command list List commands assets assets:install Install bundle's web assets under a public directory cache cache:clear Clear the cache ... list is the default command, so running php bin/console is the same. If you find the command you need, you can run it with the --help option to view the command's documentation: $ php bin/console assets:install --help --help is one of the built-in global options from the Console component, which are available for all commands, including those you can create. To learn more about them, you can read this section . APP_ENV & APP_DEBUG Console commands run in the environment defined in the APP_ENV variable of the .env file, which is dev by default. It also reads the APP_DEBUG value to turn \"debug\" mode on or off (it defaults to 1, which is on). To run the command in another environment or debug mode, edit the value of APP_ENV and APP_DEBUG. You can also define this env vars when running the command, for instance: # clears the cache for the prod environment $ APP_ENV=prod php bin/console cache:clear Console Completion If you are using the Bash, Zsh or Fish shell, you can install Symfony's completion script to get auto completion when typing commands in the terminal. All commands support name and option completion, and some can even complete values. :alt: The terminal completes the command name \"secrets:remove\" and the argument \"SOME_OTHER_SECRET\". First, you have to install the completion script *once*. Run bin/console completion --help for the installation instructions for your shell. When using Bash, make sure you installed and setup the \"bash completion\" package for your OS (typically named bash-completion). After installing and restarting your terminal, you're all set to use completion (by default, by pressing the Tab key). Many PHP tools are built using the Symfony Console component (e.g. Composer, PHPstan and Behat). If they are using version 5.4 or higher, you can also install their completion script to enable console completion: $ php vendor/bin/phpstan completion --help $ composer completion --help If you are using the Symfony CLI tool, follow these instructions to enable autocompletion. Creating a Command Commands are defined in classes and auto-registered using the #[AsCommand] attribute. For example, you may want a command to create a user:: // src/Command/CreateUserCommand.php namespace App\\Command; use Symfony\\Component\\Console\\Attribute\\AsCommand; use Symfony\\Component\\Console\\Command\\Command; // the name of the command is what users type after \"php bin/console\" #[AsCommand(name: 'app:create-user')] class CreateUserCommand { public function __invoke(): int { // ... put here the code to create the user", "title": "Console Commands", "category": "console"}
{"chunk_id": "console.rst_fixed_1", "source": "console.rst", "text": "you can also install their completion script to enable console completion: $ php vendor/bin/phpstan completion --help $ composer completion --help If you are using the Symfony CLI tool, follow these instructions to enable autocompletion. Creating a Command Commands are defined in classes and auto-registered using the #[AsCommand] attribute. For example, you may want a command to create a user:: // src/Command/CreateUserCommand.php namespace App\\Command; use Symfony\\Component\\Console\\Attribute\\AsCommand; use Symfony\\Component\\Console\\Command\\Command; // the name of the command is what users type after \"php bin/console\" #[AsCommand(name: 'app:create-user')] class CreateUserCommand { public function __invoke(): int { // ... put here the code to create the user // this method must return an integer number with the \"exit status code\" // of the command. You can also use these constants to make code more readable // return this if there was no problem running the command // (it's equivalent to returning int(0)) return Command::SUCCESS; // or return this if some error happened during the execution // (it's equivalent to returning int(1)) // return Command::FAILURE; // or return this to indicate incorrect command usage; e.g. invalid options // or missing arguments (it's equivalent to returning int(2)) // return Command::INVALID } } Support for invokable commands that don't extend the base Command class was introduced in Symfony 7.3 If you can't use PHP attributes, register the command as a service and tag it with the console.command tag. If you're using the default services.yaml configuration , this is already done for you, thanks to autoconfiguration . You can also use #[AsCommand] to add a description and longer help text for the command:: #[AsCommand( name: 'app:create-user', description: 'Creates a new user.', // the command description shown when running \"php bin/console list\" help: 'This command allows you to create a user...', // the command help shown when running the command with the \"--help\" option )] class CreateUserCommand { public function __invoke(): int { // ... } } Additionally, you can extend the Symfony\\\\Component\\\\Console\\\\Command\\\\Command class to leverage advanced features like lifecycle hooks (e.g. Symfony\\\\Component\\\\Console\\\\Command\\\\Command::initialize and and Symfony\\\\Component\\\\Console\\\\Command\\\\Command::interact):: use Symfony\\Component\\Console\\Attribute\\AsCommand; use Symfony\\Component\\Console\\Command\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; #[AsCommand(name: 'app:create-user')] class CreateUserCommand extends Command { public function initialize(InputInterface $input, OutputInterface $output): void { // ... } public function interact(InputInterface $input, OutputInterface $output): void { // ... } public function __invoke(): int { // ... } } Running the Command After configuring and registering the command, you can run it in the terminal: $ php bin/console app:create-user As you might expect, this command will do nothing as you didn't write any logic yet. Add your own logic inside the __invoke() method. Console Output The __invoke() method has access to the output stream to write messages to the console:: // ... public function __invoke(OutputInterface $output): int { // outputs multiple lines to the console (adding \"\\n\" at the end of each line) $output->writeln([ 'User Creator', '============', '', ]); // the value returned by someMethod() can be an iterator (https://php.net/iterator) // that generates and returns the messages with the 'yield' PHP keyword $output->writeln($this->someMethod()); // outputs a message followed by", "title": "Console Commands", "category": "console"}
{"chunk_id": "console.rst_fixed_2", "source": "console.rst", "text": "As you might expect, this command will do nothing as you didn't write any logic yet. Add your own logic inside the __invoke() method. Console Output The __invoke() method has access to the output stream to write messages to the console:: // ... public function __invoke(OutputInterface $output): int { // outputs multiple lines to the console (adding \"\\n\" at the end of each line) $output->writeln([ 'User Creator', '============', '', ]); // the value returned by someMethod() can be an iterator (https://php.net/iterator) // that generates and returns the messages with the 'yield' PHP keyword $output->writeln($this->someMethod()); // outputs a message followed by a \"\\n\" $output->writeln('Whoa!'); // outputs a message without adding a \"\\n\" at the end of the line $output->write('You are about to '); $output->write('create a user.'); return Command::SUCCESS; } Now, try executing the command: $ php bin/console app:create-user User Creator Whoa! You are about to create a user. Output Sections The regular console output can be divided into multiple independent regions called \"output sections\". Create one or more of these sections when you need to clear and overwrite the output information. Sections are created with the ConsoleOutput::section() method, which returns an instance of Symfony\\\\Component\\\\Console\\\\Output\\\\ConsoleSectionOutput:: // ... use Symfony\\Component\\Console\\Output\\ConsoleOutputInterface; #[AsCommand(name: 'app:my-command')] class MyCommand { public function __invoke(OutputInterface $output): int { if (!$output instanceof ConsoleOutputInterface) { throw new \\LogicException('This command accepts only an instance of \"ConsoleOutputInterface\".'); } $section1 = $output->section(); $section2 = $output->section(); $section1->writeln('Hello'); $section2->writeln('World!'); sleep(1); // Output displays \"Hello\\nWorld!\\n\" // overwrite() replaces all the existing section contents with the given content $section1->overwrite('Goodbye'); sleep(1); // Output now displays \"Goodbye\\nWorld!\\n\" // clear() deletes all the section contents... $section2->clear(); sleep(1); // Output now displays \"Goodbye\\n\" // ...but you can also delete a given number of lines // (this example deletes the last two lines of the section) $section1->clear(2); sleep(1); // Output is now completely empty! // setting the max height of a section will make new lines replace the old ones $section1->setMaxHeight(2); $section1->writeln('Line1'); $section1->writeln('Line2'); $section1->writeln('Line3'); return Command::SUCCESS; } } A new line is appended automatically when displaying information in a section. Output sections let you manipulate the Console output in advanced ways, such as displaying multiple progress bars which are updated independently and appending rows to tables that have already been rendered. Terminals only allow overwriting the visible content, so you must take into account the console height when trying to write/overwrite section contents. Console Input Use input options or arguments to pass information to the command:: use Symfony\\Component\\Console\\Attribute\\Argument; // The #[Argument] attribute configures $username as a // required input argument and its value is automatically // passed to this parameter public function __invoke(#[Argument('The username of the user.')] string $username, OutputInterface $output): int { $output->writeln([ 'User Creator', '============', '', ]); $output->writeln('Username: '.$username); return Command::SUCCESS; } Now, you can pass the username to the command: $ php bin/console app:create-user Wouter User Creator Username: Wouter Read /console/input for more information about console options and arguments. Getting Services from the Service Container To actually create a new user, the command has to access some services . Since your", "title": "Console Commands", "category": "console"}
{"chunk_id": "console.rst_fixed_3", "source": "console.rst", "text": "the command:: use Symfony\\Component\\Console\\Attribute\\Argument; // The #[Argument] attribute configures $username as a // required input argument and its value is automatically // passed to this parameter public function __invoke(#[Argument('The username of the user.')] string $username, OutputInterface $output): int { $output->writeln([ 'User Creator', '============', '', ]); $output->writeln('Username: '.$username); return Command::SUCCESS; } Now, you can pass the username to the command: $ php bin/console app:create-user Wouter User Creator Username: Wouter Read /console/input for more information about console options and arguments. Getting Services from the Service Container To actually create a new user, the command has to access some services . Since your command is already registered as a service, you can use normal dependency injection. Imagine you have a App\\Service\\UserManager service that you want to access:: // ... use App\\Service\\UserManager; use Symfony\\Component\\Console\\Attribute\\Argument; use Symfony\\Component\\Console\\Attribute\\AsCommand; #[AsCommand(name: 'app:create-user')] class CreateUserCommand { public function __construct( private UserManager $userManager ) { } public function __invoke(#[Argument] string $username, OutputInterface $output): int { // ... $this->userManager->create($username); $output->writeln('User successfully generated!'); return Command::SUCCESS; } } Command Lifecycle Commands have three lifecycle methods that are invoked when running the command: Symfony\\\\Component\\\\Console\\\\Command\\\\Command::initialize *(optional)* This method is executed before the interact() and the execute() methods. Its main purpose is to initialize variables used in the rest of the command methods. Symfony\\\\Component\\\\Console\\\\Command\\\\Command::interact *(optional)* This method is executed after initialize() and before execute(). Its purpose is to check if some of the options/arguments are missing and interactively ask the user for those values. This is the last place where you can ask for missing required options/arguments. This method is called before validating the input. Note that it will not be called when the command is run without interaction (e.g. when passing the --no-interaction global option flag). __invoke() (or Symfony\\\\Component\\\\Console\\\\Command\\\\Command::execute) *(required)* This method is executed after interact() and initialize(). It contains the logic you want the command to execute and it must return an integer which will be used as the command `exit status`_. Testing Commands Symfony provides several tools to help you test your commands. The most useful one is the Symfony\\\\Component\\\\Console\\\\Tester\\\\CommandTester class. It uses special input and output classes to ease testing without a real console:: // tests/Command/CreateUserCommandTest.php namespace App\\Tests\\Command; use Symfony\\Bundle\\FrameworkBundle\\Console\\Application; use Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase; use Symfony\\Component\\Console\\Tester\\CommandTester; class CreateUserCommandTest extends KernelTestCase { public function testExecute(): void { self::bootKernel(); $application = new Application(self::$kernel); $command = $application->find('app:create-user'); $commandTester = new CommandTester($command); $commandTester->execute([ // pass arguments to the helper 'username' => 'Wouter', // prefix the key with two dashes when passing options, // e.g: '--some-option' => 'option_value', // use brackets for testing array value, // e.g: '--some-option' => ['option_value'], ]); $commandTester->assertCommandIsSuccessful(); // the output of the command in the console $output = $commandTester->getDisplay(); $this->assertStringContainsString('Username: Wouter', $output); // ... } } If you are using a single-command application , call setAutoExit(false) on it to get the command result in CommandTester. You can also test a whole console application by using Symfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester. When testing commands using the CommandTester class, console events are not dispatched. If you need to test those events, use the Symfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester instead. When testing commands using the", "title": "Console Commands", "category": "console"}
{"chunk_id": "console.rst_fixed_4", "source": "console.rst", "text": "dashes when passing options, // e.g: '--some-option' => 'option_value', // use brackets for testing array value, // e.g: '--some-option' => ['option_value'], ]); $commandTester->assertCommandIsSuccessful(); // the output of the command in the console $output = $commandTester->getDisplay(); $this->assertStringContainsString('Username: Wouter', $output); // ... } } If you are using a single-command application , call setAutoExit(false) on it to get the command result in CommandTester. You can also test a whole console application by using Symfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester. When testing commands using the CommandTester class, console events are not dispatched. If you need to test those events, use the Symfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester instead. When testing commands using the Symfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester class, don't forget to disable the auto exit flag:: $application = new Application(); $application->setAutoExit(false); $tester = new ApplicationTester($application); When testing InputOption::VALUE_NONE command options, you must pass true to them:: $commandTester = new CommandTester($command); $commandTester->execute(['--some-option' => true]); When using the Console component in a standalone project, use Symfony\\\\Component\\\\Console\\\\Application and extend the normal \\PHPUnit\\Framework\\TestCase. When testing your commands, it could be useful to understand how your command reacts on different settings like the width and the height of the terminal, or even the color mode being used. You have access to such information thanks to the Symfony\\\\Component\\\\Console\\\\Terminal class:: use Symfony\\Component\\Console\\Terminal; $terminal = new Terminal(); // gets the number of lines available $height = $terminal->getHeight(); // gets the number of columns available $width = $terminal->getWidth(); // gets the color mode $colorMode = $terminal->getColorMode(); // changes the color mode $colorMode = $terminal->setColorMode(AnsiColorMode::Ansi24); Logging Command Errors Whenever an exception is thrown while running commands, Symfony adds a log message for it including the entire failing command. In addition, Symfony registers an event subscriber to listen to the ConsoleEvents::TERMINATE event and adds a log message whenever a command doesn't finish with the 0 `exit status`_. Using Events And Handling Signals When a command is running, many events are dispatched, one of them allows to react to signals, read more in this section . Profiling Commands Symfony allows to profile the execution of any command, including yours. First, make sure that the debug mode and the profiler are enabled. Then, add the --profile option when running the command: $ php bin/console --profile app:my-command Symfony will now collect data about the command execution, which is helpful to debug errors or check other issues. When the command execution is over, the profile is accessible through the web page of the profiler. If you run the command in verbose mode (adding the -v option), Symfony will display in the output a clickable link to the command profile (if your terminal supports links). If you run it in debug verbosity (-vvv) you'll also see the time and memory consumed by the command. When profiling the messenger:consume command from the Messenger component, add the --no-reset option to the command or you won't get any profile. Moreover, consider using the --limit option to only process a few messages to make the profile more readable in the profiler. Learn More :maxdepth: 1 :glob: console/* The console component also contains a set of \"helpers\"", "title": "Console Commands", "category": "console"}
{"chunk_id": "console.rst_fixed_5", "source": "console.rst", "text": "mode (adding the -v option), Symfony will display in the output a clickable link to the command profile (if your terminal supports links). If you run it in debug verbosity (-vvv) you'll also see the time and memory consumed by the command. When profiling the messenger:consume command from the Messenger component, add the --no-reset option to the command or you won't get any profile. Moreover, consider using the --limit option to only process a few messages to make the profile more readable in the profiler. Learn More :maxdepth: 1 :glob: console/* The console component also contains a set of \"helpers\" - different small tools capable of helping you with different tasks: * /components/console/helpers/questionhelper: interactively ask the user for information * /components/console/helpers/formatterhelper: customize the output colorization * /components/console/helpers/progressbar: shows a progress bar * /components/console/helpers/progressindicator: shows a progress indicator * /components/console/helpers/table: displays tabular data as a table * /components/console/helpers/debug_formatter: provides functions to output debug information when running an external program * /components/console/helpers/processhelper: allows to run processes using DebugFormatterHelper * /components/console/helpers/cursor: allows to manipulate the cursor in the terminal * /components/console/helpers/tree: displays tree-like structures", "title": "Console Commands", "category": "console"}
{"chunk_id": "doctrine.rst_fixed_0", "source": "doctrine.rst", "text": "Databases and the Doctrine ORM :class: screencast Do you prefer video tutorials? Check out the `Doctrine screencast series`_. Symfony provides all the tools you need to use databases in your applications thanks to `Doctrine`_, the best set of PHP libraries to work with databases. These tools support relational databases like MySQL and PostgreSQL and also NoSQL databases like MongoDB. Databases are a broad topic, so the documentation is divided in three articles: * This article explains the recommended way to work with **relational databases** in Symfony applications; * Read this other article if you need **low-level access** to perform raw SQL queries to relational databases (similar to PHP's `PDO`_); * Read `DoctrineMongoDBBundle docs`_ if you are working with **MongoDB databases**. Installing Doctrine First, install Doctrine support via the orm Symfony pack , as well as the MakerBundle, which will help generate some code: $ composer require symfony/orm-pack $ composer require --dev symfony/maker-bundle Configuring the Database The database connection information is stored as an environment variable called DATABASE_URL. For development, you can find and customize this inside .env: # .env (or override DATABASE_URL in .env.local to avoid committing your changes) # customize this line! DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=8.0.37\" # to use mariadb: # Before doctrine/dbal < 3.7 # DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=mariadb-10.5.8\" # Since doctrine/dbal 3.7 # DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=10.5.8-MariaDB\" # to use sqlite: # DATABASE_URL=\"sqlite:///%kernel.project_dir%/var/app.db\" # to use postgresql: # DATABASE_URL=\"postgresql://db_user:db_password@127.0.0.1:5432/db_name?serverVersion=12.19 (Debian 12.19-1.pgdg120+1)&charset=utf8\" # to use oracle: # DATABASE_URL=\"oci8://db_user:db_password@127.0.0.1:1521/db_name\" If the username, password, host or database name contain any character considered special in a URI (such as : / ? # [ ] @ ! $ & ' ( ) * + , ; =), you must encode them. See `RFC 3986`_ for the full list of reserved characters. You can use the urlencode function to encode them or the urlencode environment variable processor . In this case you need to remove the resolve: prefix in config/packages/doctrine.yaml to avoid errors: url: '%env(DATABASE_URL)%' Now that your connection parameters are setup, Doctrine can create the db_name database for you: $ php bin/console doctrine:database:create There are more options in config/packages/doctrine.yaml that you can configure, including your server_version (e.g. 8.0.37 if you're using MySQL 8.0.37), which may affect how Doctrine functions. There are many other Doctrine commands. Run php bin/console list doctrine to see a full list. Creating an Entity Class Suppose you're building an application where products need to be displayed. Without even thinking about Doctrine or databases, you already know that you need a Product object to represent those products. You can use the make:entity command to create this class and any fields you need. The command will ask you some questions - answer them like done below: $ php bin/console make:entity Class name of the entity to create or update: > Product New property name (press <return> to stop adding fields): > name Field type (enter ? to see all types) [string]: > string Field length [255]: > 255 Can this field be null in the database (nullable) (yes/no) [no]: > no New property name (press <return> to stop", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_1", "source": "doctrine.rst", "text": "that you need a Product object to represent those products. You can use the make:entity command to create this class and any fields you need. The command will ask you some questions - answer them like done below: $ php bin/console make:entity Class name of the entity to create or update: > Product New property name (press <return> to stop adding fields): > name Field type (enter ? to see all types) [string]: > string Field length [255]: > 255 Can this field be null in the database (nullable) (yes/no) [no]: > no New property name (press <return> to stop adding fields): > price Field type (enter ? to see all types) [string]: > integer Can this field be null in the database (nullable) (yes/no) [no]: > no New property name (press <return> to stop adding fields): > (press enter again to finish) Whoa! You now have a new src/Entity/Product.php file:: // src/Entity/Product.php namespace App\\Entity; use App\\Repository\\ProductRepository; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity(repositoryClass: ProductRepository::class)] class Product { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column] private ?int $id = null; #[ORM\\Column(length: 255)] private ?string $name = null; #[ORM\\Column] private ?int $price = null; public function getId(): ?int { return $this->id; } // ... getter and setter methods } Starting in `MakerBundle`_: v1.57.0 - You can pass either --with-uuid or --with-ulid to make:entity. Leveraging Symfony's Uid Component , this generates an entity with the id type as Uuid or Ulid instead of int. Starting in v1.44.0 - `MakerBundle`_: only supports entities using PHP attributes. Confused why the price is an integer? Don't worry: this is just an example. But, storing prices as integers (e.g. 100 = $1 USD) can avoid rounding issues. There is a `limit of 767 bytes for the index key prefix`_ when using InnoDB tables in MySQL 5.6 and earlier versions. String columns with 255 character length and utf8mb4 encoding surpass that limit. This means that any column of type string and unique=true must set its maximum length to 190. Otherwise, you'll see this error: *\"[PDOException] SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes\"*. This class is called an \"entity\". And soon, you'll be able to save and query Product objects to a product table in your database. Each property in the Product entity can be mapped to a column in that table. This is usually done with attributes: the #[ORM\\Column(...)] comments that you see above each property: <object data=\"_images/doctrine/mapping_single_entity.svg\" type=\"image/svg+xml\" alt=\"Doctrine mapping between properties of a Product PHP object and the data in the product database table\" ></object> The make:entity command is a tool to make life easier. But this is *your* code: add/remove fields, add/remove methods or update configuration. Doctrine supports a wide variety of field types, each with their own options. Check out the `list of Doctrine mapping types`_ in the Doctrine documentation. If you want to use XML instead of attributes, add type: xml and dir: '%kernel.project_dir%/config/doctrine' to the entity mappings in your config/packages/doctrine.yaml file. Be careful not to use", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_2", "source": "doctrine.rst", "text": "see above each property: <object data=\"_images/doctrine/mapping_single_entity.svg\" type=\"image/svg+xml\" alt=\"Doctrine mapping between properties of a Product PHP object and the data in the product database table\" ></object> The make:entity command is a tool to make life easier. But this is *your* code: add/remove fields, add/remove methods or update configuration. Doctrine supports a wide variety of field types, each with their own options. Check out the `list of Doctrine mapping types`_ in the Doctrine documentation. If you want to use XML instead of attributes, add type: xml and dir: '%kernel.project_dir%/config/doctrine' to the entity mappings in your config/packages/doctrine.yaml file. Be careful not to use reserved SQL keywords as your table or column names (e.g. GROUP or USER). See Doctrine's `Reserved SQL keywords documentation`_ for details on how to escape these. Or, change the table name with #[ORM\\Table(name: 'groups')] above the class or configure the column name with the name: 'group_name' option. Migrations: Creating the Database Tables/Schema The Product class is fully-configured and ready to save to a product table. If you just defined this class, your database doesn't actually have the product table yet. To add it, you can leverage the `DoctrineMigrationsBundle`_, which is already installed: $ php bin/console make:migration Starting in `MakerBundle`_: v1.56.0 - Passing --formatted to make:migration generates a nice and tidy migration file. If everything worked, you should see something like this: SUCCESS! Next: Review the new migration \"migrations/Version20211116204726.php\" Then: Run the migration with php bin/console doctrine:migrations:migrate If you open this file, it contains the SQL needed to update your database! To run that SQL, execute your migrations: $ php bin/console doctrine:migrations:migrate This command executes all migration files that have not already been run against your database. You should run this command on production when you deploy to keep your production database up-to-date. Migrations & Adding more Fields But what if you need to add a new field property to Product, like a description? You can edit the class to add the new property. But, you can also use make:entity again: $ php bin/console make:entity Class name of the entity to create or update > Product New property name (press <return> to stop adding fields): > description Field type (enter ? to see all types) [string]: > text Can this field be null in the database (nullable) (yes/no) [no]: > no New property name (press <return> to stop adding fields): > (press enter again to finish) This adds the new description property and getDescription() and setDescription() methods: // src/Entity/Product.php // ... + use Doctrine\\DBAL\\Types\\Types; class Product { // ... + #[ORM\\Column(type: Types::TEXT)] + private string $description; // getDescription() & setDescription() were also added } The new property is mapped, but it doesn't exist yet in the product table. No problem! Generate a new migration: $ php bin/console make:migration This time, the SQL in the generated file will look like this: ALTER TABLE product ADD description LONGTEXT NOT NULL The migration system is *smart*. It compares all of your entities with the current state of the database and generates the SQL needed", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_3", "source": "doctrine.rst", "text": "property and getDescription() and setDescription() methods: // src/Entity/Product.php // ... + use Doctrine\\DBAL\\Types\\Types; class Product { // ... + #[ORM\\Column(type: Types::TEXT)] + private string $description; // getDescription() & setDescription() were also added } The new property is mapped, but it doesn't exist yet in the product table. No problem! Generate a new migration: $ php bin/console make:migration This time, the SQL in the generated file will look like this: ALTER TABLE product ADD description LONGTEXT NOT NULL The migration system is *smart*. It compares all of your entities with the current state of the database and generates the SQL needed to synchronize them! Like before, execute your migrations: $ php bin/console doctrine:migrations:migrate If you are using an SQLite database, you'll see the following error: *PDOException: SQLSTATE[HY000]: General error: 1 Cannot add a NOT NULL column with default value NULL*. Add a nullable=true option to the description property to fix the problem. This will only execute the *one* new migration file, because DoctrineMigrationsBundle knows that the first migration was already executed earlier. Behind the scenes, it manages a migration_versions table to track this. Each time you make a change to your schema, run these two commands to generate the migration and then execute it. Be sure to commit the migration files and execute them when you deploy. If you prefer to add new properties manually, the make:entity command can generate the getter & setter methods for you: $ php bin/console make:entity --regenerate If you make some changes and want to regenerate *all* getter/setter methods, also pass --overwrite. Persisting Objects to the Database It's time to save a Product object to the database! Let's create a new controller to experiment: $ php bin/console make:controller ProductController Inside the controller, you can create a new Product object, set data on it, and save it:: // src/Controller/ProductController.php namespace App\\Controller; // ... use App\\Entity\\Product; use Doctrine\\ORM\\EntityManagerInterface; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class ProductController extends AbstractController { #[Route('/product', name: 'create_product')] public function createProduct(EntityManagerInterface $entityManager): Response { $product = new Product(); $product->setName('Keyboard'); $product->setPrice(1999); $product->setDescription('Ergonomic and stylish!'); // tell Doctrine you want to (eventually) save the Product (no queries yet) $entityManager->persist($product); // actually executes the queries (i.e. the INSERT query) $entityManager->flush(); return new Response('Saved new product with id '.$product->getId()); } } Try it out! http://localhost:8000/product Congratulations! You just created your first row in the product table. To prove it, you can query the database directly: $ php bin/console dbal:run-sql 'SELECT * FROM product' # on Windows systems not using Powershell, run this command instead: # php bin/console dbal:run-sql \"SELECT * FROM product\" Take a look at the previous example in more detail: * **line 13** The EntityManagerInterface $entityManager argument tells Symfony to inject the Entity Manager service into the controller method. This object is responsible for saving objects to, and fetching objects from, the database. * **lines 15-18** In this section, you instantiate and work with the $product object like any other normal PHP object. * **line 21** The persist($product) call tells Doctrine to \"manage\" the $product object. This does", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_4", "source": "doctrine.rst", "text": "* FROM product' # on Windows systems not using Powershell, run this command instead: # php bin/console dbal:run-sql \"SELECT * FROM product\" Take a look at the previous example in more detail: * **line 13** The EntityManagerInterface $entityManager argument tells Symfony to inject the Entity Manager service into the controller method. This object is responsible for saving objects to, and fetching objects from, the database. * **lines 15-18** In this section, you instantiate and work with the $product object like any other normal PHP object. * **line 21** The persist($product) call tells Doctrine to \"manage\" the $product object. This does **not** cause a query to be made to the database. * **line 24** When the flush() method is called, Doctrine looks through all of the objects that it's managing to see if they need to be persisted to the database. In this example, the $product object's data doesn't exist in the database, so the entity manager executes an INSERT query, creating a new row in the product table. If the flush() call fails, a Doctrine\\ORM\\ORMException exception is thrown. See `Transactions and Concurrency`_. Whether you're creating or updating objects, the workflow is always the same: Doctrine is smart enough to know if it should INSERT or UPDATE your entity. Validating Objects The Symfony validator can reuse Doctrine metadata to perform some basic validation tasks. First, add or configure the auto_mapping option to define which entities should be introspected by Symfony to add automatic validation constraints. Consider the following controller code:: // src/Controller/ProductController.php namespace App\\Controller; use App\\Entity\\Product; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; use Symfony\\Component\\Validator\\Validator\\ValidatorInterface; // ... class ProductController extends AbstractController { #[Route('/product', name: 'create_product')] public function createProduct(ValidatorInterface $validator): Response { $product = new Product(); // ... update the product data somehow (e.g. with a form) ... $errors = $validator->validate($product); if (count($errors) > 0) { return new Response((string) $errors, 400); } // ... } } Although the Product entity doesn't define any explicit validation configuration , if the auto_mapping option includes it in the list of entities to introspect, Symfony will infer some validation rules for it and will apply them. For example, given that the name property can't be null in the database, a NotNull constraint is added automatically to the property (if it doesn't contain that constraint already). The following table summarizes the mapping between Doctrine metadata and the corresponding validation constraints added automatically by Symfony: ================== ========================================================= ===== Doctrine attribute Validation constraint Notes ================== ========================================================= ===== nullable=false NotNull Requires installing the PropertyInfo component type Type Requires installing the PropertyInfo component unique=true UniqueEntity length Length ================== ========================================================= ===== Because the Form component as well as `API Platform`_ internally use the Validator component, all your forms and web APIs will also automatically benefit from these automatic validation constraints. This automatic validation is a nice feature to improve your productivity, but it doesn't replace the validation configuration entirely. You still need to add some validation constraints to ensure that data provided by the user is correct. Fetching Objects from the Database Fetching an object", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_5", "source": "doctrine.rst", "text": "constraint Notes ================== ========================================================= ===== nullable=false NotNull Requires installing the PropertyInfo component type Type Requires installing the PropertyInfo component unique=true UniqueEntity length Length ================== ========================================================= ===== Because the Form component as well as `API Platform`_ internally use the Validator component, all your forms and web APIs will also automatically benefit from these automatic validation constraints. This automatic validation is a nice feature to improve your productivity, but it doesn't replace the validation configuration entirely. You still need to add some validation constraints to ensure that data provided by the user is correct. Fetching Objects from the Database Fetching an object back out of the database is even easier. Suppose you want to be able to go to /product/1 to see your new product:: // src/Controller/ProductController.php namespace App\\Controller; use App\\Entity\\Product; use Doctrine\\ORM\\EntityManagerInterface; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; // ... class ProductController extends AbstractController { #[Route('/product/{id}', name: 'product_show')] public function show(EntityManagerInterface $entityManager, int $id): Response { $product = $entityManager->getRepository(Product::class)->find($id); if (!$product) { throw $this->createNotFoundException( 'No product found for id '.$id ); } return new Response('Check out this great product: '.$product->getName()); // or render a template // in the template, print things with {{ product.name }} // return $this->render('product/show.html.twig', ['product' => $product]); } } Another possibility is to use the ProductRepository using Symfony's autowiring and injected by the dependency injection container:: // src/Controller/ProductController.php namespace App\\Controller; use App\\Entity\\Product; use App\\Repository\\ProductRepository; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; // ... class ProductController extends AbstractController { #[Route('/product/{id}', name: 'product_show')] public function show(ProductRepository $productRepository, int $id): Response { $product = $productRepository ->find($id); // ... } } Try it out! http://localhost:8000/product/1 When you query for a particular type of object, you always use what's known as its \"repository\". You can think of a repository as a PHP class whose only job is to help you fetch entities of a certain class. Once you have a repository object, you have many helper methods:: $repository = $entityManager->getRepository(Product::class); // look for a single Product by its primary key (usually \"id\") $product = $repository->find($id); // look for a single Product by name $product = $repository->findOneBy(['name' => 'Keyboard']); // or find by name and price $product = $repository->findOneBy([ 'name' => 'Keyboard', 'price' => 1999, ]); // look for multiple Product objects matching the name, ordered by price $products = $repository->findBy( ['name' => 'Keyboard'], ['price' => 'ASC'] ); // look for *all* Product objects $products = $repository->findAll(); You can also add *custom* methods for more complex queries! More on that later in the doctrine-queries section. When rendering an HTML page, the web debug toolbar at the bottom of the page will display the number of queries and the time it took to execute them: :alt: The web dev toolbar showing the Doctrine item. :class: with-browser If the number of database queries is too high, the icon will turn yellow to indicate that something may not be correct. Click on the icon to open the Symfony Profiler and see the exact queries that were executed. If you don't see the web debug toolbar, install the profiler Symfony pack by", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_6", "source": "doctrine.rst", "text": "on that later in the doctrine-queries section. When rendering an HTML page, the web debug toolbar at the bottom of the page will display the number of queries and the time it took to execute them: :alt: The web dev toolbar showing the Doctrine item. :class: with-browser If the number of database queries is too high, the icon will turn yellow to indicate that something may not be correct. Click on the icon to open the Symfony Profiler and see the exact queries that were executed. If you don't see the web debug toolbar, install the profiler Symfony pack by running this command: composer require --dev symfony/profiler-pack. For more information, read the Symfony profiler documentation . Automatically Fetching Objects (EntityValueResolver) Autowiring of the EntityValueResolver was introduced in DoctrineBundle 2.7.1. In many cases, you can use the EntityValueResolver to do the query for you automatically! You can simplify the controller to:: // src/Controller/ProductController.php namespace App\\Controller; use App\\Entity\\Product; use App\\Repository\\ProductRepository; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; // ... class ProductController extends AbstractController { #[Route('/product/{id}')] public function show(Product $product): Response { // use the Product! // ... } } That's it! The attribute uses the {id} from the route to query for the Product by the id column. If it's not found, a 404 error is thrown. You can change this behavior by making the controller argument optional. In that case, no 404 is thrown automatically and you're free to handle the missing entity yourself:: #[Route('/product/{id}')] public function show(?Product $product): Response { if (null === $product) { // run your own logic to return a custom response } // ... } When enabled globally, it's possible to disable the behavior on a specific controller, by using the MapEntity set to disabled:: public function show( #[CurrentUser] #[MapEntity(disabled: true)] User $user ): Response { // User is not resolved by the EntityValueResolver // ... } Fetch Automatically If your route wildcards match properties on your entity, then the resolver will automatically fetch them:: /** * Fetch via primary key because {id} is in the route. */ #[Route('/product/{id}')] public function showByPk(Product $product): Response { } /** * Perform a findOneBy() where the slug property matches {slug}. */ #[Route('/product/{slug:product}')] public function showBySlug(Product $product): Response { } Automatic fetching works in these situations: * If {id} is in your route, then this is used to fetch by primary key via the find() method. * The resolver will attempt to do a findOneBy() fetch by using *all* of the wildcards in your route that are actually properties on your entity (non-properties are ignored). The {slug:product} syntax maps the route parameter named slug to the controller argument named $product. It also hints the resolver to look up the corresponding Product object from the database using the slug. Route parameter mapping was introduced in Symfony 7.1. You can also configure the mapping explicitly for any controller argument using the MapEntity attribute. You can even control the behavior of the EntityValueResolver by using the `MapEntity options`_ :: // src/Controller/ProductController.php namespace App\\Controller; use App\\Entity\\Product; use", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_7", "source": "doctrine.rst", "text": "a findOneBy() fetch by using *all* of the wildcards in your route that are actually properties on your entity (non-properties are ignored). The {slug:product} syntax maps the route parameter named slug to the controller argument named $product. It also hints the resolver to look up the corresponding Product object from the database using the slug. Route parameter mapping was introduced in Symfony 7.1. You can also configure the mapping explicitly for any controller argument using the MapEntity attribute. You can even control the behavior of the EntityValueResolver by using the `MapEntity options`_ :: // src/Controller/ProductController.php namespace App\\Controller; use App\\Entity\\Product; use Symfony\\Bridge\\Doctrine\\Attribute\\MapEntity; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; // ... class ProductController extends AbstractController { #[Route('/product/{slug}')] public function show( #[MapEntity(mapping: ['slug' => 'slug'])] Product $product ): Response { // use the Product! // ... } } Fetch via an Expression If automatic fetching doesn't work for your use case, you can write an expression using the ExpressionLanguage component :: #[Route('/product/{product_id}')] public function show( #[MapEntity(expr: 'repository.find(product_id)')] Product $product ): Response { } In the expression, the repository variable will be your entity's Repository class and any route wildcards - like {product_id} are available as variables. The repository method called in the expression can also return a list of entities. In that case, update the type of your controller argument:: #[Route('/posts_by/{author_id}')] public function authorPosts( #[MapEntity(class: Post::class, expr: 'repository.findBy({\"author\": author_id}, {}, 10)')] iterable $posts ): Response { } The mapping of the lists of entities was introduced in Symfony 7.1. This can also be used to help resolve multiple arguments:: #[Route('/product/{id}/comments/{comment_id}')] public function show( Product $product, #[MapEntity(expr: 'repository.find(comment_id)')] Comment $comment ): Response { } In the example above, the $product argument is handled automatically, but $comment is configured with the attribute since they cannot both follow the default convention. If you need to get other information from the request to query the database, you can also access the request in your expression thanks to the request variable. Let's say you want the first or the last comment of a product depending on a query parameter named sort:: #[Route('/product/{id}/comments')] public function show( Product $product, #[MapEntity(expr: 'repository.findOneBy({\"product\": id}, {\"createdAt\": request.query.get(\"sort\", \"DESC\")})')] Comment $comment ): Response { } Fetch via Interfaces Suppose your Product class implements an interface called ProductInterface. If you want to decouple your controllers from the concrete entity implementation, you can reference the entity by its interface instead. To enable this, first configure the resolve_target_entities option . Then, your controller can type-hint the interface, and the entity will be resolved automatically:: public function show( #[MapEntity] ProductInterface $product ): Response { // ... } Support for target entity resolution in the EntityValueResolver was introduced Symfony 7.3 MapEntity Options A number of options are available on the MapEntity attribute to control behavior: id If an id option is configured and matches a route parameter, then the resolver will find by the primary key:: #[Route('/product/{product_id}')] public function show( #[MapEntity(id: 'product_id')] Product $product ): Response { } mapping Configures the properties and values to use with the findOneBy() method: the", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_8", "source": "doctrine.rst", "text": ". Then, your controller can type-hint the interface, and the entity will be resolved automatically:: public function show( #[MapEntity] ProductInterface $product ): Response { // ... } Support for target entity resolution in the EntityValueResolver was introduced Symfony 7.3 MapEntity Options A number of options are available on the MapEntity attribute to control behavior: id If an id option is configured and matches a route parameter, then the resolver will find by the primary key:: #[Route('/product/{product_id}')] public function show( #[MapEntity(id: 'product_id')] Product $product ): Response { } mapping Configures the properties and values to use with the findOneBy() method: the key is the route placeholder name and the value is the Doctrine property name:: #[Route('/product/{category}/{slug}/comments/{comment_slug}')] public function show( #[MapEntity(mapping: ['category' => 'category', 'slug' => 'slug'])] Product $product, #[MapEntity(mapping: ['comment_slug' => 'slug'])] Comment $comment ): Response { } stripNull If true, then when findOneBy() is used, any values that are null will not be used for the query. objectManager By default, the EntityValueResolver uses the *default* object manager, but you can configure this:: #[Route('/product/{id}')] public function show( #[MapEntity(objectManager: 'foo')] Product $product ): Response { } evictCache If true, forces Doctrine to always fetch the entity from the database instead of cache. disabled If true, the EntityValueResolver will not try to replace the argument. message An optional custom message displayed when there's a Symfony\\\\Component\\\\HttpKernel\\\\Exception\\\\NotFoundHttpException, but **only in the development environment** (you won't see this message in production):: #[Route('/product/{product_id}')] public function show( #[MapEntity(id: 'product_id', message: 'The product does not exist')] Product $product ): Response { } The message option was introduced in Symfony 7.1. Updating an Object Once you've fetched an object from Doctrine, you interact with it the same as with any PHP model:: // src/Controller/ProductController.php namespace App\\Controller; use App\\Entity\\Product; use App\\Repository\\ProductRepository; use Doctrine\\ORM\\EntityManagerInterface; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; // ... class ProductController extends AbstractController { #[Route('/product/edit/{id}', name: 'product_edit')] public function update(EntityManagerInterface $entityManager, int $id): Response { $product = $entityManager->getRepository(Product::class)->find($id); if (!$product) { throw $this->createNotFoundException( 'No product found for id '.$id ); } $product->setName('New product name!'); $entityManager->flush(); return $this->redirectToRoute('product_show', [ 'id' => $product->getId() ]); } } Using Doctrine to edit an existing product consists of three steps: #. fetching the object from Doctrine; #. modifying the object; #. calling flush() on the entity manager. You *can* call $entityManager->persist($product), but it isn't necessary: Doctrine is already \"watching\" your object for changes. Deleting an Object Deleting an object is very similar, but requires a call to the remove() method of the entity manager:: $entityManager->remove($product); $entityManager->flush(); As you might expect, the remove() method notifies Doctrine that you'd like to remove the given object from the database. The DELETE query isn't actually executed until the flush() method is called. Querying for Objects: The Repository You've already seen how the repository object allows you to run basic queries without any work:: // from inside a controller $repository = $entityManager->getRepository(Product::class); $product = $repository->find($id); But what if you need a more complex query? When you generated your entity with make:entity, the command *also* generated a ProductRepository class:: // src/Repository/ProductRepository.php namespace", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_9", "source": "doctrine.rst", "text": "to the remove() method of the entity manager:: $entityManager->remove($product); $entityManager->flush(); As you might expect, the remove() method notifies Doctrine that you'd like to remove the given object from the database. The DELETE query isn't actually executed until the flush() method is called. Querying for Objects: The Repository You've already seen how the repository object allows you to run basic queries without any work:: // from inside a controller $repository = $entityManager->getRepository(Product::class); $product = $repository->find($id); But what if you need a more complex query? When you generated your entity with make:entity, the command *also* generated a ProductRepository class:: // src/Repository/ProductRepository.php namespace App\\Repository; use App\\Entity\\Product; use Doctrine\\Bundle\\DoctrineBundle\\Repository\\ServiceEntityRepository; use Doctrine\\Persistence\\ManagerRegistry; class ProductRepository extends ServiceEntityRepository { public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Product::class); } } When you fetch your repository (i.e. ->getRepository(Product::class)), it is *actually* an instance of *this* object! This is because of the repositoryClass config that was generated at the top of your Product entity class. Suppose you want to query for all Product objects greater than a certain price. Add a new method for this to your repository:: // src/Repository/ProductRepository.php // ... class ProductRepository extends ServiceEntityRepository { public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Product::class); } /** * @return Product[] */ public function findAllGreaterThanPrice(int $price): array { $entityManager = $this->getEntityManager(); $query = $entityManager->createQuery( 'SELECT p FROM App\\Entity\\Product p WHERE p.price > :price ORDER BY p.price ASC' )->setParameter('price', $price); // returns an array of Product objects return $query->getResult(); } } The string passed to createQuery() might look like SQL, but it is `Doctrine Query Language`_. This allows you to type queries using commonly known query language, but referencing PHP objects instead (i.e. in the FROM statement). Now, you can call this method on the repository:: // from inside a controller $minPrice = 1000; $products = $entityManager->getRepository(Product::class)->findAllGreaterThanPrice($minPrice); // ... See services-constructor-injection for how to inject the repository into any service. Querying with the Query Builder Doctrine also provides a `Query Builder`_, an object-oriented way to write queries. It is recommended to use this when queries are built dynamically (i.e. based on PHP conditions):: // src/Repository/ProductRepository.php // ... class ProductRepository extends ServiceEntityRepository { public function findAllGreaterThanPrice(int $price, bool $includeUnavailableProducts = false): array { // automatically knows to select Products // the \"p\" is an alias you'll use in the rest of the query $qb = $this->createQueryBuilder('p') ->where('p.price > :price') ->setParameter('price', $price) ->orderBy('p.price', 'ASC'); if (!$includeUnavailableProducts) { $qb->andWhere('p.available = TRUE'); } $query = $qb->getQuery(); return $query->execute(); // to get just one result: // $product = $query->setMaxResults(1)->getOneOrNullResult(); } } Querying with SQL In addition, you can query directly with SQL if you need to:: // src/Repository/ProductRepository.php // ... class ProductRepository extends ServiceEntityRepository { public function findAllGreaterThanPrice(int $price): array { $conn = $this->getEntityManager()->getConnection(); $sql = ' SELECT * FROM product p WHERE p.price > :price ORDER BY p.price ASC '; $resultSet = $conn->executeQuery($sql, ['price' => $price]); // returns an array of arrays (i.e. a raw data set) return $resultSet->fetchAllAssociative(); } } With SQL, you will get back raw data, not objects (unless you use the `NativeQuery`_ functionality). Configuration", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "doctrine.rst_fixed_10", "source": "doctrine.rst", "text": "// to get just one result: // $product = $query->setMaxResults(1)->getOneOrNullResult(); } } Querying with SQL In addition, you can query directly with SQL if you need to:: // src/Repository/ProductRepository.php // ... class ProductRepository extends ServiceEntityRepository { public function findAllGreaterThanPrice(int $price): array { $conn = $this->getEntityManager()->getConnection(); $sql = ' SELECT * FROM product p WHERE p.price > :price ORDER BY p.price ASC '; $resultSet = $conn->executeQuery($sql, ['price' => $price]); // returns an array of arrays (i.e. a raw data set) return $resultSet->fetchAllAssociative(); } } With SQL, you will get back raw data, not objects (unless you use the `NativeQuery`_ functionality). Configuration See the Doctrine config reference . Relationships and Associations Doctrine provides all the functionality you need to manage database relationships (also known as associations), including ManyToOne, OneToMany, OneToOne and ManyToMany relationships. For info, see /doctrine/associations. Database Testing Read the article about testing code that interacts with the database . Doctrine Extensions (Timestampable, Translatable, etc.) Doctrine community has created some extensions to implement common needs such as *\"set the value of the createdAt property automatically when creating an entity\"*. Read more about the `available Doctrine extensions`_ and use the `StofDoctrineExtensionsBundle`_ to integrate them in your application. Learn more :maxdepth: 1 doctrine/associations doctrine/events doctrine/custom_dql_functions doctrine/dbal doctrine/multiple_entity_managers doctrine/resolve_target_entity testing/database", "title": "Databases and the Doctrine ORM", "category": "doctrine"}
{"chunk_id": "event_dispatcher.rst_fixed_0", "source": "event_dispatcher.rst", "text": "Events and Event Listeners During the execution of a Symfony application, lots of event notifications are triggered. Your application can listen to these notifications and respond to them by executing any piece of code. Symfony triggers several events related to the kernel while processing the HTTP Request. Third-party bundles may also dispatch events, and you can even dispatch custom events from your own code. All the examples shown in this article use the same KernelEvents::EXCEPTION event for consistency purposes. In your own application, you can use any event and even mix several of them in the same subscriber. Creating an Event Listener The most common way to listen to an event is to register an **event listener**:: // src/EventListener/ExceptionListener.php namespace App\\EventListener; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent; use Symfony\\Component\\HttpKernel\\Exception\\HttpExceptionInterface; class ExceptionListener { public function __invoke(ExceptionEvent $event): void { // You get the exception object from the received event $exception = $event->getThrowable(); $message = sprintf( 'My Error says: %s with code: %s', $exception->getMessage(), $exception->getCode() ); // Customize your response object to display the exception details $response = new Response(); $response->setContent($message); // the exception message can contain unfiltered user input; // set the content-type to text to avoid XSS issues $response->headers->set('Content-Type', 'text/plain; charset=utf-8'); // HttpExceptionInterface is a special type of exception that // holds status code and header details if ($exception instanceof HttpExceptionInterface) { $response->setStatusCode($exception->getStatusCode()); $response->headers->replace($exception->getHeaders()); } else { $response->setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR); } // sends the modified response object to the event $event->setResponse($response); } } Now that the class is created, you need to register it as a service and notify Symfony that it is an event listener by using a special \"tag\": # config/services.yaml services: App\\EventListener\\ExceptionListener: tags: [kernel.event_listener] <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <service id=\"App\\EventListener\\ExceptionListener\"> <tag name=\"kernel.event_listener\"/> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\EventListener\\ExceptionListener; return function(ContainerConfigurator $container): void { $services = $container->services(); $services->set(ExceptionListener::class) ->tag('kernel.event_listener') ; }; Symfony follows this logic to decide which method to call inside the event listener class: #. If the kernel.event_listener tag defines the method attribute, that's the name of the method to be called; #. If no method attribute is defined, try to call the __invoke() magic method (which makes event listeners invokable); #. If the __invoke() method is not defined either, throw an exception. There is an optional attribute for the kernel.event_listener tag called priority, which is a positive or negative integer that defaults to 0 and it controls the order in which listeners are executed (the higher the number, the earlier a listener is executed). This is useful when you need to guarantee that one listener is executed before another. The priorities of the internal Symfony listeners usually range from -256 to 256 but your own listeners can use any positive or negative integer. There is an optional attribute for the kernel.event_listener tag called event which is useful when listener $event argument is not typed. If you configure it, it will change type of $event object. For the kernel.exception event, it is Symfony\\\\Component\\\\HttpKernel\\\\Event\\\\ExceptionEvent. Check out the Symfony events", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_fixed_1", "source": "event_dispatcher.rst", "text": "the order in which listeners are executed (the higher the number, the earlier a listener is executed). This is useful when you need to guarantee that one listener is executed before another. The priorities of the internal Symfony listeners usually range from -256 to 256 but your own listeners can use any positive or negative integer. There is an optional attribute for the kernel.event_listener tag called event which is useful when listener $event argument is not typed. If you configure it, it will change type of $event object. For the kernel.exception event, it is Symfony\\\\Component\\\\HttpKernel\\\\Event\\\\ExceptionEvent. Check out the Symfony events reference to see what type of object each event provides. With this attribute, Symfony follows this logic to decide which method to call inside the event listener class: #. If the kernel.event_listener tag defines the method attribute, that's the name of the method to be called; #. If no method attribute is defined, try to call the method whose name is on + \"PascalCased event name\" (e.g. onKernelException() method for the kernel.exception event); #. If that method is not defined either, try to call the __invoke() magic method (which makes event listeners invokable); #. If the __invoke() method is not defined either, throw an exception. Defining Event Listeners with PHP Attributes An alternative way to define an event listener is to use the Symfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener PHP attribute. This allows you to configure the listener inside its class, without having to add any configuration in external files:: namespace App\\EventListener; use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; #[AsEventListener] final class MyListener { public function __invoke(CustomEvent $event): void { // ... } } You can add multiple #[AsEventListener] attributes to configure different methods. The method property is optional, and when not defined, it defaults to on + uppercased event name. In the example below, the 'foo' event listener doesn't explicitly define its method, so the onFoo() method will be called:: namespace App\\EventListener; use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; #[AsEventListener(event: CustomEvent::class, method: 'onCustomEvent')] #[AsEventListener(event: 'foo', priority: 42)] #[AsEventListener(event: 'bar', method: 'onBarEvent')] final class MyMultiListener { public function onCustomEvent(CustomEvent $event): void { // ... } public function onFoo(): void { // ... } public function onBarEvent(): void { // ... } } Symfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener can also be applied to methods directly:: namespace App\\EventListener; use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; final class MyMultiListener { #[AsEventListener] public function onCustomEvent(CustomEvent $event): void { // ... } #[AsEventListener(event: 'foo', priority: 42)] public function onFoo(): void { // ... } #[AsEventListener(event: 'bar')] public function onBarEvent(): void { // ... } } Note that the attribute doesn't require its event parameter to be set if the method already type-hints the expected event. Creating an Event Subscriber Another way to listen to events is via an **event subscriber**, which is a class that defines one or more methods that listen to one or various events. The main difference with the event listeners is that subscribers always know the events to which they are listening. If different event subscriber methods listen to the same event, their order is defined by the priority parameter. This value is a positive", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_fixed_2", "source": "event_dispatcher.rst", "text": "void { // ... } } Note that the attribute doesn't require its event parameter to be set if the method already type-hints the expected event. Creating an Event Subscriber Another way to listen to events is via an **event subscriber**, which is a class that defines one or more methods that listen to one or various events. The main difference with the event listeners is that subscribers always know the events to which they are listening. If different event subscriber methods listen to the same event, their order is defined by the priority parameter. This value is a positive or negative integer which defaults to 0. The higher the number, the earlier the method is called. **Priority is aggregated for all listeners and subscribers**, so your methods could be called before or after the methods defined in other listeners and subscribers. To learn more about event subscribers, read /components/event_dispatcher. The following example shows an event subscriber that defines several methods which listen to the same kernel.exception event via its ExceptionEvent class:: // src/EventSubscriber/ExceptionSubscriber.php namespace App\\EventSubscriber; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent; class ExceptionSubscriber implements EventSubscriberInterface { public static function getSubscribedEvents(): array { // return the subscribed events, their methods and priorities return [ ExceptionEvent::class => [ ['processException', 10], ['logException', 0], ['notifyException', -10], ], ]; } public function processException(ExceptionEvent $event): void { // ... } public function logException(ExceptionEvent $event): void { // ... } public function notifyException(ExceptionEvent $event): void { // ... } } That's it! Your services.yaml file should already be setup to load services from the EventSubscriber directory. Symfony takes care of the rest. If your methods are *not* called when an exception is thrown, double-check that you're loading services from the EventSubscriber directory and have autoconfigure enabled. You can also manually add the kernel.event_subscriber tag. Request Events, Checking Types A single page can make several requests (one main request, and then multiple sub-requests - typically when embedding controllers in templates ). For the core Symfony events, you might need to check to see if the event is for a \"main\" request or a \"sub request\":: // src/EventListener/RequestListener.php namespace App\\EventListener; use Symfony\\Component\\HttpKernel\\Event\\RequestEvent; class RequestListener { public function onKernelRequest(RequestEvent $event): void { if (!$event->isMainRequest()) { // don't do anything if it's not the main request return; } // ... } } Certain things, like checking information on the *real* request, may not need to be done on the sub-request listeners. Listeners or Subscribers Listeners and subscribers can be used in the same application indistinctly. The decision to use either of them is usually a matter of personal taste. However, there are some minor advantages for each of them: * **Subscribers are easier to reuse** because the knowledge of the events is kept in the class rather than in the service definition. This is the reason why Symfony uses subscribers internally; * **Listeners are more flexible** because bundles can enable or disable each of them conditionally depending on some configuration value. Event Aliases When configuring event listeners and subscribers via dependency injection,", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_fixed_3", "source": "event_dispatcher.rst", "text": "or Subscribers Listeners and subscribers can be used in the same application indistinctly. The decision to use either of them is usually a matter of personal taste. However, there are some minor advantages for each of them: * **Subscribers are easier to reuse** because the knowledge of the events is kept in the class rather than in the service definition. This is the reason why Symfony uses subscribers internally; * **Listeners are more flexible** because bundles can enable or disable each of them conditionally depending on some configuration value. Event Aliases When configuring event listeners and subscribers via dependency injection, Symfony's core events can also be referred to by the fully qualified class name (FQCN) of the corresponding event class:: // src/EventSubscriber/RequestSubscriber.php namespace App\\EventSubscriber; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\HttpKernel\\Event\\RequestEvent; class RequestSubscriber implements EventSubscriberInterface { public static function getSubscribedEvents(): array { return [ RequestEvent::class => 'onKernelRequest', ]; } public function onKernelRequest(RequestEvent $event): void { // ... } } Internally, the event FQCN are treated as aliases for the original event names. Since the mapping already happens when compiling the service container, event listeners and subscribers using FQCN instead of event names will appear under the original event name when inspecting the event dispatcher. This alias mapping can be extended for custom events by registering the compiler pass AddEventAliasesPass:: // src/Kernel.php namespace App; use App\\Event\\MyCustomEvent; use Symfony\\Component\\DependencyInjection\\ContainerBuilder; use Symfony\\Component\\EventDispatcher\\DependencyInjection\\AddEventAliasesPass; use Symfony\\Component\\HttpKernel\\Kernel as BaseKernel; class Kernel extends BaseKernel { protected function build(ContainerBuilder $container): void { $container->addCompilerPass(new AddEventAliasesPass([ MyCustomEvent::class => 'my_custom_event', ])); } } The compiler pass will always extend the existing list of aliases. Because of that, it is safe to register multiple instances of the pass with different configurations. Debugging Event Listeners You can find out what listeners are registered in the event dispatcher using the console. To show all events and their listeners, run: $ php bin/console debug:event-dispatcher You can get registered listeners for a particular event by specifying its name: $ php bin/console debug:event-dispatcher kernel.exception or can get everything which partial matches the event name: $ php bin/console debug:event-dispatcher kernel // matches \"kernel.exception\", \"kernel.response\" etc. $ php bin/console debug:event-dispatcher Security // matches \"Symfony\\Component\\Security\\Http\\Event\\CheckPassportEvent\" The security system uses an event dispatcher per firewall. Use the --dispatcher option to get the registered listeners for a particular event dispatcher: $ php bin/console debug:event-dispatcher --dispatcher=security.event_dispatcher.main How to Set Up Before and After Filters It is quite common in web application development to need some logic to be performed right before or directly after your controller actions acting as filters or hooks. Some web frameworks define methods like preExecute() and postExecute(), but there is no such thing in Symfony. The good news is that there is a much better way to interfere with the Request -> Response process using the EventDispatcher component . Token Validation Example Imagine that you need to develop an API where some controllers are public but some others are restricted to one or some clients. For these private features, you might provide a token to your clients to identify themselves. So, before", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_fixed_4", "source": "event_dispatcher.rst", "text": "to be performed right before or directly after your controller actions acting as filters or hooks. Some web frameworks define methods like preExecute() and postExecute(), but there is no such thing in Symfony. The good news is that there is a much better way to interfere with the Request -> Response process using the EventDispatcher component . Token Validation Example Imagine that you need to develop an API where some controllers are public but some others are restricted to one or some clients. For these private features, you might provide a token to your clients to identify themselves. So, before executing your controller action, you need to check if the action is restricted or not. If it is restricted, you need to validate the provided token. Please note that for simplicity in this recipe, tokens will be defined in config and neither database setup nor authentication via the Security component will be used. Before Filters with the kernel.controller Event First, define some token configuration as parameters: # config/services.yaml parameters: tokens: client1: pass1 client2: pass2 <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters> <parameter key=\"tokens\" type=\"collection\"> <parameter key=\"client1\">pass1</parameter> <parameter key=\"client2\">pass2</parameter> </parameter> </parameters> </container> // config/services.php $container->setParameter('tokens', [ 'client1' => 'pass1', 'client2' => 'pass2', ]); Tag Controllers to Be Checked ............................. A kernel.controller (aka KernelEvents::CONTROLLER) listener gets notified on *every* request, right before the controller is executed. So, first, you need some way to identify if the controller that matches the request needs token validation. A clean and simple way is to create an empty interface and make the controllers implement it:: namespace App\\Controller; interface TokenAuthenticatedController { // ... } A controller that implements this interface looks like this:: namespace App\\Controller; use App\\Controller\\TokenAuthenticatedController; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; class FooController extends AbstractController implements TokenAuthenticatedController { // An action that needs authentication public function bar(): Response { // ... } } Creating an Event Subscriber ............................ Next, you'll need to create an event subscriber, which will hold the logic that you want to be executed before your controllers. If you're not familiar with event subscribers, you can learn more about how to use them :: // src/EventSubscriber/TokenSubscriber.php namespace App\\EventSubscriber; use App\\Controller\\TokenAuthenticatedController; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\HttpKernel\\Event\\ControllerEvent; use Symfony\\Component\\HttpKernel\\Exception\\AccessDeniedHttpException; use Symfony\\Component\\HttpKernel\\KernelEvents; class TokenSubscriber implements EventSubscriberInterface { public function __construct( private array $tokens ) { } public function onKernelController(ControllerEvent $event): void { $controller = $event->getController(); // when a controller class defines multiple action methods, the controller // is returned as [$controllerInstance, 'methodName'] if (is_array($controller)) { $controller = $controller[0]; } if ($controller instanceof TokenAuthenticatedController) { $token = $event->getRequest()->query->get('token'); if (!in_array($token, $this->tokens)) { throw new AccessDeniedHttpException('This action needs a valid token!'); } } } public static function getSubscribedEvents(): array { return [ KernelEvents::CONTROLLER => 'onKernelController', ]; } } That's it! Your services.yaml file should already be setup to load services from the EventSubscriber directory. Symfony takes care of the rest. Your TokenSubscriber onKernelController() method will be executed on each request. If the controller that is about to be executed implements TokenAuthenticatedController, token authentication is", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_fixed_5", "source": "event_dispatcher.rst", "text": "action methods, the controller // is returned as [$controllerInstance, 'methodName'] if (is_array($controller)) { $controller = $controller[0]; } if ($controller instanceof TokenAuthenticatedController) { $token = $event->getRequest()->query->get('token'); if (!in_array($token, $this->tokens)) { throw new AccessDeniedHttpException('This action needs a valid token!'); } } } public static function getSubscribedEvents(): array { return [ KernelEvents::CONTROLLER => 'onKernelController', ]; } } That's it! Your services.yaml file should already be setup to load services from the EventSubscriber directory. Symfony takes care of the rest. Your TokenSubscriber onKernelController() method will be executed on each request. If the controller that is about to be executed implements TokenAuthenticatedController, token authentication is applied. This lets you have a \"before\" filter on any controller you want. If your subscriber is *not* called on each request, double-check that you're loading services from the EventSubscriber directory and have autoconfigure enabled. You can also manually add the kernel.event_subscriber tag. After Filters with the kernel.response Event In addition to having a \"hook\" that's executed *before* your controller, you can also add a hook that's executed *after* your controller. For this example, imagine that you want to add a sha1 hash (with a salt using that token) to all responses that have passed this token authentication. Another core Symfony event - called kernel.response (aka KernelEvents::RESPONSE) - is notified on every request, but after the controller returns a Response object. To create an \"after\" listener, create a listener class and register it as a service on this event. For example, take the TokenSubscriber from the previous example and first record the authentication token inside the request attributes. This will serve as a basic flag that this request underwent token authentication:: public function onKernelController(ControllerEvent $event): void { // ... if ($controller instanceof TokenAuthenticatedController) { $token = $event->getRequest()->query->get('token'); if (!in_array($token, $this->tokens)) { throw new AccessDeniedHttpException('This action needs a valid token!'); } // mark the request as having passed token authentication $event->getRequest()->attributes->set('auth_token', $token); } } Now, configure the subscriber to listen to another event and add onKernelResponse(). This will look for the auth_token flag on the request object and set a custom header on the response if it's found:: // add the new use statement at the top of your file use Symfony\\Component\\HttpKernel\\Event\\ResponseEvent; public function onKernelResponse(ResponseEvent $event): void { // check to see if onKernelController marked this as a token \"auth'ed\" request if (!$token = $event->getRequest()->attributes->get('auth_token')) { return; } $response = $event->getResponse(); // create a hash and set it as a response header $hash = sha1($response->getContent().$token); $response->headers->set('X-CONTENT-HASH', $hash); } public static function getSubscribedEvents(): array { return [ KernelEvents::CONTROLLER => 'onKernelController', KernelEvents::RESPONSE => 'onKernelResponse', ]; } That's it! The TokenSubscriber is now notified before every controller is executed (onKernelController()) and after every controller returns a response (onKernelResponse()). By making specific controllers implement the TokenAuthenticatedController interface, your listener knows which controllers it should take action on. And by storing a value in the request's \"attributes\" bag, the onKernelResponse() method knows to add the extra header. Have fun! How to Customize a Method Behavior without Using Inheritance If you want to do something right before,", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_fixed_6", "source": "event_dispatcher.rst", "text": "header $hash = sha1($response->getContent().$token); $response->headers->set('X-CONTENT-HASH', $hash); } public static function getSubscribedEvents(): array { return [ KernelEvents::CONTROLLER => 'onKernelController', KernelEvents::RESPONSE => 'onKernelResponse', ]; } That's it! The TokenSubscriber is now notified before every controller is executed (onKernelController()) and after every controller returns a response (onKernelResponse()). By making specific controllers implement the TokenAuthenticatedController interface, your listener knows which controllers it should take action on. And by storing a value in the request's \"attributes\" bag, the onKernelResponse() method knows to add the extra header. Have fun! How to Customize a Method Behavior without Using Inheritance If you want to do something right before, or directly after a method is called, you can dispatch an event respectively at the beginning or at the end of the method:: class CustomMailer { // ... public function send(string $subject, string $message): mixed { // dispatch an event before the method $event = new BeforeSendMailEvent($subject, $message); $this->dispatcher->dispatch($event, 'mailer.pre_send'); // get $subject and $message from the event, they may have been modified $subject = $event->getSubject(); $message = $event->getMessage(); // the real method implementation is here $returnValue = ...; // do something after the method $event = new AfterSendMailEvent($returnValue); $this->dispatcher->dispatch($event, 'mailer.post_send'); return $event->getReturnValue(); } } In this example, two events are dispatched: #. mailer.pre_send, before the method is called, #. and mailer.post_send after the method is called. Each uses a custom Event class to communicate information to the listeners of the two events. For example, BeforeSendMailEvent might look like this:: // src/Event/BeforeSendMailEvent.php namespace App\\Event; use Symfony\\Contracts\\EventDispatcher\\Event; class BeforeSendMailEvent extends Event { public function __construct( private string $subject, private string $message, ) { } public function getSubject(): string { return $this->subject; } public function setSubject(string $subject): void { $this->subject = $subject; } public function getMessage(): string { return $this->message; } public function setMessage(string $message): void { $this->message = $message; } } And the AfterSendMailEvent even like this:: // src/Event/AfterSendMailEvent.php namespace App\\Event; use Symfony\\Contracts\\EventDispatcher\\Event; class AfterSendMailEvent extends Event { public function __construct( private mixed $returnValue, ) { } public function getReturnValue(): mixed { return $this->returnValue; } public function setReturnValue(mixed $returnValue): void { $this->returnValue = $returnValue; } } Both events allow you to get some information (e.g. getMessage()) and even change that information (e.g. setMessage()). Now, you can create an event subscriber to hook into this event. For example, you could listen to the mailer.post_send event and change the method's return value:: // src/EventSubscriber/MailPostSendSubscriber.php namespace App\\EventSubscriber; use App\\Event\\AfterSendMailEvent; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; class MailPostSendSubscriber implements EventSubscriberInterface { public function onMailerPostSend(AfterSendMailEvent $event): void { $returnValue = $event->getReturnValue(); // modify the original $returnValue value $event->setReturnValue($returnValue); } public static function getSubscribedEvents(): array { return [ 'mailer.post_send' => 'onMailerPostSend', ]; } } That's it! Your subscriber should be called automatically (or read more about event subscriber configuration ). Learn More - The Request-Response Lifecycle - /reference/events - Security-related Events - /components/event_dispatcher", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "event_dispatcher.rst_fixed_7", "source": "event_dispatcher.rst", "text": "EventSubscriberInterface { public function onMailerPostSend(AfterSendMailEvent $event): void { $returnValue = $event->getReturnValue(); // modify the original $returnValue value $event->setReturnValue($returnValue); } public static function getSubscribedEvents(): array { return [ 'mailer.post_send' => 'onMailerPostSend', ]; } } That's it! Your subscriber should be called automatically (or read more about event subscriber configuration ). Learn More - The Request-Response Lifecycle - /reference/events - Security-related Events - /components/event_dispatcher", "title": "Events and Event Listeners", "category": "event_dispatcher"}
{"chunk_id": "forms.rst_fixed_0", "source": "forms.rst", "text": "Forms :class: screencast Do you prefer video tutorials? Check out the `Symfony Forms screencast series`_. Creating and processing HTML forms is hard and repetitive. You need to deal with rendering HTML form fields, validating submitted data, mapping the form data into objects and a lot more. Symfony includes a powerful form feature that provides all these features and many more for truly complex scenarios. Installation In applications using Symfony Flex , run this command to install the form feature before using it: $ composer require symfony/form Usage The recommended workflow when working with Symfony forms is the following: #. **Build the form** in a Symfony controller or using a dedicated form class; #. **Render the form** in a template so the user can edit and submit it; #. **Process the form** to validate the submitted data, transform it into PHP data and do something with it (e.g. persist it in a database). Each of these steps is explained in detail in the next sections. To make examples easier to follow, all of them assume that you're building a small Todo list application that displays \"tasks\". Users create and edit tasks using Symfony forms. Each task is an instance of the following Task class:: // src/Entity/Task.php namespace App\\Entity; class Task { protected string $task; protected ?\\DateTimeInterface $dueDate; public function getTask(): string { return $this->task; } public function setTask(string $task): void { $this->task = $task; } public function getDueDate(): ?\\DateTimeInterface { return $this->dueDate; } public function setDueDate(?\\DateTimeInterface $dueDate): void { $this->dueDate = $dueDate; } } This class is a \"plain-old-PHP-object\" because, so far, it has nothing to do with Symfony or any other library. It's a normal PHP object that directly solves a problem inside *your* application (i.e. the need to represent a task in your application). But you can also edit Doctrine entities in the same way. Form Types Before creating your first Symfony form, it's important to understand the concept of \"form type\". In other projects, it's common to differentiate between \"forms\" and \"form fields\". In Symfony, all of them are \"form types\": * a single <input type=\"text\"> form field is a \"form type\" (e.g. TextType); * a group of several HTML fields used to input a postal address is a \"form type\" (e.g. PostalAddressType); * an entire <form> with multiple fields to edit a user profile is a \"form type\" (e.g. UserProfileType). This may be confusing at first, but it will feel natural to you soon enough. Besides, it simplifies code and makes \"composing\" and \"embedding\" form fields much easier to implement. There are tens of form types provided by Symfony and you can also create your own form types . You can use the debug:form to list all the available types, type extensions and type guessers in your application: $ php bin/console debug:form # pass the form type FQCN to only show the options for that type, its parents and extensions. # For built-in types, you can pass the short classname instead of the FQCN $ php bin/console", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_fixed_1", "source": "forms.rst", "text": "it will feel natural to you soon enough. Besides, it simplifies code and makes \"composing\" and \"embedding\" form fields much easier to implement. There are tens of form types provided by Symfony and you can also create your own form types . You can use the debug:form to list all the available types, type extensions and type guessers in your application: $ php bin/console debug:form # pass the form type FQCN to only show the options for that type, its parents and extensions. # For built-in types, you can pass the short classname instead of the FQCN $ php bin/console debug:form BirthdayType # pass also an option name to only display the full definition of that option $ php bin/console debug:form BirthdayType label_attr Building Forms Symfony provides a \"form builder\" object which allows you to describe the form fields using a fluent interface. Later, this builder creates the actual form object used to render and process contents. Creating Forms in Controllers If your controller extends from the AbstractController , use the createFormBuilder() helper:: // src/Controller/TaskController.php namespace App\\Controller; use App\\Entity\\Task; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; class TaskController extends AbstractController { public function new(Request $request): Response { // creates a task object and initializes some data for this example $task = new Task(); $task->setTask('Write a blog post'); $task->setDueDate(new \\DateTimeImmutable('tomorrow')); $form = $this->createFormBuilder($task) ->add('task', TextType::class) ->add('dueDate', DateType::class) ->add('save', SubmitType::class, ['label' => 'Create Task']) ->getForm(); // ... } } If your controller does not extend from AbstractController, you'll need to fetch services in your controller and use the createBuilder() method of the form.factory service. In this example, you've added two fields to your form - task and dueDate - corresponding to the task and dueDate properties of the Task class. You've also assigned each a form type (e.g. TextType and DateType), represented by its fully qualified class name. Finally, you added a submit button with a custom label for submitting the form to the server. Creating Form Classes Symfony recommends putting as little logic as possible in controllers. That's why it's better to move complex forms to dedicated classes instead of defining them in controller actions. Besides, forms defined in classes can be reused in multiple actions and services. Form classes are form types that implement Symfony\\\\Component\\\\Form\\\\FormTypeInterface. However, it's better to extend from Symfony\\\\Component\\\\Form\\\\AbstractType, which already implements the interface and provides some utilities:: // src/Form/Type/TaskType.php namespace App\\Form\\Type; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; use Symfony\\Component\\Form\\FormBuilderInterface; class TaskType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder ->add('task', TextType::class) ->add('dueDate', DateType::class) ->add('save', SubmitType::class) ; } } Install the `MakerBundle`_ in your project to generate form classes using the make:form and make:registration-form commands. The form class contains all the directions needed to create the task form. In controllers extending from the AbstractController , use the createForm() helper (otherwise, use the create() method of the form.factory service):: // src/Controller/TaskController.php namespace App\\Controller; use App\\Form\\Type\\TaskType; // ... class TaskController extends AbstractController { public function new(): Response {", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_fixed_2", "source": "forms.rst", "text": "use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; use Symfony\\Component\\Form\\FormBuilderInterface; class TaskType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder ->add('task', TextType::class) ->add('dueDate', DateType::class) ->add('save', SubmitType::class) ; } } Install the `MakerBundle`_ in your project to generate form classes using the make:form and make:registration-form commands. The form class contains all the directions needed to create the task form. In controllers extending from the AbstractController , use the createForm() helper (otherwise, use the create() method of the form.factory service):: // src/Controller/TaskController.php namespace App\\Controller; use App\\Form\\Type\\TaskType; // ... class TaskController extends AbstractController { public function new(): Response { // creates a task object and initializes some data for this example $task = new Task(); $task->setTask('Write a blog post'); $task->setDueDate(new \\DateTimeImmutable('tomorrow')); $form = $this->createForm(TaskType::class, $task); // ... } } Every form needs to know the name of the class that holds the underlying data (e.g. App\\Entity\\Task). Usually, this is just guessed based off of the object passed to the second argument to createForm() (i.e. $task). Later, when you begin embedding forms , this will no longer be sufficient. So, while not always necessary, it's generally a good idea to explicitly specify the data_class option by adding the following to your form type class:: // src/Form/Type/TaskType.php namespace App\\Form\\Type; use App\\Entity\\Task; use Symfony\\Component\\OptionsResolver\\OptionsResolver; // ... class TaskType extends AbstractType { // ... public function configureOptions(OptionsResolver $resolver): void { $resolver->setDefaults([ 'data_class' => Task::class, ]); } } Rendering Forms Now that the form has been created, the next step is to render it:: // src/Controller/TaskController.php namespace App\\Controller; use App\\Entity\\Task; use App\\Form\\Type\\TaskType; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; class TaskController extends AbstractController { public function new(Request $request): Response { $task = new Task(); // ... $form = $this->createForm(TaskType::class, $task); return $this->render('task/new.html.twig', [ 'form' => $form, ]); } } Internally, the render() method calls $form->createView() to transform the form into a *form view* instance. Then, use some form helper functions to render the form contents: {# templates/task/new.html.twig #} {{ form(form) }} That's it! The form() function renders all fields *and* the <form> start and end tags. By default, the form method is POST and the target URL is the same that displayed the form, but you can change both . Notice how the rendered task input field has the value of the task property from the $task object (i.e. \"Write a blog post\"). This is the first job of a form: to take data from an object and translate it into a format that's suitable for being rendered in an HTML form. The form system is smart enough to access the value of the protected task property via the getTask() and setTask() methods on the Task class. Unless a property is public, it *must* have a \"getter\" and \"setter\" method so that Symfony can get and put data onto the property. For a boolean property, you can use an \"isser\" or \"hasser\" method (e.g. isPublished() or hasReminder()) instead of a getter (e.g. getPublished() or getReminder()). As short as this rendering is, it's not very flexible.", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_fixed_3", "source": "forms.rst", "text": "an object and translate it into a format that's suitable for being rendered in an HTML form. The form system is smart enough to access the value of the protected task property via the getTask() and setTask() methods on the Task class. Unless a property is public, it *must* have a \"getter\" and \"setter\" method so that Symfony can get and put data onto the property. For a boolean property, you can use an \"isser\" or \"hasser\" method (e.g. isPublished() or hasReminder()) instead of a getter (e.g. getPublished() or getReminder()). As short as this rendering is, it's not very flexible. Usually, you'll need more control about how the entire form or some of its fields look. For example, thanks to the Bootstrap 5 integration with Symfony forms you can set this option to generate forms compatible with the Bootstrap 5 CSS framework: # config/packages/twig.yaml twig: form_themes: ['bootstrap_5_layout.html.twig'] <!-- config/packages/twig.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:twig=\"http://symfony.com/schema/dic/twig\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\"> <twig:config> <twig:form-theme>bootstrap_5_layout.html.twig</twig:form-theme> <!-- ... --> </twig:config> </container> // config/packages/twig.php use Symfony\\Config\\TwigConfig; return static function (TwigConfig $twig): void { $twig->formThemes(['bootstrap_5_layout.html.twig']); // ... }; The built-in Symfony form themes include Bootstrap 3, 4 and 5, Foundation 5 and 6, as well as Tailwind 2. You can also create your own Symfony form theme . In addition to form themes, Symfony allows you to customize the way fields are rendered with multiple functions to render each field part separately (widgets, labels, errors, help messages, etc.) Processing Forms The recommended way of processing forms is to use a single action for both rendering the form and handling the form submit. You can use separate actions, but using one action simplifies everything while keeping the code concise and maintainable. Processing a form means to translate user-submitted data back to the properties of an object. To make this happen, the submitted data from the user must be written into the form object:: // src/Controller/TaskController.php // ... use Symfony\\Component\\HttpFoundation\\Request; class TaskController extends AbstractController { public function new(Request $request): Response { // just set up a fresh $task object (remove the example data) $task = new Task(); $form = $this->createForm(TaskType::class, $task); $form->handleRequest($request); if ($form->isSubmitted() && $form->isValid()) { // $form->getData() holds the submitted values // but, the original `$task` variable has also been updated $task = $form->getData(); // ... perform some action, such as saving the task to the database return $this->redirectToRoute('task_success'); } return $this->render('task/new.html.twig', [ 'form' => $form, ]); } } This controller follows a common pattern for handling forms and has three possible paths: #. When initially loading the page in a browser, the form hasn't been submitted yet and $form->isSubmitted() returns false. So, the form is created and rendered; #. When the user submits the form, Symfony\\\\Component\\\\Form\\\\FormInterface::handleRequest recognizes this and immediately writes the submitted data back into the task and dueDate properties of the $task object. Then this object is validated (validation is explained in the next section). If it is invalid, Symfony\\\\Component\\\\Form\\\\FormInterface::isValid returns false and the form is rendered again, but now with", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_fixed_4", "source": "forms.rst", "text": "=> $form, ]); } } This controller follows a common pattern for handling forms and has three possible paths: #. When initially loading the page in a browser, the form hasn't been submitted yet and $form->isSubmitted() returns false. So, the form is created and rendered; #. When the user submits the form, Symfony\\\\Component\\\\Form\\\\FormInterface::handleRequest recognizes this and immediately writes the submitted data back into the task and dueDate properties of the $task object. Then this object is validated (validation is explained in the next section). If it is invalid, Symfony\\\\Component\\\\Form\\\\FormInterface::isValid returns false and the form is rendered again, but now with validation errors. By passing $form to the render() method (instead of $form->createView()), the response code is automatically set to `HTTP 422 Unprocessable Content`_. This ensures compatibility with tools relying on the HTTP specification, like `Symfony UX Turbo`_; #. When the user submits the form with valid data, the submitted data is again written into the form, but this time Symfony\\\\Component\\\\Form\\\\FormInterface::isValid returns true. Now you have the opportunity to perform some actions using the $task object (e.g. persisting it to the database) before redirecting the user to some other page (e.g. a \"thank you\" or \"success\" page); Redirecting a user after a successful form submission is a best practice that prevents the user from being able to hit the \"Refresh\" button of their browser and re-post the data. If you need more control over exactly when your form is submitted or which data is passed to it, you can use the submit() method to handle form submissions . Validating Forms In the previous section, you learned how a form can be submitted with valid or invalid data. In Symfony, the question isn't whether the \"form\" is valid, but whether or not the underlying object ($task in this example) is valid after the form has applied the submitted data to it. Calling $form->isValid() is a shortcut that asks the $task object whether or not it has valid data. Before using validation, add support for it in your application: $ composer require symfony/validator Validation is done by adding a set of rules, called (validation) constraints, to a class. You can add them either to the entity class or by using the constraints option of form types. To see the first approach - adding constraints to the entity - in action, add the validation constraints, so that the task field cannot be empty, and the dueDate field cannot be empty, and must be a valid DateTimeImmutable object. // src/Entity/Task.php namespace App\\Entity; use Symfony\\Component\\Validator\\Constraints as Assert; class Task { #[Assert\\NotBlank] public string $task; #[Assert\\NotBlank] #[Assert\\Type(\\DateTimeInterface::class)] protected \\DateTimeInterface $dueDate; } # config/validator/validation.yaml App\\Entity\\Task: properties: task: - NotBlank: ~ dueDate: - NotBlank: ~ - Type: \\DateTimeInterface <!-- config/validator/validation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Task\"> <property name=\"task\"> <constraint name=\"NotBlank\"/> </property> <property name=\"dueDate\"> <constraint name=\"NotBlank\"/> <constraint name=\"Type\">\\DateTimeInterface</constraint> </property> </class> </constraint-mapping> // src/Entity/Task.php namespace App\\Entity; use Symfony\\Component\\Validator\\Constraints\\NotBlank; use Symfony\\Component\\Validator\\Constraints\\Type; use Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Task { // ... public static function loadValidatorMetadata(ClassMetadata $metadata): void { $metadata->addPropertyConstraint('task',", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_fixed_5", "source": "forms.rst", "text": "the dueDate field cannot be empty, and must be a valid DateTimeImmutable object. // src/Entity/Task.php namespace App\\Entity; use Symfony\\Component\\Validator\\Constraints as Assert; class Task { #[Assert\\NotBlank] public string $task; #[Assert\\NotBlank] #[Assert\\Type(\\DateTimeInterface::class)] protected \\DateTimeInterface $dueDate; } # config/validator/validation.yaml App\\Entity\\Task: properties: task: - NotBlank: ~ dueDate: - NotBlank: ~ - Type: \\DateTimeInterface <!-- config/validator/validation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Task\"> <property name=\"task\"> <constraint name=\"NotBlank\"/> </property> <property name=\"dueDate\"> <constraint name=\"NotBlank\"/> <constraint name=\"Type\">\\DateTimeInterface</constraint> </property> </class> </constraint-mapping> // src/Entity/Task.php namespace App\\Entity; use Symfony\\Component\\Validator\\Constraints\\NotBlank; use Symfony\\Component\\Validator\\Constraints\\Type; use Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Task { // ... public static function loadValidatorMetadata(ClassMetadata $metadata): void { $metadata->addPropertyConstraint('task', new NotBlank()); $metadata->addPropertyConstraint('dueDate', new NotBlank()); $metadata->addPropertyConstraint( 'dueDate', new Type(\\DateTimeInterface::class) ); } } That's it! If you re-submit the form with invalid data, you'll see the corresponding errors printed out with the form. To see the second approach - adding constraints to the form - refer to this section . Both approaches can be used together. Other Common Form Features Passing Options to Forms If you create forms in classes , when building the form in the controller you can pass custom options to it as the third optional argument of createForm():: // src/Controller/TaskController.php namespace App\\Controller; use App\\Form\\Type\\TaskType; // ... class TaskController extends AbstractController { public function new(): Response { $task = new Task(); // use some PHP logic to decide if this form field is required or not $dueDateIsRequired = ...; $form = $this->createForm(TaskType::class, $task, [ 'require_due_date' => $dueDateIsRequired, ]); // ... } } If you try to use the form now, you'll see an error message: *The option \"require_due_date\" does not exist.* That's because forms must declare all the options they accept using the configureOptions() method:: // src/Form/Type/TaskType.php namespace App\\Form\\Type; use Symfony\\Component\\OptionsResolver\\OptionsResolver; // ... class TaskType extends AbstractType { // ... public function configureOptions(OptionsResolver $resolver): void { $resolver->setDefaults([ // ..., 'require_due_date' => false, ]); // you can also define the allowed types, allowed values and // any other feature supported by the OptionsResolver component $resolver->setAllowedTypes('require_due_date', 'bool'); } } Now you can use this new form option inside the buildForm() method:: // src/Form/Type/TaskType.php namespace App\\Form\\Type; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType; use Symfony\\Component\\Form\\FormBuilderInterface; class TaskType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder // ... ->add('dueDate', DateType::class, [ 'required' => $options['require_due_date'], ]) ; } // ... } Form Type Options Each form type has a number of options to configure it, as explained in the Symfony form types reference . Two commonly used options are required and label. The required Option ....................... The most common option is the required option, which can be applied to any field. By default, this option is set to true, meaning that HTML5-ready browsers will require you to fill in all fields before submitting the form. If you don't want this behavior, either disable client-side validation for the entire form or set the required option to false on one or more fields:: ->add('dueDate', DateType::class, [ 'required' => false, ]) The required option does not perform any server-side validation. If a user submits a", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_fixed_6", "source": "forms.rst", "text": "reference . Two commonly used options are required and label. The required Option ....................... The most common option is the required option, which can be applied to any field. By default, this option is set to true, meaning that HTML5-ready browsers will require you to fill in all fields before submitting the form. If you don't want this behavior, either disable client-side validation for the entire form or set the required option to false on one or more fields:: ->add('dueDate', DateType::class, [ 'required' => false, ]) The required option does not perform any server-side validation. If a user submits a blank value for the field (either with an old browser or a web service, for example), it will be accepted as a valid value unless you also use Symfony's NotBlank or NotNull validation constraints. The label Option .................... By default, the label of form fields are the *humanized* version of the property name (user -> User; postalAddress -> Postal Address). Set the label option on fields to define their labels explicitly:: ->add('dueDate', DateType::class, [ // set it to FALSE to not display the label for this field 'label' => 'To Be Completed Before', ]) By default, <label> tags of required fields are rendered with a required CSS class, so you can display an asterisk by applying a CSS style: label.required:before { content: \"*\"; } Changing the Action and HTTP Method By default, the <form> tag is rendered with a method=\"post\" attribute, and no action attribute. This means that the form is submitted via an HTTP POST request to the same URL under which it was rendered. When building the form, use the setAction() and setMethod() methods to change this:: // src/Controller/TaskController.php namespace App\\Controller; // ... use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; class TaskController extends AbstractController { public function new(): Response { // ... $form = $this->createFormBuilder($task) ->setAction($this->generateUrl('target_route')) ->setMethod('GET') // ... ->getForm(); // ... } } When building the form in a class, pass the action and method as form options:: // src/Controller/TaskController.php namespace App\\Controller; use App\\Form\\TaskType; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; // ... class TaskController extends AbstractController { public function new(): Response { // ... $form = $this->createForm(TaskType::class, $task, [ 'action' => $this->generateUrl('target_route'), 'method' => 'GET', ]); // ... } } Finally, you can override the action and method in the template by passing them to the form() or the form_start() helper functions: {# templates/task/new.html.twig #} {{ form_start(form, {'action': path('target_route'), 'method': 'GET'}) }} If the form's method is not GET or POST, but PUT, PATCH or DELETE, Symfony will insert a hidden field with the name _method that stores this method. The form will be submitted in a normal POST request, but Symfony's routing is capable of detecting the _method parameter and will interpret it as a PUT, PATCH or DELETE request. The http_method_override option must be enabled for this to work. Changing the Form Name If you inspect the HTML contents of the rendered form, you'll see that the <form> name and the field names are generated from the type", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_fixed_7", "source": "forms.rst", "text": "'GET'}) }} If the form's method is not GET or POST, but PUT, PATCH or DELETE, Symfony will insert a hidden field with the name _method that stores this method. The form will be submitted in a normal POST request, but Symfony's routing is capable of detecting the _method parameter and will interpret it as a PUT, PATCH or DELETE request. The http_method_override option must be enabled for this to work. Changing the Form Name If you inspect the HTML contents of the rendered form, you'll see that the <form> name and the field names are generated from the type class name (e.g. <form name=\"task\" ...> and <select name=\"task[dueDate][date][month]\" ...>). If you want to modify this, use the Symfony\\\\Component\\\\Form\\\\FormFactoryInterface::createNamed method:: // src/Controller/TaskController.php namespace App\\Controller; use App\\Form\\TaskType; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\Form\\FormFactoryInterface; // ... class TaskController extends AbstractController { public function new(FormFactoryInterface $formFactory): Response { $task = ...; $form = $formFactory->createNamed('my_name', TaskType::class, $task); // ... } } You can even suppress the name completely by setting it to an empty string. Client-Side HTML Validation Thanks to HTML5, many browsers can natively enforce certain validation constraints on the client side. The most common validation is activated by adding a required attribute on fields that are required. For browsers that support HTML5, this will result in a native browser message being displayed if the user tries to submit the form with that field blank. Generated forms take full advantage of this new feature by adding sensible HTML attributes that trigger the validation. The client-side validation, however, can be disabled by adding the novalidate attribute to the <form> tag or formnovalidate to the submit tag. This is especially useful when you want to test your server-side validation constraints, but are being prevented by your browser from, for example, submitting blank fields. {# templates/task/new.html.twig #} {{ form_start(form, {'attr': {'novalidate': 'novalidate'}}) }} {{ form_widget(form) }} {{ form_end(form) }} Form Type Guessing If the object handled by the form includes validation constraints, Symfony can introspect that metadata to guess the type of your field. In the above example, Symfony can guess from the validation rules that the task field is a normal TextType field and the dueDate field is a DateType field. To enable Symfony's \"guessing mechanism\", omit the second argument to the add() method, or pass null to it:: // src/Form/Type/TaskType.php namespace App\\Form\\Type; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType; use Symfony\\Component\\Form\\FormBuilderInterface; class TaskType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder // if you don't define field options, you can omit the second argument ->add('task') // if you define field options, pass NULL as second argument ->add('dueDate', null, ['required' => false]) ->add('save', SubmitType::class) ; } } When using a specific form validation group , the field type guesser will still consider *all* validation constraints when guessing your field types (including constraints that are not part of the validation group(s) being used). Form Type Options Guessing .......................... When the guessing mechanism is enabled for some field, in addition to its form type,", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_fixed_8", "source": "forms.rst", "text": "{ public function buildForm(FormBuilderInterface $builder, array $options): void { $builder // if you don't define field options, you can omit the second argument ->add('task') // if you define field options, pass NULL as second argument ->add('dueDate', null, ['required' => false]) ->add('save', SubmitType::class) ; } } When using a specific form validation group , the field type guesser will still consider *all* validation constraints when guessing your field types (including constraints that are not part of the validation group(s) being used). Form Type Options Guessing .......................... When the guessing mechanism is enabled for some field, in addition to its form type, the following options will be guessed too: required The required option is guessed based on the validation rules (i.e. is the field NotBlank or NotNull) or the Doctrine metadata (i.e. is the field nullable). This is very useful, as your client-side validation will automatically match your validation rules. maxlength If the field is some sort of text field, then the maxlength option attribute is guessed from the validation constraints (if Length or Range is used) or from the Doctrine metadata (via the field's length). If you'd like to change one of the guessed values, override it in the options field array:: ->add('task', null, ['attr' => ['maxlength' => 4]]) Besides guessing the form type, Symfony also guesses validation constraints if you're using a Doctrine entity. Read automatic_object_validation guide for more information. Unmapped Fields When editing an object via a form, all form fields are considered properties of the object. Any fields on the form that do not exist on the object will cause an exception to be thrown. If you need extra fields in the form that won't be stored in the object (for example to add an *\"I agree with these terms\"* checkbox), set the mapped option to false in those fields:: // ... use Symfony\\Component\\Form\\Extension\\Core\\Type\\CheckboxType; use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType; use Symfony\\Component\\Form\\FormBuilderInterface; class TaskType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder ->add('task') ->add('dueDate') ->add('agreeTerms', CheckboxType::class, ['mapped' => false]) ->add('save', SubmitType::class) ; } } These \"unmapped fields\" can be set and accessed in a controller with:: $form->get('agreeTerms')->getData(); $form->get('agreeTerms')->setData(true); Additionally, if there are any fields on the form that aren't included in the submitted data, those fields will be explicitly set to null. Learn more When building forms, keep in mind that the first goal of a form is to translate data from an object (Task) to an HTML form so that the user can modify that data. The second goal of a form is to take the data submitted by the user and to re-apply it to the object. There's a lot more to learn and a lot of *powerful* tricks in the Symfony forms: Reference: :maxdepth: 1 /reference/forms/types Advanced Features: :maxdepth: 1 /controller/upload_file /security/csrf /form/create_custom_field_type /form/data_transformers /form/data_mappers /form/create_form_type_extension /form/type_guesser Form Themes and Customization: :maxdepth: 1 /form/bootstrap4 /form/bootstrap5 /form/tailwindcss /form/form_customization /form/form_themes Events: :maxdepth: 1 /form/events /form/dynamic_form_modification Validation: :maxdepth: 1 /form/validation_groups /form/disabling_validation Misc.: :maxdepth: 1 /form/direct_submit /form/embedded /form/form_collections /form/inherit_data_option /form/multiple_buttons /form/unit_testing /form/use_empty_data /form/without_class", "title": "Forms", "category": "forms"}
{"chunk_id": "forms.rst_fixed_9", "source": "forms.rst", "text": "form so that the user can modify that data. The second goal of a form is to take the data submitted by the user and to re-apply it to the object. There's a lot more to learn and a lot of *powerful* tricks in the Symfony forms: Reference: :maxdepth: 1 /reference/forms/types Advanced Features: :maxdepth: 1 /controller/upload_file /security/csrf /form/create_custom_field_type /form/data_transformers /form/data_mappers /form/create_form_type_extension /form/type_guesser Form Themes and Customization: :maxdepth: 1 /form/bootstrap4 /form/bootstrap5 /form/tailwindcss /form/form_customization /form/form_themes Events: :maxdepth: 1 /form/events /form/dynamic_form_modification Validation: :maxdepth: 1 /form/validation_groups /form/disabling_validation Misc.: :maxdepth: 1 /form/direct_submit /form/embedded /form/form_collections /form/inherit_data_option /form/multiple_buttons /form/unit_testing /form/use_empty_data /form/without_class", "title": "Forms", "category": "forms"}
{"chunk_id": "http_cache.rst_fixed_0", "source": "http_cache.rst", "text": "HTTP Cache The nature of rich web applications means that they're dynamic. No matter how efficient your application, each request will always contain more overhead than serving a static file. Usually, that's fine. But when you need your requests to be lightning fast, you need HTTP caching. Caching on the Shoulders of Giants With HTTP Caching, you cache the full output of a page (i.e. the response) and bypass your application *entirely* on subsequent requests. Caching entire responses isn't always possible for highly dynamic sites, or is it? With Edge Side Includes (ESI) , you can use the power of HTTP caching on only *fragments* of your site. The Symfony cache system is different because it relies on the simplicity and power of the HTTP cache as defined in `RFC 7234 - Caching`_. Instead of reinventing a caching methodology, Symfony embraces the standard that defines basic communication on the Web. Once you understand the fundamental HTTP validation and expiration caching models, you'll be ready to understand the Symfony cache system. Since caching with HTTP isn't unique to Symfony, many articles already exist on the topic. If you're new to HTTP caching, Ryan Tomayko's article `Things Caches Do`_ is *highly* recommended. Another in-depth resource is Mark Nottingham's `Cache Tutorial`_. Caching with a Gateway Cache When caching with HTTP, the *cache* is separated from your application entirely and sits between your application and the client making the request. The job of the cache is to accept requests from the client and pass them back to your application. The cache will also receive responses back from your application and forward them on to the client. The cache is the \"middle-man\" of the request-response communication between the client and your application. Along the way, the cache will store each response that is deemed \"cacheable\" (See http-cache-introduction). If the same resource is requested again, the cache sends the cached response to the client, ignoring your application entirely. This type of cache is known as an HTTP gateway cache and many exist such as `Varnish`_, `Squid in reverse proxy mode`_, and the Symfony reverse proxy. Gateway caches are sometimes referred to as reverse proxy caches, surrogate caches, or even HTTP accelerators. Symfony Reverse Proxy Symfony comes with a reverse proxy (i.e. gateway cache) written in PHP. It's not a fully-featured reverse proxy cache like Varnish , but it is a great way to start. For details on setting up Varnish, see /http_cache/varnish. Use the framework.http_cache option to enable the proxy for the prod environment : # config/packages/framework.yaml when@prod: framework: http_cache: true <!-- config/packages/framework.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <when env=\"prod\"> <framework:config> <!-- ... --> <framework:http-cache enabled=\"true\"/> </framework:config> </when> </container> // config/packages/framework.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework, string $env): void { if ('prod' === $env) { $framework->httpCache()->enabled(true); } }; The kernel will immediately act as a reverse proxy: caching responses from your application and returning them to the client. The proxy has a sensible default configuration, but", "title": "HTTP Cache", "category": "http_cache"}
{"chunk_id": "http_cache.rst_fixed_1", "source": "http_cache.rst", "text": "on setting up Varnish, see /http_cache/varnish. Use the framework.http_cache option to enable the proxy for the prod environment : # config/packages/framework.yaml when@prod: framework: http_cache: true <!-- config/packages/framework.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <when env=\"prod\"> <framework:config> <!-- ... --> <framework:http-cache enabled=\"true\"/> </framework:config> </when> </container> // config/packages/framework.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework, string $env): void { if ('prod' === $env) { $framework->httpCache()->enabled(true); } }; The kernel will immediately act as a reverse proxy: caching responses from your application and returning them to the client. The proxy has a sensible default configuration, but it can be finely tuned via a set of options . When in debug mode , Symfony automatically adds an X-Symfony-Cache header to the response. You can also use the trace_level config option and set it to either none, short or full to add this information. short will add the information for the main request only. It's written in a concise way that makes it easy to record the information in your server log files. For example, in Apache you can use %{X-Symfony-Cache}o in LogFormat format statements. This information can be used to extract general information about cache efficiency of your routes. You can change the name of the header used for the trace information using the trace_header config option. The Symfony reverse proxy is a great tool to use when developing your website or when you deploy your website to a shared host where you cannot install anything beyond PHP code. But being written in PHP, it cannot be as fast as a proxy written in C. Fortunately, since all reverse proxies are effectively the same, you should be able to switch to something more robust - like Varnish - without any problems. See How to use Varnish Making your Responses HTTP Cacheable Once you've added a reverse proxy cache (e.g. like the Symfony reverse proxy or Varnish), you're ready to cache your responses. To do that, you need to *communicate* to your cache *which* responses are cacheable and for how long. This is done by setting HTTP cache headers on the response. HTTP specifies four response cache headers that you can set to enable caching: * Cache-Control * Expires * ETag * Last-Modified These four headers are used to help cache your responses via *two* different models: #. Expiration Caching Used to cache your entire response for a specific amount of time (e.g. 24 hours). Simple, but cache invalidation is more difficult. #. Validation Caching More complex: used to cache your response, but allows you to dynamically invalidate it as soon as your content changes. All of the HTTP headers you'll read about are *not* invented by Symfony! They're part of an HTTP specification that's used by sites all over the web. To dig deeper into HTTP Caching, check out the documents `RFC 7234 - Caching`_ and `RFC 7232 - Conditional Requests`_. As a web developer, you are strongly urged to read the specification. Its clarity and power", "title": "HTTP Cache", "category": "http_cache"}
{"chunk_id": "http_cache.rst_fixed_2", "source": "http_cache.rst", "text": "specific amount of time (e.g. 24 hours). Simple, but cache invalidation is more difficult. #. Validation Caching More complex: used to cache your response, but allows you to dynamically invalidate it as soon as your content changes. All of the HTTP headers you'll read about are *not* invented by Symfony! They're part of an HTTP specification that's used by sites all over the web. To dig deeper into HTTP Caching, check out the documents `RFC 7234 - Caching`_ and `RFC 7232 - Conditional Requests`_. As a web developer, you are strongly urged to read the specification. Its clarity and power - even more than fifteen years after its creation - is invaluable. Don't be put-off by the appearance of the spec - its contents are much more beautiful than its cover! Expiration Caching The *easiest* way to cache a response is by caching it for a specific amount of time:: // src/Controller/BlogController.php use Symfony\\Component\\HttpKernel\\Attribute\\Cache; // ... #[Cache(public: true, maxage: 3600, mustRevalidate: true)] public function index(): Response { return $this->render('blog/index.html.twig', []); } // src/Controller/BlogController.php use Symfony\\Component\\HttpFoundation\\Response; public function index(): Response { // somehow create a Response object, like by rendering a template $response = $this->render('blog/index.html.twig', []); // cache publicly for 3600 seconds $response->setPublic(); $response->setMaxAge(3600); // (optional) set a custom Cache-Control directive $response->headers->addCacheControlDirective('must-revalidate', true); return $response; } Thanks to this new code, your HTTP response will have the following header: Cache-Control: public, maxage=3600, must-revalidate When both are used, the cache headers defined in the controller take precedence over those configured with the #[Cache] attribute. This tells your HTTP reverse proxy to cache this response for 3600 seconds. If *anyone* requests this URL again before 3600 seconds, your application *won't* be hit at all. If you're using the Symfony reverse proxy, look at the X-Symfony-Cache header for debugging information about cache hits and misses. The URI of the request is used as the cache key (unless you vary ). This provides great performance and is simple to use. But, cache *invalidation* is not supported. If your content change, you'll need to wait until your cache expires for the page to update. Actually, you *can* manually invalidate your cache, but it's not part of the HTTP Caching spec. See http-cache-invalidation. If you need to set cache headers for many different controller actions, check out `FOSHttpCacheBundle`_. It provides a way to define cache headers based on the URL pattern and other request properties. Finally, for more information about expiration caching, see /http_cache/expiration. Validation Caching With expiration caching, you say \"cache for 3600 seconds!\". But, when someone updates cached content, you won't see that content on your site until the cache expires. If you need to see updated content *immediately*, you either need to invalidate your cache *or* use the validation caching model. For details, see /http_cache/validation. Safe Methods: Only caching GET or HEAD requests HTTP caching only works for \"safe\" HTTP methods (like GET and HEAD). This means three things: * Don't try to cache PUT or DELETE requests. It won't work and with good", "title": "HTTP Cache", "category": "http_cache"}
{"chunk_id": "http_cache.rst_fixed_3", "source": "http_cache.rst", "text": "more information about expiration caching, see /http_cache/expiration. Validation Caching With expiration caching, you say \"cache for 3600 seconds!\". But, when someone updates cached content, you won't see that content on your site until the cache expires. If you need to see updated content *immediately*, you either need to invalidate your cache *or* use the validation caching model. For details, see /http_cache/validation. Safe Methods: Only caching GET or HEAD requests HTTP caching only works for \"safe\" HTTP methods (like GET and HEAD). This means three things: * Don't try to cache PUT or DELETE requests. It won't work and with good reason. These methods are meant to be used when mutating the state of your application (e.g. deleting a blog post). Caching them would prevent certain requests from hitting and mutating your application. * POST requests are generally considered uncacheable, but `they can be cached`_ when they include explicit freshness information. However, POST caching is not widely implemented, so you should avoid it if possible. * You should *never* change the state of your application (e.g. update a blog post) when responding to a GET or HEAD request. If those requests are cached, future requests may not actually hit your server. More Response Methods The Response class provides many more methods related to the cache. Here are the most useful ones:: // marks the Response stale $response->expire(); // forces the response to return a proper 304 response with no content $response->setNotModified(); Additionally, most cache-related HTTP headers can be set via the single Symfony\\\\Component\\\\HttpFoundation\\\\Response::setCache method:: // use this method to set several cache settings in one call // (this example lists all the available cache settings) $response->setCache([ 'must_revalidate' => false, 'no_cache' => false, 'no_store' => false, 'no_transform' => false, 'public' => true, 'private' => false, 'proxy_revalidate' => false, 'max_age' => 600, 's_maxage' => 600, 'immutable' => true, 'last_modified' => new \\DateTime(), 'etag' => 'abcdef' ]); All these options are also available when using the #[Cache] attribute. Cache Invalidation Cache invalidation is *not* part of the HTTP specification. Still, it can be really useful to delete various HTTP cache entries as soon as some content on your site is updated. For details, see /http_cache/cache_invalidation. Using Edge Side Includes When pages contain dynamic parts, you may not be able to cache entire pages, but only parts of it. Read /http_cache/esi to find out how to configure different cache strategies for specific parts of your page. HTTP Caching and User Sessions Whenever the session is started during a request, Symfony turns the response into a private non-cacheable response. This is the best default behavior to not cache private user information (e.g. a shopping cart, a user profile details, etc.) and expose it to other visitors. However, even requests making use of the session can be cached under some circumstances. For example, information related to some user group could be cached for all the users belonging to that group. Handling these advanced caching scenarios is out of the scope of Symfony, but they can be solved", "title": "HTTP Cache", "category": "http_cache"}
{"chunk_id": "http_cache.rst_fixed_4", "source": "http_cache.rst", "text": "page. HTTP Caching and User Sessions Whenever the session is started during a request, Symfony turns the response into a private non-cacheable response. This is the best default behavior to not cache private user information (e.g. a shopping cart, a user profile details, etc.) and expose it to other visitors. However, even requests making use of the session can be cached under some circumstances. For example, information related to some user group could be cached for all the users belonging to that group. Handling these advanced caching scenarios is out of the scope of Symfony, but they can be solved with the `FOSHttpCacheBundle`_. In order to disable the default Symfony behavior that makes requests using the session uncacheable, add the following internal header to your response and Symfony won't modify it:: use Symfony\\Component\\HttpKernel\\EventListener\\AbstractSessionListener; $response->headers->set(AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER, 'true'); Summary Symfony was designed to follow the proven rules of the road: HTTP. Caching is no exception. Mastering the Symfony cache system means becoming familiar with the HTTP cache models and using them effectively. This means that, instead of relying only on Symfony documentation and code examples, you have access to a world of knowledge related to HTTP caching and gateway caches such as Varnish. Learn more :maxdepth: 1 :glob: http_cache/*", "title": "HTTP Cache", "category": "http_cache"}
{"chunk_id": "index.rst_fixed_0", "source": "index.rst", "text": "Symfony Documentation Quick Tour Get started fast with the Symfony Quick Tour : * /quick_tour/the_big_picture * /quick_tour/flex_recipes * /quick_tour/the_architecture Getting Started :maxdepth: 2 getting_started/index Topics :maxdepth: 1 best_practices bundles cache console doctrine deployment event_dispatcher forms frontend html_sanitizer http_cache http_client lock logging mailer mercure messenger migration notifier performance profiler rate_limiter routing security session setup serializer service_container testing translation validation web_link webhook workflow Components Read the Components documentation. Reference Documents Get answers quickly with reference documents: Contributing Contribute to Symfony: Create your Own Framework Want to create your own framework based on Symfony? :maxdepth: 2 create_framework/index", "title": "Symfony Documentation", "category": "index"}
{"chunk_id": "mailer.rst_fixed_0", "source": "mailer.rst", "text": "Sending Emails with Mailer Installation Symfony's Mailer & Mime components form a *powerful* system for creating and sending emails - complete with support for multipart messages, Twig integration, CSS inlining, file attachments and a lot more. Get them installed with: $ composer require symfony/mailer Transport Setup Emails are delivered via a \"transport\". Out of the box, you can deliver emails over SMTP by configuring the DSN in your .env file (the user, pass and port parameters are optional): # .env MAILER_DSN=smtp://user:pass@smtp.example.com:port # config/packages/mailer.yaml framework: mailer: dsn: '%env(MAILER_DSN)%' <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:mailer dsn=\"%env(MAILER_DSN)%\"/> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env; return static function (FrameworkConfig $framework): void { $framework->mailer()->dsn(env('MAILER_DSN')); }; If the username, password or host contain any character considered special in a URI (such as : / ? # [ ] @ ! $ & ' ( ) * + , ; =), you must encode them. See `RFC 3986`_ for the full list of reserved characters or use the urlencode function to encode them. Using Built-in Transports ============ ======================================== ============================================================== DSN protocol Example Description ============ ======================================== ============================================================== smtp smtp://user:pass@smtp.example.com:25 Mailer uses an SMTP server to send emails sendmail sendmail://default Mailer uses the local sendmail binary to send emails native native://default Mailer uses the sendmail binary and options configured in the sendmail_path setting of php.ini. On Windows hosts, Mailer fallbacks to smtp and smtp_port php.ini settings when sendmail_path is not configured. ============ ======================================== ============================================================== When using native://default, if php.ini uses the sendmail -t command, you won't have error reporting and Bcc headers won't be removed. It's highly recommended to NOT use native://default as you cannot control how sendmail is configured (prefer using sendmail://default if possible). Using a 3rd Party Transport Instead of using your own SMTP server or sendmail binary, you can send emails via a third-party provider: ===================== =============================================== =============== Service Install with Webhook support ===================== =============================================== =============== `AhaSend`_ composer require symfony/aha-send-mailer yes `Amazon SES`_ composer require symfony/amazon-mailer `Azure`_ composer require symfony/azure-mailer `Brevo`_ composer require symfony/brevo-mailer yes `Infobip`_ composer require symfony/infobip-mailer `Mailgun`_ composer require symfony/mailgun-mailer yes `Mailjet`_ composer require symfony/mailjet-mailer yes `Mailomat`_ composer require symfony/mailomat-mailer yes `MailPace`_ composer require symfony/mail-pace-mailer `MailerSend`_ composer require symfony/mailer-send-mailer yes `Mailtrap`_ composer require symfony/mailtrap-mailer yes `Mandrill`_ composer require symfony/mailchimp-mailer yes `Postal`_ composer require symfony/postal-mailer `Postmark`_ composer require symfony/postmark-mailer yes `Resend`_ composer require symfony/resend-mailer yes `Scaleway`_ composer require symfony/scaleway-mailer `SendGrid`_ composer require symfony/sendgrid-mailer yes `Sweego`_ composer require symfony/sweego-mailer yes ===================== =============================================== =============== The Azure and Resend integrations were introduced in Symfony 7.1. The Mailomat, Mailtrap, Postal and Sweego integrations were introduced in Symfony 7.2. The AhaSend integration was introduced in Symfony 7.3. As a convenience, Symfony also provides support for Gmail (composer require symfony/google-mailer), but this should not be used in production. In development, you should probably use an email catcher instead. Note that most supported providers also offer a free tier. Each library includes a Symfony Flex recipe that will add a configuration example to your .env file. For example,", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_1", "source": "mailer.rst", "text": "require symfony/sendgrid-mailer yes `Sweego`_ composer require symfony/sweego-mailer yes ===================== =============================================== =============== The Azure and Resend integrations were introduced in Symfony 7.1. The Mailomat, Mailtrap, Postal and Sweego integrations were introduced in Symfony 7.2. The AhaSend integration was introduced in Symfony 7.3. As a convenience, Symfony also provides support for Gmail (composer require symfony/google-mailer), but this should not be used in production. In development, you should probably use an email catcher instead. Note that most supported providers also offer a free tier. Each library includes a Symfony Flex recipe that will add a configuration example to your .env file. For example, suppose you want to use SendGrid. First, install it: $ composer require symfony/sendgrid-mailer You'll now have a new line in your .env file that you can uncomment: # .env MAILER_DSN=sendgrid://KEY@default The MAILER_DSN isn't a *real* address: it's a convenient format that offloads most of the configuration work to mailer. The sendgrid scheme activates the SendGrid provider that you installed, which knows all about how to deliver messages via SendGrid. The *only* part you need to change is the KEY placeholder. Each provider has different environment variables that the Mailer uses to configure the *actual* protocol, address and authentication for delivery. Some also have options that can be configured with query parameters at the end of the MAILER_DSN - like ?region= for Amazon SES, Mailgun or Scaleway. Some providers support sending via http, api or smtp. Symfony chooses the best available transport, but you can force to use one: # .env # force to use SMTP instead of HTTP (which is the default) MAILER_DSN=sendgrid+smtp://$SENDGRID_KEY@default This table shows the full list of available DSN formats for each third party provider: | Provider | Formats | | `AhaSend`_ | - SMTP ahasend+smtp://USERNAME:PASSWORD@default | | | - HTTP n/a | | | - API ahasend+api://KEY@default | | `Amazon SES`_ | - SMTP ses+smtp://USERNAME:PASSWORD@default | | | - HTTP ses+https://ACCESS_KEY:SECRET_KEY@default | | | - API ses+api://ACCESS_KEY:SECRET_KEY@default | | `Azure`_ | - API azure+api://ACS_RESOURCE_NAME:KEY@default | | `Brevo`_ | - SMTP brevo+smtp://USERNAME:PASSWORD@default | | | - HTTP n/a | | | - API brevo+api://KEY@default | | `Google Gmail`_ | - SMTP gmail+smtp://USERNAME:APP-PASSWORD@default | | | - HTTP n/a | | | - API n/a | | `Infobip`_ | - SMTP infobip+smtp://KEY@default | | | - HTTP n/a | | | - API infobip+api://KEY@BASE_URL | | `Mandrill`_ | - SMTP mandrill+smtp://USERNAME:PASSWORD@default | | | - HTTP mandrill+https://KEY@default | | | - API mandrill+api://KEY@default | | `MailerSend`_ | - SMTP mailersend+smtp://KEY@default | | | - HTTP n/a | | | - API mailersend+api://KEY@BASE_URL | | `Mailgun`_ | - SMTP mailgun+smtp://USERNAME:PASSWORD@default | | | - HTTP mailgun+https://KEY:DOMAIN@default | | | - API mailgun+api://KEY:DOMAIN@default | | `Mailjet`_ | - SMTP mailjet+smtp://ACCESS_KEY:SECRET_KEY@default | | | - HTTP n/a | | | - API mailjet+api://ACCESS_KEY:SECRET_KEY@default | | `Mailomat`_ | - SMTP mailomat+smtp://USERNAME:PASSWORD@default | | | - HTTP n/a | | | - API mailomat+api://KEY@default | | `MailPace`_ | - SMTP mailpace+api://API_TOKEN@default | | | - HTTP n/a | | | - API mailpace+api://API_TOKEN@default", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_2", "source": "mailer.rst", "text": "| | - API mandrill+api://KEY@default | | `MailerSend`_ | - SMTP mailersend+smtp://KEY@default | | | - HTTP n/a | | | - API mailersend+api://KEY@BASE_URL | | `Mailgun`_ | - SMTP mailgun+smtp://USERNAME:PASSWORD@default | | | - HTTP mailgun+https://KEY:DOMAIN@default | | | - API mailgun+api://KEY:DOMAIN@default | | `Mailjet`_ | - SMTP mailjet+smtp://ACCESS_KEY:SECRET_KEY@default | | | - HTTP n/a | | | - API mailjet+api://ACCESS_KEY:SECRET_KEY@default | | `Mailomat`_ | - SMTP mailomat+smtp://USERNAME:PASSWORD@default | | | - HTTP n/a | | | - API mailomat+api://KEY@default | | `MailPace`_ | - SMTP mailpace+api://API_TOKEN@default | | | - HTTP n/a | | | - API mailpace+api://API_TOKEN@default | | `Mailtrap`_ | - SMTP mailtrap+smtp://PASSWORD@default | | | - HTTP n/a | | | - API mailtrap+api://API_TOKEN@default | | `Postal`_ | - SMTP n/a | | | - HTTP n/a | | | - API postal+api://API_KEY@BASE_URL | | `Postmark`_ | - SMTP postmark+smtp://ID@default | | | - HTTP n/a | | | - API postmark+api://KEY@default | | `Resend`_ | - SMTP resend+smtp://resend:API_KEY@default | | | - HTTP n/a | | | - API resend+api://API_KEY@default | | `Scaleway`_ | - SMTP scaleway+smtp://PROJECT_ID:API_KEY@default | | | - HTTP n/a | | | - API scaleway+api://PROJECT_ID:API_KEY@default | | `Sendgrid`_ | - SMTP sendgrid+smtp://KEY@default | | | - HTTP n/a | | | - API sendgrid+api://KEY@default | | `Sweego`_ | - SMTP sweego+smtp://LOGIN:PASSWORD@HOST:PORT | | | - HTTP n/a | | | - API sweego+api://API_KEY@default | If your credentials contain special characters, you must URL-encode them. For example, the DSN ses+smtp://ABC1234:abc+12/345@default should be configured as ses+smtp://ABC1234:abc%2B12%2F345@default If you want to use the ses+smtp transport together with Messenger to send messages in background , you need to add the ping_threshold parameter to your MAILER_DSN with a value lower than 10: ses+smtp://USERNAME:PASSWORD@default?ping_threshold=9 When using SMTP, the default timeout for sending a message before throwing an exception is the value defined in the `default_socket_timeout`_ PHP.ini option. Besides SMTP, many 3rd party transports offer a web API to send emails. To do so, you have to install (additionally to the bridge) the HttpClient component via composer require symfony/http-client. To use Google Gmail, you must have a Google Account with 2-Step-Verification (2FA) enabled and you must use `App Password`_ to authenticate. Also note that Google revokes your App Passwords when you change your Google Account password and then you need to generate a new one. Using other methods (like XOAUTH2 or the Gmail API) are not supported currently. You should use Gmail for testing purposes only and use a real provider in production. If you want to override the default host for a provider (to debug an issue using a service like requestbin.com), change default by your host: # .env MAILER_DSN=mailgun+https://KEY:DOMAIN@requestbin.com Note that the protocol is *always* HTTPs and cannot be changed. The specific transports, e.g. mailgun+smtp are designed to work without any manual configuration. Changing the port by appending it to your DSN is not supported for any of these <provider>+smtp transports. If you need to change the port, use the smtp transport instead, like so:", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_3", "source": "mailer.rst", "text": "currently. You should use Gmail for testing purposes only and use a real provider in production. If you want to override the default host for a provider (to debug an issue using a service like requestbin.com), change default by your host: # .env MAILER_DSN=mailgun+https://KEY:DOMAIN@requestbin.com Note that the protocol is *always* HTTPs and cannot be changed. The specific transports, e.g. mailgun+smtp are designed to work without any manual configuration. Changing the port by appending it to your DSN is not supported for any of these <provider>+smtp transports. If you need to change the port, use the smtp transport instead, like so: # .env MAILER_DSN=smtp://KEY:DOMAIN@smtp.eu.mailgun.org.com:25 Some third party mailers, when using the API, support status callbacks via webhooks. See the Webhook documentation for more details. High Availability Symfony's mailer supports `high availability`_ via a technique called \"failover\" to ensure that emails are sent even if one mailer server fails. A failover transport is configured with two or more transports and the failover keyword: MAILER_DSN=\"failover(postmark+api://ID@default sendgrid+smtp://KEY@default)\" The failover-transport starts using the first transport and if it fails, it will retry the same delivery with the next transports until one of them succeeds (or until all of them fail). By default, delivery is retried 60 seconds after a failed attempt. You can adjust the retry period by setting the retry_period option in the DSN: MAILER_DSN=\"failover(postmark+api://ID@default sendgrid+smtp://KEY@default)?retry_period=15\" The retry_period option was introduced in Symfony 7.3. Load Balancing Symfony's mailer supports `load balancing`_ via a technique called \"round-robin\" to distribute the mailing workload across multiple transports. A round-robin transport is configured with two or more transports and the roundrobin keyword: MAILER_DSN=\"roundrobin(postmark+api://ID@default sendgrid+smtp://KEY@default)\" The round-robin transport starts with a *randomly* selected transport and then switches to the next available transport for each subsequent email. As with the failover transport, round-robin retries deliveries until a transport succeeds (or all fail). In contrast to the failover transport, it *spreads* the load across all its transports. By default, delivery is retried 60 seconds after a failed attempt. You can adjust the retry period by setting the retry_period option in the DSN: MAILER_DSN=\"roundrobin(postmark+api://ID@default sendgrid+smtp://KEY@default)?retry_period=15\" The retry_period option was introduced in Symfony 7.3. TLS Peer Verification By default, SMTP transports perform TLS peer verification. This behavior is configurable with the verify_peer option. Although it's not recommended to disable this verification for security reasons, it can be useful while developing the application or when using a self-signed certificate:: $dsn = 'smtp://user:pass@smtp.example.com?verify_peer=0'; TLS Peer Fingerprint Verification Additional fingerprint verification can be enforced with the peer_fingerprint option. This is especially useful when a self-signed certificate is used and disabling verify_peer is needed, but security is still desired. Fingerprint may be specified as SHA1 or MD5 hash:: $dsn = 'smtp://user:pass@smtp.example.com?peer_fingerprint=6A1CF3B08D175A284C30BC10DE19162307C7286E'; Disabling Automatic TLS The option to disable automatic TLS was introduced in Symfony 7.1. By default, the Mailer component will use encryption when the OpenSSL extension is enabled and the SMTP server supports STARTTLS. This behavior can be turned off by calling setAutoTls(false) on the EsmtpTransport instance, or by setting the auto_tls option to false in", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_4", "source": "mailer.rst", "text": "Fingerprint Verification Additional fingerprint verification can be enforced with the peer_fingerprint option. This is especially useful when a self-signed certificate is used and disabling verify_peer is needed, but security is still desired. Fingerprint may be specified as SHA1 or MD5 hash:: $dsn = 'smtp://user:pass@smtp.example.com?peer_fingerprint=6A1CF3B08D175A284C30BC10DE19162307C7286E'; Disabling Automatic TLS The option to disable automatic TLS was introduced in Symfony 7.1. By default, the Mailer component will use encryption when the OpenSSL extension is enabled and the SMTP server supports STARTTLS. This behavior can be turned off by calling setAutoTls(false) on the EsmtpTransport instance, or by setting the auto_tls option to false in the DSN:: $dsn = 'smtp://user:pass@10.0.0.25?auto_tls=false'; It's not recommended to disable TLS while connecting to an SMTP server over the Internet, but it can be useful when both the application and the SMTP server are in a secured network, where there is no need for additional encryption. This setting only works when the smtp:// protocol is used. Ensure TLS You may want to ensure that TLS is used (either directly or via STARTTLS) when sending mail over SMTP, regardless of other options or SMTP server support. To require TLS, call setRequireTls(true) on the EsmtpTransport instance, or set the require_tls option to true in the DSN:: $dsn = 'smtp://user:pass@10.0.0.25?require_tls=true'; When TLS is required, a Symfony\\\\Component\\\\Mailer\\\\Exception\\\\TransportException is thrown if a TLS connection cannot be established during the initial communication with the SMTP server. This setting only applies when using the smtp:// protocol. The require_tls option was introduced in Symfony 7.3. Binding to IPv4 or IPv6 The option to bind to IPv4, or IPv6, or a specific IP address was introduced in Symfony 7.3. By default, the underlying SocketStream will bind to IPv4 or IPv6 based on the available interfaces. You can enforce binding to a specific protocol or IP address by using the source_ip option. To bind to IPv4, use:: $dsn = 'smtp://smtp.example.com?source_ip=0.0.0.0'; As per RFC2732, IPv6 addresses must be enclosed in square brackets. To bind to IPv6, use:: $dsn = 'smtp://smtp.example.com?source_ip=[::]'; This option only works when using the smtp:// protocol. Overriding default SMTP authenticators By default, SMTP transports will try to login using all authentication methods available on the SMTP server, one after the other. In some cases, it may be useful to redefine the supported authentication methods to ensure that the preferred method will be used first. This can be done from EsmtpTransport constructor or using the setAuthenticators() method:: use Symfony\\Component\\Mailer\\Transport\\Smtp\\Auth\\XOAuth2Authenticator; use Symfony\\Component\\Mailer\\Transport\\Smtp\\EsmtpTransport; // Choose one of these two options: // Option 1: pass the authenticators to the constructor $transport = new EsmtpTransport( host: 'oauth-smtp.domain.tld', authenticators: [new XOAuth2Authenticator()] ); // Option 2: call a method to redefine the authenticators $transport->setAuthenticators([new XOAuth2Authenticator()]); Other Options command Command to be executed by sendmail transport:: $dsn = 'sendmail://default?command=/usr/sbin/sendmail%20-oi%20-t' local_domain The domain name to use in HELO command:: $dsn = 'smtps://smtp.example.com?local_domain=example.org' restart_threshold The maximum number of messages to send before re-starting the transport. It can be used together with restart_threshold_sleep:: $dsn = 'smtps://smtp.example.com?restart_threshold=10&restart_threshold_sleep=1' restart_threshold_sleep The number of seconds to sleep between stopping and re-starting the transport.", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_5", "source": "mailer.rst", "text": "use Symfony\\Component\\Mailer\\Transport\\Smtp\\EsmtpTransport; // Choose one of these two options: // Option 1: pass the authenticators to the constructor $transport = new EsmtpTransport( host: 'oauth-smtp.domain.tld', authenticators: [new XOAuth2Authenticator()] ); // Option 2: call a method to redefine the authenticators $transport->setAuthenticators([new XOAuth2Authenticator()]); Other Options command Command to be executed by sendmail transport:: $dsn = 'sendmail://default?command=/usr/sbin/sendmail%20-oi%20-t' local_domain The domain name to use in HELO command:: $dsn = 'smtps://smtp.example.com?local_domain=example.org' restart_threshold The maximum number of messages to send before re-starting the transport. It can be used together with restart_threshold_sleep:: $dsn = 'smtps://smtp.example.com?restart_threshold=10&restart_threshold_sleep=1' restart_threshold_sleep The number of seconds to sleep between stopping and re-starting the transport. It's common to combine it with restart_threshold:: $dsn = 'smtps://smtp.example.com?restart_threshold=10&restart_threshold_sleep=1' ping_threshold The minimum number of seconds between two messages required to ping the server:: $dsn = 'smtps://smtp.example.com?ping_threshold=200' max_per_second The number of messages to send per second (0 to disable this limitation):: $dsn = 'smtps://smtp.example.com?max_per_second=2' Custom Transport Factories If you want to support your own custom DSN (acme://...), you can create a custom transport factory. To do so, create a class that implements Symfony\\\\Component\\\\Mailer\\\\Transport\\\\TransportFactoryInterface or, if you prefer, extend the Symfony\\\\Component\\\\Mailer\\\\Transport\\\\AbstractTransportFactory class to save some boilerplate code:: // src/Mailer/AcmeTransportFactory.php final class AcmeTransportFactory extends AbstractTransportFactory { public function create(Dsn $dsn): TransportInterface { // parse the given DSN, extract data/credentials from it // and then, create and return the transport } protected function getSupportedSchemes(): array { // this supports DSN starting with `acme://` return ['acme']; } } After creating the custom transport class, register it as a service in your application and tag it with the mailer.transport_factory tag. Creating & Sending Messages To send an email, get a Symfony\\\\Component\\\\Mailer\\\\Mailer instance by type-hinting Symfony\\\\Component\\\\Mailer\\\\MailerInterface and create an Symfony\\\\Component\\\\Mime\\\\Email object:: // src/Controller/MailerController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Mailer\\MailerInterface; use Symfony\\Component\\Mime\\Email; use Symfony\\Component\\Routing\\Attribute\\Route; class MailerController extends AbstractController { #[Route('/email')] public function sendEmail(MailerInterface $mailer): Response { $email = (new Email()) ->from('hello@example.com') ->to('you@example.com') //->cc('cc@example.com') //->bcc('bcc@example.com') //->replyTo('fabien@example.com') //->priority(Email::PRIORITY_HIGH) ->subject('Time for Symfony Mailer!') ->text('Sending emails is fun again!') ->html('<p>See Twig integration for better HTML integration!</p>'); $mailer->send($email); // ... } } That's it! The message will be sent immediately via the transport you configured. If you prefer to send emails asynchronously to improve performance, read the Sending Messages Async section. Also, if your application has the Messenger component installed, all emails will be sent asynchronously by default (but you can change that ). Email Addresses All the methods that require email addresses (from(), to(), etc.) accept both strings or address objects:: // ... use Symfony\\Component\\Mime\\Address; $email = (new Email()) // email address as a simple string ->from('fabien@example.com') // non-ASCII characters are supported both in the local part and the domain; // if the SMTP server doesn't support this feature, you'll see an exception ->from('jânë.dœ@ëxãmplę.com') // email address as an object ->from(new Address('fabien@example.com')) // defining the email address and name as an object // (email clients will display the name) ->from(new Address('fabien@example.com', 'Fabien')) // defining the email address and name as a string // (the format must match: 'Name <email@example.com>') ->from(Address::create('Fabien Potencier <fabien@example.com>')) // ... ; Instead of calling ->from()", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_6", "source": "mailer.rst", "text": "address objects:: // ... use Symfony\\Component\\Mime\\Address; $email = (new Email()) // email address as a simple string ->from('fabien@example.com') // non-ASCII characters are supported both in the local part and the domain; // if the SMTP server doesn't support this feature, you'll see an exception ->from('jânë.dœ@ëxãmplę.com') // email address as an object ->from(new Address('fabien@example.com')) // defining the email address and name as an object // (email clients will display the name) ->from(new Address('fabien@example.com', 'Fabien')) // defining the email address and name as a string // (the format must match: 'Name <email@example.com>') ->from(Address::create('Fabien Potencier <fabien@example.com>')) // ... ; Instead of calling ->from() *every* time you create a new email, you can configure emails globally to set the same From email to all messages. Support for non-ASCII email addresses (e.g. jânë.dœ@ëxãmplę.com) was introduced in Symfony 7.2. The local part of the address (what goes before the @) can include UTF-8 characters, except for the sender address (to avoid issues with bounced emails). For example: föóbàr@example.com, 用户@example.com, θσερ@example.com, etc. Use addTo(), addCc(), or addBcc() methods to add more addresses:: $email = (new Email()) ->to('foo@example.com') ->addTo('bar@example.com') ->cc('cc@example.com') ->addCc('cc2@example.com') // ... ; Alternatively, you can pass multiple addresses to each method:: $toAddresses = ['foo@example.com', new Address('bar@example.com')]; $email = (new Email()) ->to(...$toAddresses) ->cc('cc1@example.com', 'cc2@example.com') // ... ; Message Headers Messages include a number of header fields to describe their contents. Symfony sets all the required headers automatically, but you can set your own headers too. There are different types of headers (Id header, Mailbox header, Date header, etc.) but most of the times you'll set text headers:: $email = (new Email()) ->getHeaders() // this non-standard header tells compliant autoresponders (\"email holiday mode\") // to not reply to this message because it's an automated email ->addTextHeader('X-Auto-Response-Suppress', 'OOF, DR, RN, NRN, AutoReply') // use an array if you want to add a header with multiple values // (for example in the \"References\" or \"In-Reply-To\" header) ->addIdHeader('References', ['123@example.com', '456@example.com']) // ... ; Instead of calling ->addTextHeader() *every* time you create a new email, you can configure emails globally to set the same headers to all sent emails. Message Contents The text and HTML contents of the email messages can be strings (usually the result of rendering some template) or PHP resources:: $email = (new Email()) // ... // simple contents defined as a string ->text('Lorem ipsum...') ->html('<p>Lorem ipsum...</p>') // attach a file stream ->text(fopen('/path/to/emails/user_signup.txt', 'r')) ->html(fopen('/path/to/emails/user_signup.html', 'r')) ; You can also use Twig templates to render the HTML and text contents. Read the `Twig: HTML & CSS`_ section later in this article to learn more. File Attachments Use the addPart() method with a File to add files that exist on your file system:: use Symfony\\Component\\Mime\\Part\\DataPart; use Symfony\\Component\\Mime\\Part\\File; // ... $email = (new Email()) // ... ->addPart(new DataPart(new File('/path/to/documents/terms-of-use.pdf'))) // optionally you can tell email clients to display a custom name for the file ->addPart(new DataPart(new File('/path/to/documents/privacy.pdf'), 'Privacy Policy')) // optionally you can provide an explicit MIME type (otherwise it's guessed) ->addPart(new DataPart(new File('/path/to/documents/contract.doc'), 'Contract', 'application/msword')) ; Alternatively you can attach", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_7", "source": "mailer.rst", "text": "also use Twig templates to render the HTML and text contents. Read the `Twig: HTML & CSS`_ section later in this article to learn more. File Attachments Use the addPart() method with a File to add files that exist on your file system:: use Symfony\\Component\\Mime\\Part\\DataPart; use Symfony\\Component\\Mime\\Part\\File; // ... $email = (new Email()) // ... ->addPart(new DataPart(new File('/path/to/documents/terms-of-use.pdf'))) // optionally you can tell email clients to display a custom name for the file ->addPart(new DataPart(new File('/path/to/documents/privacy.pdf'), 'Privacy Policy')) // optionally you can provide an explicit MIME type (otherwise it's guessed) ->addPart(new DataPart(new File('/path/to/documents/contract.doc'), 'Contract', 'application/msword')) ; Alternatively you can attach contents from a stream by passing it directly to the DataPart:: $email = (new Email()) // ... ->addPart(new DataPart(fopen('/path/to/documents/contract.doc', 'r'))) ; Embedding Images If you want to display images inside your email, you must embed them instead of adding them as attachments. When using Twig to render the email contents, as explained later in this article , the images are embedded automatically. Otherwise, you need to embed them manually. First, use the addPart() method to add an image from a file or stream:: $email = (new Email()) // ... // get the image contents from a PHP resource ->addPart((new DataPart(fopen('/path/to/images/logo.png', 'r'), 'logo', 'image/png'))->asInline()) // get the image contents from an existing file ->addPart((new DataPart(new File('/path/to/images/signature.gif'), 'footer-signature', 'image/gif'))->asInline()) ; Use the asInline() method to embed the content instead of attaching it. The second optional argument of both methods is the image name (\"Content-ID\" in the MIME standard). Its value is an arbitrary string that must be unique in each email message and is used later to reference the images inside the HTML contents:: $email = (new Email()) // ... ->addPart((new DataPart(fopen('/path/to/images/logo.png', 'r'), 'logo', 'image/png'))->asInline()) ->addPart((new DataPart(new File('/path/to/images/signature.gif'), 'footer-signature', 'image/gif'))->asInline()) // reference images using the syntax 'cid:' + \"image embed name\" ->html('<img src=\"cid:logo\"> ... <img src=\"cid:footer-signature\"> ...') // use the same syntax for images included as HTML background images ->html('... <div background=\"cid:footer-signature\"> ... </div> ...') ; The actual Content-ID value present in the e-mail source will be randomly generated by Symfony. You can also use the DataPart::setContentId() method to define a custom Content-ID for the image and use it as its cid reference:: $part = new DataPart(new File('/path/to/images/signature.gif')); // according to the spec, the Content-ID value must include at least one '@' character $part->setContentId('footer-signature@my-app'); $email = (new Email()) // ... ->addPart($part->asInline()) ->html('... <img src=\"cid:footer-signature@my-app\"> ...') ; Configuring Emails Globally Instead of calling ->from() on each Email you create, you can configure this value globally so that it is set on all sent emails. The same is true with ->to() and headers. # config/packages/mailer.yaml framework: mailer: envelope: sender: 'fabien@example.com' recipients: ['foo@example.com', 'bar@example.com'] headers: From: 'Fabien <fabien@example.com>' Bcc: 'baz@example.com' X-Custom-Header: 'foobar' <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <framework:config> <framework:mailer> <framework:envelope> <framework:sender>fabien@example.com</framework:sender> <framework:recipients>foo@example.com</framework:recipients> <framework:recipients>bar@example.com</framework:recipients> </framework:envelope> <framework:header name=\"From\">Fabien &lt;fabien@example.com&gt;</framework:header> <framework:header name=\"Bcc\">baz@example.com</framework:header> <framework:header name=\"X-Custom-Header\">foobar</framework:header> </framework:mailer> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $mailer = $framework->mailer(); $mailer ->envelope() ->sender('fabien@example.com') ->recipients(['foo@example.com',", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_8", "source": "mailer.rst", "text": "->from() on each Email you create, you can configure this value globally so that it is set on all sent emails. The same is true with ->to() and headers. # config/packages/mailer.yaml framework: mailer: envelope: sender: 'fabien@example.com' recipients: ['foo@example.com', 'bar@example.com'] headers: From: 'Fabien <fabien@example.com>' Bcc: 'baz@example.com' X-Custom-Header: 'foobar' <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <framework:config> <framework:mailer> <framework:envelope> <framework:sender>fabien@example.com</framework:sender> <framework:recipients>foo@example.com</framework:recipients> <framework:recipients>bar@example.com</framework:recipients> </framework:envelope> <framework:header name=\"From\">Fabien &lt;fabien@example.com&gt;</framework:header> <framework:header name=\"Bcc\">baz@example.com</framework:header> <framework:header name=\"X-Custom-Header\">foobar</framework:header> </framework:mailer> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $mailer = $framework->mailer(); $mailer ->envelope() ->sender('fabien@example.com') ->recipients(['foo@example.com', 'bar@example.com']) ; $mailer->header('From')->value('Fabien <fabien@example.com>'); $mailer->header('Bcc')->value('baz@example.com'); $mailer->header('X-Custom-Header')->value('foobar'); }; Some third-party providers don't support the usage of keywords like from in the headers. Check out your provider's documentation before setting any global header. Handling Sending Failures Symfony Mailer considers that sending was successful when your transport (SMTP server or third-party provider) accepts the mail for further delivery. The message can later be lost or not delivered because of some problem in your provider, but that's out of reach for your Symfony application. If there's an error when handing over the email to your transport, Symfony throws a Symfony\\\\Component\\\\Mailer\\\\Exception\\\\TransportExceptionInterface. Catch that exception to recover from the error or to display some message:: use Symfony\\Component\\Mailer\\Exception\\TransportExceptionInterface; $email = new Email(); // ... try { $mailer->send($email); } catch (TransportExceptionInterface $e) { // some error prevented the email sending; display an // error message or try to resend the message } Debugging Emails The send() method of the mailer service injected when using MailerInterface doesn't return anything, so you can't access the sent email information. This is because it sends email messages **asynchronously** when the Messenger component is used in the application. To access information about the sent email, update your code to replace the Symfony\\\\Component\\\\Mailer\\\\MailerInterface with Symfony\\\\Component\\\\Mailer\\\\Transport\\\\TransportInterface: -use Symfony\\Component\\Mailer\\MailerInterface; +use Symfony\\Component\\Mailer\\Transport\\TransportInterface; // ... class MailerController extends AbstractController { #[Route('/email')] - public function sendEmail(MailerInterface $mailer): Response + public function sendEmail(TransportInterface $mailer): Response { $email = (new Email()) // ... $sentEmail = $mailer->send($email); // ... } } The send() method of TransportInterface returns an object of type Symfony\\\\Component\\\\Mailer\\\\SentMessage. This is because it always sends the emails **synchronously**, even if your application uses the Messenger component. The SentMessage object provides access to the original message (getOriginalMessage()) and to some debug information (getDebug()) such as the HTTP calls done by the HTTP transports, which is useful to debug errors. You can also access the Symfony\\\\Component\\\\Mailer\\\\SentMessage object by listening to the SentMessageEvent , and retrieve getDebug() by listening to the FailedMessageEvent . Some mailer providers change the Message-Id when sending the email. The getMessageId() method from SentMessage always returns the final ID of the message - whether it's the original random ID generated by Symfony or a new one generated by the provider. Exceptions related to mailer transports (those implementing Symfony\\\\Component\\\\Mailer\\\\Exception\\\\TransportException) also provide this debug information via the getDebug() method. Twig: HTML & CSS The Mime component integrates with the Twig template engine to provide advanced features such as CSS style", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_9", "source": "mailer.rst", "text": "can also access the Symfony\\\\Component\\\\Mailer\\\\SentMessage object by listening to the SentMessageEvent , and retrieve getDebug() by listening to the FailedMessageEvent . Some mailer providers change the Message-Id when sending the email. The getMessageId() method from SentMessage always returns the final ID of the message - whether it's the original random ID generated by Symfony or a new one generated by the provider. Exceptions related to mailer transports (those implementing Symfony\\\\Component\\\\Mailer\\\\Exception\\\\TransportException) also provide this debug information via the getDebug() method. Twig: HTML & CSS The Mime component integrates with the Twig template engine to provide advanced features such as CSS style inlining and support for HTML/CSS frameworks to create complex HTML email messages. First, make sure Twig is installed: $ composer require symfony/twig-bundle # or if you're using the component in a non-Symfony app: # composer require symfony/twig-bridge HTML Content To define the contents of your email with Twig, use the Symfony\\\\Bridge\\\\Twig\\\\Mime\\\\TemplatedEmail class. This class extends the normal Symfony\\\\Component\\\\Mime\\\\Email class but adds some new methods for Twig templates:: use Symfony\\Bridge\\Twig\\Mime\\TemplatedEmail; $email = (new TemplatedEmail()) ->from('fabien@example.com') ->to(new Address('ryan@example.com')) ->subject('Thanks for signing up!') // path of the Twig template to render ->htmlTemplate('emails/signup.html.twig') // change locale used in the template, e.g. to match user's locale ->locale('de') // pass variables (name => value) to the template ->context([ 'expiration_date' => new \\DateTime('+7 days'), 'username' => 'foo', ]) ; Then, create the template: {# templates/emails/signup.html.twig #} <h1>Welcome {{ email.toName }}!</h1> <p> You signed up as {{ username }} the following email: </p> <p><code>{{ email.to[0].address }}</code></p> <p> <a href=\"#\">Activate your account</a> (this link is valid until {{ expiration_date|date('F jS') }}) </p> The Twig template has access to any of the parameters passed in the context() method of the TemplatedEmail class and also to a special variable called email, which is an instance of Symfony\\\\Bridge\\\\Twig\\\\Mime\\\\WrappedTemplatedEmail. Text Content When the text content of a TemplatedEmail is not explicitly defined, it is automatically generated from the HTML contents. Symfony uses the following strategy when generating the text version of an email: * If an explicit HTML to text converter has been configured (see twig.mailer.html_to_text_converter ), it calls it; * If not, and if you have `league/html-to-markdown`_ installed in your application, it uses it to turn HTML into Markdown (so the text email has some visual appeal); * Otherwise, it applies the strip_tags PHP function to the original HTML contents. If you want to define the text content yourself, use the text() method explained in the previous sections or the textTemplate() method provided by the TemplatedEmail class: +use Symfony\\Bridge\\Twig\\Mime\\TemplatedEmail; $email = (new TemplatedEmail()) // ... ->htmlTemplate('emails/signup.html.twig') + ->textTemplate('emails/signup.txt.twig') // ... ; Embedding Images Instead of dealing with the <img src=\"cid: ...\"> syntax explained in the previous sections, when using Twig to render email contents you can refer to image files as usual. First, to simplify things, define a Twig namespace called images that points to whatever directory your images are stored in: # config/packages/twig.yaml twig: # ... paths: # point this wherever your images live '%kernel.project_dir%/assets/images': images <!-- config/packages/twig.xml --> <container xmlns=\"http://symfony.com/schema/dic/services\"", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_10", "source": "mailer.rst", "text": "method explained in the previous sections or the textTemplate() method provided by the TemplatedEmail class: +use Symfony\\Bridge\\Twig\\Mime\\TemplatedEmail; $email = (new TemplatedEmail()) // ... ->htmlTemplate('emails/signup.html.twig') + ->textTemplate('emails/signup.txt.twig') // ... ; Embedding Images Instead of dealing with the <img src=\"cid: ...\"> syntax explained in the previous sections, when using Twig to render email contents you can refer to image files as usual. First, to simplify things, define a Twig namespace called images that points to whatever directory your images are stored in: # config/packages/twig.yaml twig: # ... paths: # point this wherever your images live '%kernel.project_dir%/assets/images': images <!-- config/packages/twig.xml --> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:twig=\"http://symfony.com/schema/dic/twig\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\"> <twig:config> <!-- ... --> <!-- point this wherever your images live --> <twig:path namespace=\"images\">%kernel.project_dir%/assets/images</twig:path> </twig:config> </container> // config/packages/twig.php use Symfony\\Config\\TwigConfig; return static function (TwigConfig $twig): void { // ... // point this wherever your images live $twig->path('%kernel.project_dir%/assets/images', 'images'); }; Now, use the special email.image() Twig helper to embed the images inside the email contents: {# '@images/' refers to the Twig namespace defined earlier #} <img src=\"{{ email.image('@images/logo.png') }}\" alt=\"Logo\"> <h1>Welcome {{ email.toName }}!</h1> {# ... #} By default this will create an attachment using the file path as file name: Content-Disposition: inline; name=\"cid...\"; filename=\"@images/logo.png\". This behavior can be overridden by passing a custom file name as the third argument: <img src=\"{{ email.image('@images/logo.png', 'image/png', 'logo-acme.png') }}\" alt=\"ACME Logo\"> The third argument of email.image() was introduced in Symfony 7.3. Inlining CSS Styles Designing the HTML contents of an email is very different from designing a normal HTML page. For starters, most email clients only support a subset of all CSS features. In addition, popular email clients like Gmail don't support defining styles inside <style> ... </style> sections and you must **inline all the CSS styles**. CSS inlining means that every HTML tag must define a style attribute with all its CSS styles. This can make organizing your CSS a mess. That's why Twig provides a CssInlinerExtension that automates everything for you. Install it with: $ composer require twig/extra-bundle twig/cssinliner-extra The extension is enabled automatically. To use it, wrap the entire template with the inline_css filter: {% apply inline_css %} <style> {# here, define your CSS styles as usual #} h1 { color: #333; } </style> <h1>Welcome {{ email.toName }}!</h1> {# ... #} {% endapply %} Using External CSS Files ........................ You can also define CSS styles in external files and pass them as arguments to the filter: {% apply inline_css(source('@styles/email.css')) %} <h1>Welcome {{ username }}!</h1> {# ... #} {% endapply %} You can pass unlimited number of arguments to inline_css() to load multiple CSS files. For this example to work, you also need to define a new Twig namespace called styles that points to the directory where email.css lives: # config/packages/twig.yaml twig: # ... paths: # point this wherever your css files live '%kernel.project_dir%/assets/styles': styles <!-- config/packages/twig.xml --> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:twig=\"http://symfony.com/schema/dic/twig\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\"> <twig:config> <!-- ... --> <!-- point this wherever your css files live --> <twig:path namespace=\"styles\">%kernel.project_dir%/assets/styles</twig:path> </twig:config> </container> // config/packages/twig.php use", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_11", "source": "mailer.rst", "text": "filter: {% apply inline_css(source('@styles/email.css')) %} <h1>Welcome {{ username }}!</h1> {# ... #} {% endapply %} You can pass unlimited number of arguments to inline_css() to load multiple CSS files. For this example to work, you also need to define a new Twig namespace called styles that points to the directory where email.css lives: # config/packages/twig.yaml twig: # ... paths: # point this wherever your css files live '%kernel.project_dir%/assets/styles': styles <!-- config/packages/twig.xml --> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:twig=\"http://symfony.com/schema/dic/twig\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\"> <twig:config> <!-- ... --> <!-- point this wherever your css files live --> <twig:path namespace=\"styles\">%kernel.project_dir%/assets/styles</twig:path> </twig:config> </container> // config/packages/twig.php use Symfony\\Config\\TwigConfig; return static function (TwigConfig $twig): void { // ... // point this wherever your css files live $twig->path('%kernel.project_dir%/assets/styles', 'styles'); }; Rendering Markdown Content Twig provides another extension called MarkdownExtension that lets you define the email contents using `Markdown syntax`_. To use this, install the extension and a Markdown conversion library (the extension is compatible with several popular libraries): # instead of league/commonmark, you can also use erusev/parsedown or michelf/php-markdown $ composer require twig/extra-bundle twig/markdown-extra league/commonmark The extension adds a markdown_to_html filter, which you can use to convert parts or the entire email contents from Markdown to HTML: {% apply markdown_to_html %} Welcome {{ email.toName }}! You signed up to our site using the following email: `{{ email.to[0].address }}` [Activate your account]({{ url('...') }}) {% endapply %} Inky Email Templating Language Symfony recommends Inky, but you can also use `MJML`_, a more actively maintained alternative for responsive email templates. Creating beautifully designed emails that work on every email client is so complex that there are HTML/CSS frameworks dedicated to that. One of the most popular frameworks is called `Inky`_. It defines a syntax based on some HTML-like tags which are later transformed into the real HTML code sent to users: <!-- a simplified example of the Inky syntax --> <container> <row> <columns>This is a column.</columns> </row> </container> Twig provides integration with Inky via the InkyExtension. First, install the extension in your application: $ composer require twig/extra-bundle twig/inky-extra The extension adds an inky_to_html filter, which can be used to convert parts or the entire email contents from Inky to HTML: {% apply inky_to_html %} <container> <row class=\"header\"> <columns> <spacer size=\"16\"></spacer> <h1 class=\"text-center\">Welcome {{ email.toName }}!</h1> </columns> {# ... #} </row> </container> {% endapply %} You can combine all filters to create complex email messages: {% apply inky_to_html|inline_css(source('@styles/foundation-emails.css')) %} {# ... #} {% endapply %} This makes use of the styles Twig namespace we created earlier. You could, for example, `download the foundation-emails.css file`_ directly from GitHub and save it in assets/styles. Signing and Encrypting Messages It's possible to sign and/or encrypt email messages to increase their integrity/security. Both options can be combined to encrypt a signed message and/or to sign an encrypted message. Before signing/encrypting messages, make sure to have: * The `OpenSSL PHP extension`_ properly installed and configured; * A valid `S/MIME`_ security certificate. When using OpenSSL to generate certificates, make sure to add the -addtrust emailProtection command option. Signing", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_12", "source": "mailer.rst", "text": "{% endapply %} This makes use of the styles Twig namespace we created earlier. You could, for example, `download the foundation-emails.css file`_ directly from GitHub and save it in assets/styles. Signing and Encrypting Messages It's possible to sign and/or encrypt email messages to increase their integrity/security. Both options can be combined to encrypt a signed message and/or to sign an encrypted message. Before signing/encrypting messages, make sure to have: * The `OpenSSL PHP extension`_ properly installed and configured; * A valid `S/MIME`_ security certificate. When using OpenSSL to generate certificates, make sure to add the -addtrust emailProtection command option. Signing and encrypting messages require their contents to be fully rendered. For example, the content of templated emails is rendered by a Symfony\\\\Component\\\\Mailer\\\\EventListener\\\\MessageListener. So, if you want to sign and/or encrypt such a message, you need to do it in a MessageEvent listener run after it (you need to set a negative priority to your listener). Signing Messages When signing a message, a cryptographic hash is generated for the entire content of the message (including attachments). This hash is added as an attachment so the recipient can validate the integrity of the received message. However, the contents of the original message are still readable for mailing agents not supporting signed messages, so you must also encrypt the message if you want to hide its contents. You can sign messages using either S/MIME or DKIM. In both cases, the certificate and private key must be `PEM encoded`_, and can be either created using for example OpenSSL or obtained at an official Certificate Authority (CA). The email recipient must have the CA certificate in the list of trusted issuers in order to verify the signature. If you use message signature, sending to Bcc will be removed from the message. If you need to send a message to multiple recipients, you need to compute a new signature for each recipient. S/MIME Signer ............. `S/MIME`_ is a standard for public key encryption and signing of MIME data. It requires using both a certificate and a private key:: use Symfony\\Component\\Mime\\Crypto\\SMimeSigner; use Symfony\\Component\\Mime\\Email; $email = (new Email()) ->from('hello@example.com') // ... ->html('...'); $signer = new SMimeSigner('/path/to/certificate.crt', '/path/to/certificate-private-key.key'); // if the private key has a passphrase, pass it as the third argument // new SMimeSigner('/path/to/certificate.crt', '/path/to/certificate-private-key.key', 'the-passphrase'); $signedEmail = $signer->sign($email); // now use the Mailer component to send this $signedEmail instead of the original email The SMimeSigner class defines other optional arguments to pass intermediate certificates and to configure the signing process using a bitwise operator options for openssl_pkcs7_sign PHP function. DKIM Signer ........... `DKIM`_ is an email authentication method that affixes a digital signature, linked to a domain name, to each outgoing email messages. It requires a private key but not a certificate:: use Symfony\\Component\\Mime\\Crypto\\DkimSigner; use Symfony\\Component\\Mime\\Email; $email = (new Email()) ->from('hello@example.com') // ... ->html('...'); // first argument: same as openssl_pkey_get_private(), either a string with the // contents of the private key or the absolute path to it (prefixed with 'file://') // second and third arguments: the domain", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_13", "source": "mailer.rst", "text": "other optional arguments to pass intermediate certificates and to configure the signing process using a bitwise operator options for openssl_pkcs7_sign PHP function. DKIM Signer ........... `DKIM`_ is an email authentication method that affixes a digital signature, linked to a domain name, to each outgoing email messages. It requires a private key but not a certificate:: use Symfony\\Component\\Mime\\Crypto\\DkimSigner; use Symfony\\Component\\Mime\\Email; $email = (new Email()) ->from('hello@example.com') // ... ->html('...'); // first argument: same as openssl_pkey_get_private(), either a string with the // contents of the private key or the absolute path to it (prefixed with 'file://') // second and third arguments: the domain name and \"selector\" used to perform a DNS lookup // (the selector is a string used to point to a specific DKIM public key record in your DNS) $signer = new DkimSigner('file:///path/to/private-key.key', 'example.com', 'sf'); // if the private key has a passphrase, pass it as the fifth argument // new DkimSigner('file:///path/to/private-key.key', 'example.com', 'sf', [], 'the-passphrase'); $signedEmail = $signer->sign($email); // now use the Mailer component to send this $signedEmail instead of the original email // DKIM signer provides many config options and a helper object to configure them use Symfony\\Component\\Mime\\Crypto\\DkimOptions; $signedEmail = $signer->sign($email, (new DkimOptions()) ->bodyCanon('relaxed') ->headerCanon('relaxed') ->headersToIgnore(['Message-ID']) ->toArray() ); Signing Messages Globally ......................... Instead of creating a signer instance for each email, you can configure a global signer that automatically applies to all outgoing messages. This approach minimizes repetition and centralizes your configuration for DKIM and S/MIME signing. # config/packages/mailer.yaml framework: mailer: dkim_signer: key: 'file://%kernel.project_dir%/var/certificates/dkim.pem' domain: 'symfony.com' select: 's1' smime_signer: key: '%kernel.project_dir%/var/certificates/smime.key' certificate: '%kernel.project_dir%/var/certificates/smime.crt' passphrase: '' <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <framework:config> <framework:mailer> <framework:dkim-signer> <framework:key>file://%kernel.project_dir%/var/certificates/dkim.pem</framework:key> <framework:domain>symfony.com</framework:domain> <framework:select>s1</framework:select> </framework:dkim-signer> <framework:smime-signer> <framework:key>%kernel.project_dir%/var/certificates/smime.pem</framework:key> <framework:certificate>%kernel.project_dir%/var/certificates/smime.crt</framework:certificate> <framework:passphrase></framework:passphrase> </framework:smime-signer> </framework:mailer> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $mailer = $framework->mailer(); $mailer->dsn('%env(MAILER_DSN)%'); $mailer->dkimSigner() ->key('file://%kernel.project_dir%/var/certificates/dkim.pem') ->domain('symfony.com') ->select('s1'); $mailer->smimeSigner() ->key('%kernel.project_dir%/var/certificates/smime.key') ->certificate('%kernel.project_dir%/var/certificates/smime.crt') ->passphrase('') ; }; Global message signing was introduced in Symfony 7.3. Encrypting Messages When encrypting a message, the entire message (including attachments) is encrypted using a certificate. Therefore, only the recipients that have the corresponding private key can read the original message contents:: use Symfony\\Component\\Mime\\Crypto\\SMimeEncrypter; use Symfony\\Component\\Mime\\Email; $email = (new Email()) ->from('hello@example.com') // ... ->html('...'); $encrypter = new SMimeEncrypter('/path/to/certificate.crt'); $encryptedEmail = $encrypter->encrypt($email); // now use the Mailer component to send this $encryptedEmail instead of the original email You can pass more than one certificate to the SMimeEncrypter constructor and it will select the appropriate certificate depending on the To option:: $firstEmail = (new Email()) // ... ->to('jane@example.com'); $secondEmail = (new Email()) // ... ->to('john@example.com'); // the second optional argument of SMimeEncrypter defines which encryption algorithm is used // (it must be one of these constants: https://www.php.net/manual/en/openssl.ciphers.php) $encrypter = new SMimeEncrypter([ // key = email recipient; value = path to the certificate file 'jane@example.com' => '/path/to/first-certificate.crt', 'john@example.com' => '/path/to/second-certificate.crt', ]); $firstEncryptedEmail = $encrypter->encrypt($firstEmail); $secondEncryptedEmail = $encrypter->encrypt($secondEmail); Encrypting Messages Globally ............................ Instead of creating a new encrypter for each email, you can configure a global S/MIME encrypter that automatically applies to", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_14", "source": "mailer.rst", "text": "it will select the appropriate certificate depending on the To option:: $firstEmail = (new Email()) // ... ->to('jane@example.com'); $secondEmail = (new Email()) // ... ->to('john@example.com'); // the second optional argument of SMimeEncrypter defines which encryption algorithm is used // (it must be one of these constants: https://www.php.net/manual/en/openssl.ciphers.php) $encrypter = new SMimeEncrypter([ // key = email recipient; value = path to the certificate file 'jane@example.com' => '/path/to/first-certificate.crt', 'john@example.com' => '/path/to/second-certificate.crt', ]); $firstEncryptedEmail = $encrypter->encrypt($firstEmail); $secondEncryptedEmail = $encrypter->encrypt($secondEmail); Encrypting Messages Globally ............................ Instead of creating a new encrypter for each email, you can configure a global S/MIME encrypter that automatically applies to all outgoing messages: # config/packages/mailer.yaml framework: mailer: smime_encrypter: repository: App\\Security\\LocalFileCertificateRepository <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <framework:config> <framework:mailer> <framework:smime-encrypter> <framework:repository>App\\Security\\LocalFileCertificateRepository</framework:repository> </framework:smime-encrypter> </framework:mailer> </framework:config> </container> // config/packages/mailer.php use App\\Security\\LocalFileCertificateRepository; use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $mailer = $framework->mailer(); $mailer->smimeEncrypter() ->repository(LocalFileCertificateRepository::class) ; }; The repository option is the ID of a service that implements Symfony\\\\Component\\\\Mailer\\\\EventListener\\\\SmimeCertificateRepositoryInterface. This interface requires only one method: findCertificatePathFor(), which must return the file path to the certificate associated with the given email address:: namespace App\\Security; use Symfony\\Component\\DependencyInjection\\Attribute\\Autowire; use Symfony\\Component\\Mailer\\EventListener\\SmimeCertificateRepositoryInterface; class LocalFileCertificateRepository implements SmimeCertificateRepositoryInterface { public function __construct( #[Autowire(param: 'kernel.project_dir')] private readonly string $projectDir ){} public function findCertificatePathFor(string $email): ?string { $hash = hash('sha256', strtolower(trim($email))); $path = sprintf('%s/storage/%s.crt', $this->projectDir, $hash); return file_exists($path) ? $path : null; } } Global message encryption configuration was introduced in Symfony 7.3. Multiple Email Transports You may want to use more than one mailer transport for delivery of your messages. This can be configured by replacing the dsn configuration entry with a transports entry, like: # config/packages/mailer.yaml framework: mailer: transports: main: '%env(MAILER_DSN)%' alternative: '%env(MAILER_DSN_IMPORTANT)%' <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <framework:config> <framework:mailer> <framework:transport name=\"main\">%env(MAILER_DSN)%</framework:transport> <framework:transport name=\"alternative\">%env(MAILER_DSN_IMPORTANT)%</framework:transport> </framework:mailer> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env; return static function (FrameworkConfig $framework): void { $framework->mailer() ->transport('main', env('MAILER_DSN')) ->transport('alternative', env('MAILER_DSN_IMPORTANT')) ; }; By default the first transport is used. The other transports can be selected by adding an X-Transport header (which Mailer will remove automatically from the final email):: // Send using first transport (\"main\"): $mailer->send($email); // ... or use the transport \"alternative\": $email->getHeaders()->addTextHeader('X-Transport', 'alternative'); $mailer->send($email); Sending Messages Async When you call $mailer->send($email), the email is sent to the transport immediately. To improve performance, you can leverage Messenger to send the messages later via a Messenger transport. Start by following the Messenger documentation and configuring a transport. Once everything is set up, when you call $mailer->send(), a Symfony\\\\Component\\\\Mailer\\\\Messenger\\\\SendEmailMessage message will be dispatched through the default message bus (messenger.default_bus). Assuming you have a transport called async, you can route the message there: # config/packages/messenger.yaml framework: messenger: transports: async: \"%env(MESSENGER_TRANSPORT_DSN)%\" routing: 'Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage': async <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport> <framework:routing message-class=\"Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage\"> <framework:sender service=\"async\"/> </framework:routing> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void {", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_15", "source": "mailer.rst", "text": "send the messages later via a Messenger transport. Start by following the Messenger documentation and configuring a transport. Once everything is set up, when you call $mailer->send(), a Symfony\\\\Component\\\\Mailer\\\\Messenger\\\\SendEmailMessage message will be dispatched through the default message bus (messenger.default_bus). Assuming you have a transport called async, you can route the message there: # config/packages/messenger.yaml framework: messenger: transports: async: \"%env(MESSENGER_TRANSPORT_DSN)%\" routing: 'Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage': async <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport> <framework:routing message-class=\"Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage\"> <framework:sender service=\"async\"/> </framework:routing> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->messenger() ->transport('async')->dsn(env('MESSENGER_TRANSPORT_DSN')); $framework->messenger() ->routing('Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage') ->senders(['async']); }; Thanks to this, instead of being delivered immediately, messages will be sent to the transport to be handled later (see messenger-worker). Note that the \"rendering\" of the email (computed headers, body rendering, ...) is also deferred and will only happen just before the email is sent by the Messenger handler. When sending an email asynchronously, its instance must be serializable. This is always the case for Symfony\\\\Component\\\\Mailer\\\\Mailer instances, but when sending a Symfony\\\\Bridge\\\\Twig\\\\Mime\\\\TemplatedEmail, you must ensure that the context is serializable. If you have non-serializable variables, like Doctrine entities, either replace them with more specific variables or render the email before calling $mailer->send($email):: use Symfony\\Component\\Mailer\\MailerInterface; use Symfony\\Component\\Mime\\BodyRendererInterface; public function action(MailerInterface $mailer, BodyRendererInterface $bodyRenderer): void { $email = (new TemplatedEmail()) ->htmlTemplate($template) ->context($context) ; $bodyRenderer->render($email); $mailer->send($email); } You can configure which bus is used to dispatch the message using the message_bus option. You can also set this to false to call the Mailer transport directly and disable asynchronous delivery. # config/packages/mailer.yaml framework: mailer: message_bus: app.another_bus <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:mailer message_bus=\"app.another_bus\" > </framework:mailer> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->mailer() ->messageBus('app.another_bus'); }; In cases of long-running scripts, and when Mailer uses the Symfony\\\\Component\\\\Mailer\\\\Transport\\\\Smtp\\\\SmtpTransport you may manually disconnect from the SMTP server to avoid keeping an open connection to the SMTP server in between sending emails. You can do so by using the stop() method. You can also select the transport by adding an X-Bus-Transport header (which will be removed automatically from the final message):: // Use the bus transport \"app.another_bus\": $email->getHeaders()->addTextHeader('X-Bus-Transport', 'app.another_bus'); $mailer->send($email); Adding Tags and Metadata to Emails Certain 3rd party transports support email *tags* and *metadata*, which can be used for grouping, tracking and workflows. You can add those by using the Symfony\\\\Component\\\\Mailer\\\\Header\\\\TagHeader and Symfony\\\\Component\\\\Mailer\\\\Header\\\\MetadataHeader classes. If your transport supports headers, it will convert them to their appropriate format:: use Symfony\\Component\\Mailer\\Header\\MetadataHeader; use Symfony\\Component\\Mailer\\Header\\TagHeader; $email->getHeaders()->add(new TagHeader('password-reset')); $email->getHeaders()->add(new MetadataHeader('Color', 'blue')); $email->getHeaders()->add(new MetadataHeader('Client-ID', '12345')); If your transport does not support tags and metadata, they will be added as custom headers: X-Tag: password-reset X-Metadata-Color: blue X-Metadata-Client-ID: 12345 The following transports currently support tags and metadata: * Brevo * Mailgun * Mailtrap * Mandrill * Postmark * Sendgrid The following transports only support tags: * MailPace * Resend The following transports only support metadata: * Amazon SES (note that Amazon", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_16", "source": "mailer.rst", "text": "You can add those by using the Symfony\\\\Component\\\\Mailer\\\\Header\\\\TagHeader and Symfony\\\\Component\\\\Mailer\\\\Header\\\\MetadataHeader classes. If your transport supports headers, it will convert them to their appropriate format:: use Symfony\\Component\\Mailer\\Header\\MetadataHeader; use Symfony\\Component\\Mailer\\Header\\TagHeader; $email->getHeaders()->add(new TagHeader('password-reset')); $email->getHeaders()->add(new MetadataHeader('Color', 'blue')); $email->getHeaders()->add(new MetadataHeader('Client-ID', '12345')); If your transport does not support tags and metadata, they will be added as custom headers: X-Tag: password-reset X-Metadata-Color: blue X-Metadata-Client-ID: 12345 The following transports currently support tags and metadata: * Brevo * Mailgun * Mailtrap * Mandrill * Postmark * Sendgrid The following transports only support tags: * MailPace * Resend The following transports only support metadata: * Amazon SES (note that Amazon refers to this feature as \"tags\", but Symfony calls it \"metadata\" because it contains a key and a value) Draft Emails Symfony\\\\Component\\\\Mime\\\\DraftEmail is a special instance of Symfony\\\\Component\\\\Mime\\\\Email. Its purpose is to build up an email (with body, attachments, etc) and make available to download as an .eml with the X-Unsent header. Many email clients can open these files and interpret them as *draft emails*. You can use these to create advanced mailto: links. Here's an example of making one available to download:: // src/Controller/DownloadEmailController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\HttpFoundation\\ResponseHeaderBag; use Symfony\\Component\\Mime\\DraftEmail; use Symfony\\Component\\Routing\\Attribute\\Route; class DownloadEmailController extends AbstractController { #[Route('/download-email')] public function __invoke(): Response { $message = (new DraftEmail()) ->html($this->renderView(/* ... */)) ->addPart(/* ... */) ; $response = new Response($message->toString()); $contentDisposition = $response->headers->makeDisposition( ResponseHeaderBag::DISPOSITION_ATTACHMENT, 'download.eml' ); $response->headers->set('Content-Type', 'message/rfc822'); $response->headers->set('Content-Disposition', $contentDisposition); return $response; } } As it's possible for Symfony\\\\Component\\\\Mime\\\\DraftEmail's to be created without a To/From they cannot be sent with the mailer. Mailer Events MessageEvent **Event Class**: Symfony\\\\Component\\\\Mailer\\\\Event\\\\MessageEvent MessageEvent allows to change the Mailer message and the envelope before the email is sent:: use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\Mailer\\Event\\MessageEvent; use Symfony\\Component\\Mime\\Email; public function onMessage(MessageEvent $event): void { $message = $event->getMessage(); if (!$message instanceof Email) { return; } // do something with the message (logging, ...) // and/or add some Messenger stamps $event->addStamp(new SomeMessengerStamp()); } If you want to stop the Message from being sent, call reject() (it will also stop the event propagation):: use Symfony\\Component\\Mailer\\Event\\MessageEvent; public function onMessage(MessageEvent $event): void { $event->reject(); } Execute this command to find out which listeners are registered for this event and their priorities: $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\MessageEvent\" SentMessageEvent **Event Class**: Symfony\\\\Component\\\\Mailer\\\\Event\\\\SentMessageEvent SentMessageEvent allows you to act on the Symfony\\\\Component\\\\Mailer\\\\SentMessage class to access the original message (getOriginalMessage()) and some debugging information (getDebug()) such as the HTTP calls made by the HTTP transports, which is useful for debugging errors:: use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\Mailer\\Event\\SentMessageEvent; public function onMessage(SentMessageEvent $event): void { $message = $event->getMessage(); // do something with the message (e.g. get its id) } Execute this command to find out which listeners are registered for this event and their priorities: $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\SentMessageEvent\" FailedMessageEvent **Event Class**: Symfony\\\\Component\\\\Mailer\\\\Event\\\\FailedMessageEvent FailedMessageEvent allows acting on the initial message in case of a failure and some debugging information (getDebug()) such as the HTTP calls made by the HTTP transports, which is useful for debugging errors:: use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\Mailer\\Event\\FailedMessageEvent; use Symfony\\Component\\Mailer\\Exception\\TransportExceptionInterface; public function onMessage(FailedMessageEvent $event): void { //", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_17", "source": "mailer.rst", "text": "is useful for debugging errors:: use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\Mailer\\Event\\SentMessageEvent; public function onMessage(SentMessageEvent $event): void { $message = $event->getMessage(); // do something with the message (e.g. get its id) } Execute this command to find out which listeners are registered for this event and their priorities: $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\SentMessageEvent\" FailedMessageEvent **Event Class**: Symfony\\\\Component\\\\Mailer\\\\Event\\\\FailedMessageEvent FailedMessageEvent allows acting on the initial message in case of a failure and some debugging information (getDebug()) such as the HTTP calls made by the HTTP transports, which is useful for debugging errors:: use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\Mailer\\Event\\FailedMessageEvent; use Symfony\\Component\\Mailer\\Exception\\TransportExceptionInterface; public function onMessage(FailedMessageEvent $event): void { // e.g you can get more information on this error when sending an email $error = $event->getError(); if ($error instanceof TransportExceptionInterface) { $error->getDebug(); } // do something with the message } Execute this command to find out which listeners are registered for this event and their priorities: $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\FailedMessageEvent\" Development & Debugging Enabling an Email Catcher When developing locally, it is recommended to use an email catcher. If you have enabled Docker support via Symfony recipes, an email catcher is automatically configured. In addition, if you are using the Symfony CLI tool, the mailer DSN is automatically exposed via the symfony binary Docker integration . Sending Test Emails Symfony provides a command to send emails, which is useful during development to test if sending emails works correctly: # the only mandatory argument is the recipient address # (check the command help to learn about its options) $ php bin/console mailer:test someone@example.com This command bypasses the Messenger bus , if configured, to ease testing emails even when the Messenger consumer is not running. Disabling Delivery While developing (or testing), you may want to disable delivery of messages entirely. You can do this by using null://null as the mailer DSN, either in your .env configuration files or in the mailer configuration file (e.g. in the dev or test environments): # config/packages/mailer.yaml when@dev: framework: mailer: dsn: 'null://null' <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <framework:config> <framework:mailer dsn=\"null://null\"/> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { // ... $framework->mailer() ->dsn('null://null'); }; If you're using Messenger and routing to a transport, the message will *still* be sent to that transport. Always Send to the same Address Instead of disabling delivery entirely, you might want to *always* send emails to a specific address, instead of the *real* address: # config/packages/mailer.yaml when@dev: framework: mailer: envelope: recipients: ['youremail@example.com'] <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <framework:config> <framework:mailer> <framework:envelope> <framework:recipient>youremail@example.com</framework:recipient> </framework:envelope> </framework:mailer> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { // ... $framework->mailer() ->envelope() ->recipients(['youremail@example.com']) ; }; Use the allowed_recipients option to define specific addresses that should still receive their original emails. These messages will also be sent to the address(es) defined in recipients, as with all other emails: # config/packages/mailer.yaml when@dev: framework: mailer: envelope:", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "mailer.rst_fixed_18", "source": "mailer.rst", "text": "emails to a specific address, instead of the *real* address: # config/packages/mailer.yaml when@dev: framework: mailer: envelope: recipients: ['youremail@example.com'] <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <framework:config> <framework:mailer> <framework:envelope> <framework:recipient>youremail@example.com</framework:recipient> </framework:envelope> </framework:mailer> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { // ... $framework->mailer() ->envelope() ->recipients(['youremail@example.com']) ; }; Use the allowed_recipients option to define specific addresses that should still receive their original emails. These messages will also be sent to the address(es) defined in recipients, as with all other emails: # config/packages/mailer.yaml when@dev: framework: mailer: envelope: recipients: ['youremail@example.com'] allowed_recipients: - 'internal@example.com' # you can also use regular expression to define allowed recipients - 'internal-.*@example.(com|fr)' <!-- config/packages/mailer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <!-- ... --> <framework:config> <framework:mailer> <framework:envelope> <framework:recipient>youremail@example.com</framework:recipient> <framework:allowed-recipient>internal@example.com</framework:allowed-recipient> <!-- you can also use regular expression to define allowed recipients --> <framework:allowed-recipient>internal-.*@example.(com|fr)</framework:allowed-recipient> </framework:envelope> </framework:mailer> </framework:config> </container> // config/packages/mailer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { // ... $framework->mailer() ->envelope() ->recipients(['youremail@example.com']) ->allowedRecipients([ 'internal@example.com', // you can also use regular expression to define allowed recipients 'internal-.*@example.(com|fr)', ]) ; }; With this configuration, all emails will be sent to youremail@example.com. Additionally, emails sent to internal@example.com, internal-monitoring@example.fr, etc., will also be delivered to those addresses. The allowed_recipients option was introduced in Symfony 7.1. Write a Functional Test Symfony provides lots of built-in mailer assertions to functionally test that an email was sent, its contents or headers, etc. They are available in test classes extending Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\KernelTestCase or when using the Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\MailerAssertionsTrait:: // tests/Controller/MailControllerTest.php namespace App\\Tests\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase; class MailControllerTest extends WebTestCase { public function testMailIsSentAndContentIsOk(): void { $client = static::createClient(); $client->request('GET', '/mail/send'); $this->assertResponseIsSuccessful(); $this->assertEmailCount(1); // use assertQueuedEmailCount() when using Messenger $email = $this->getMailerMessage(); $this->assertEmailHtmlBodyContains($email, 'Welcome'); $this->assertEmailTextBodyContains($email, 'Welcome'); } } If your controller returns a redirect response after sending the email, make sure to have your client *not* follow redirects. The kernel is rebooted after following the redirection and the message will be lost from the mailer event handler.", "title": "Sending Emails with Mailer", "category": "mailer"}
{"chunk_id": "messenger.rst_fixed_0", "source": "messenger.rst", "text": "Messenger: Sync & Queued Message Handling Messenger provides a message bus with the ability to send messages and then handle them immediately in your application or send them through transports (e.g. queues) to be handled later. To learn more about it, read the Messenger component docs . Installation In applications using Symfony Flex , run this command to install messenger: $ composer require symfony/messenger Creating a Message & Handler Messenger centers around two different classes that you'll create: (1) a message class that holds data and (2) a handler(s) class that will be called when that message is dispatched. The handler class will read the message class and perform one or more tasks. There are no specific requirements for a message class, except that it can be serialized:: // src/Message/SmsNotification.php namespace App\\Message; class SmsNotification { public function __construct( private string $content, ) { } public function getContent(): string { return $this->content; } } A message handler is a PHP callable, the recommended way to create it is to create a class that has the Symfony\\\\Component\\\\Messenger\\\\Attribute\\\\AsMessageHandler attribute and has an __invoke() method that's type-hinted with the message class (or a message interface):: // src/MessageHandler/SmsNotificationHandler.php namespace App\\MessageHandler; use App\\Message\\SmsNotification; use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler; #[AsMessageHandler] class SmsNotificationHandler { public function __invoke(SmsNotification $message) { // ... do some work - like sending an SMS message! } } You can also use the #[AsMessageHandler] attribute on individual class methods. You may use the attribute on as many methods in a single class as you like, allowing you to group the handling of multiple related types of messages. Thanks to autoconfiguration and the SmsNotification type-hint, Symfony knows that this handler should be called when an SmsNotification message is dispatched. Most of the time, this is all you need to do. But you can also manually configure message handlers . To see all the configured handlers, run: $ php bin/console debug:messenger Dispatching the Message You're ready! To dispatch the message (and call the handler), inject the messenger.default_bus service (via the MessageBusInterface), like in a controller:: // src/Controller/DefaultController.php namespace App\\Controller; use App\\Message\\SmsNotification; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Messenger\\MessageBusInterface; class DefaultController extends AbstractController { public function index(MessageBusInterface $bus): Response { // will cause the SmsNotificationHandler to be called $bus->dispatch(new SmsNotification('Look! I created a message!')); // ... } } Transports: Async/Queued Messages By default, messages are handled as soon as they are dispatched. If you want to handle a message asynchronously, you can configure a transport. A transport is capable of sending messages (e.g. to a queueing system) and then receiving them via a worker . Messenger supports multiple transports . If you want to use a transport that's not supported, check out the `Enqueue's transport`_, which backs services like Kafka and Google Pub/Sub. A transport is registered using a \"DSN\". Thanks to Messenger's Flex recipe, your .env file already has a few examples. # MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages # MESSENGER_TRANSPORT_DSN=doctrine://default # MESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages Uncomment whichever transport you want (or set it in .env.local). See messenger-transports-config for more details. Next, in config/packages/messenger.yaml, let's define a transport", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_1", "source": "messenger.rst", "text": "can configure a transport. A transport is capable of sending messages (e.g. to a queueing system) and then receiving them via a worker . Messenger supports multiple transports . If you want to use a transport that's not supported, check out the `Enqueue's transport`_, which backs services like Kafka and Google Pub/Sub. A transport is registered using a \"DSN\". Thanks to Messenger's Flex recipe, your .env file already has a few examples. # MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages # MESSENGER_TRANSPORT_DSN=doctrine://default # MESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages Uncomment whichever transport you want (or set it in .env.local). See messenger-transports-config for more details. Next, in config/packages/messenger.yaml, let's define a transport called async that uses this configuration: # config/packages/messenger.yaml framework: messenger: transports: async: \"%env(MESSENGER_TRANSPORT_DSN)%\" # or expanded to configure more options #async: # dsn: \"%env(MESSENGER_TRANSPORT_DSN)%\" # options: [] <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport> <!-- or expanded to configure more options --> <framework:transport name=\"async\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\" > <option key=\"...\">...</option> </framework:transport> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->messenger() ->transport('async') ->dsn(env('MESSENGER_TRANSPORT_DSN')) ; $framework->messenger() ->transport('async') ->dsn(env('MESSENGER_TRANSPORT_DSN')) ->options([]) ; }; Routing Messages to a Transport Now that you have a transport configured, instead of handling a message immediately, you can configure them to be sent to a transport: // src/Message/SmsNotification.php namespace App\\Message; use Symfony\\Component\\Messenger\\Attribute\\AsMessage; #[AsMessage('async')] class SmsNotification { // ... } # config/packages/messenger.yaml framework: messenger: transports: async: \"%env(MESSENGER_TRANSPORT_DSN)%\" routing: # async is whatever name you gave your transport above 'App\\Message\\SmsNotification': async <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:routing message-class=\"App\\Message\\SmsNotification\"> <!-- async is whatever name you gave your transport above --> <framework:sender service=\"async\"/> </framework:routing> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->messenger() // async is whatever name you gave your transport above ->routing('App\\Message\\SmsNotification')->senders(['async']) ; }; The #[AsMessage] attribute was introduced in Symfony 7.2. Thanks to this, the App\\Message\\SmsNotification will be sent to the async transport and its handler(s) will *not* be called immediately. Any messages not matched under routing will still be handled immediately, i.e. synchronously. If you configure routing with both YAML/XML/PHP configuration files and PHP attributes, the configuration always takes precedence over the class attribute. This behavior allows you to override routing on a per-environment basis. When configuring the routing in separate YAML/XML/PHP files, you can use a partial PHP namespace like 'App\\Message\\*' to match all the messages within the matching namespace. The only requirement is that the '*' wildcard has to be placed at the end of the namespace. You may use '*' as the message class. This will act as a default routing rule for any message not matched under routing. This is useful to ensure no message is handled synchronously by default. The only drawback is that '*' will also apply to the emails sent with the Symfony Mailer (which uses SendEmailMessage when Messenger is available). This could cause issues if your emails are not serializable (e.g. if they include file attachments as", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_2", "source": "messenger.rst", "text": "the messages within the matching namespace. The only requirement is that the '*' wildcard has to be placed at the end of the namespace. You may use '*' as the message class. This will act as a default routing rule for any message not matched under routing. This is useful to ensure no message is handled synchronously by default. The only drawback is that '*' will also apply to the emails sent with the Symfony Mailer (which uses SendEmailMessage when Messenger is available). This could cause issues if your emails are not serializable (e.g. if they include file attachments as PHP resources/streams). You can also route classes by their parent class or interface. Or send messages to multiple transports: // src/Message/SmsNotification.php namespace App\\Message; use Symfony\\Component\\Messenger\\Attribute\\AsMessage; #[AsMessage(['async', 'audit'])] class SmsNotification { // ... } // if you prefer, you can also apply multiple attributes to the message class #[AsMessage('async')] #[AsMessage('audit')] class SmsNotification { // ... } # config/packages/messenger.yaml framework: messenger: routing: # route all messages that extend this example base class or interface 'App\\Message\\AbstractAsyncMessage': async 'App\\Message\\AsyncMessageInterface': async 'My\\Message\\ToBeSentToTwoSenders': [async, audit] <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <!-- route all messages that extend this example base class or interface --> <framework:routing message-class=\"App\\Message\\AbstractAsyncMessage\"> <framework:sender service=\"async\"/> </framework:routing> <framework:routing message-class=\"App\\Message\\AsyncMessageInterface\"> <framework:sender service=\"async\"/> </framework:routing> <framework:routing message-class=\"My\\Message\\ToBeSentToTwoSenders\"> <framework:sender service=\"async\"/> <framework:sender service=\"audit\"/> </framework:routing> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); // route all messages that extend this example base class or interface $messenger->routing('App\\Message\\AbstractAsyncMessage')->senders(['async']); $messenger->routing('App\\Message\\AsyncMessageInterface')->senders(['async']); $messenger->routing('My\\Message\\ToBeSentToTwoSenders')->senders(['async', 'audit']); }; If you configure routing for both a child and parent class, both rules are used. E.g. if you have an SmsNotification object that extends from Notification, both the routing for Notification and SmsNotification will be used. You can define and override the transport that a message is using at runtime by using the Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\TransportNamesStamp on the envelope of the message. This stamp takes an array of transport name as its only argument. For more information about stamps, see `Envelopes & Stamps`_. Doctrine Entities in Messages If you need to pass a Doctrine entity in a message, it's better to pass the entity's primary key (or whatever relevant information the handler actually needs, like email, etc.) instead of the object (otherwise you might see errors related to the Entity Manager):: // src/Message/NewUserWelcomeEmail.php namespace App\\Message; class NewUserWelcomeEmail { public function __construct( private int $userId, ) { } public function getUserId(): int { return $this->userId; } } Then, in your handler, you can query for a fresh object:: // src/MessageHandler/NewUserWelcomeEmailHandler.php namespace App\\MessageHandler; use App\\Message\\NewUserWelcomeEmail; use App\\Repository\\UserRepository; use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler; #[AsMessageHandler] class NewUserWelcomeEmailHandler { public function __construct( private UserRepository $userRepository, ) { } public function __invoke(NewUserWelcomeEmail $welcomeEmail): void { $user = $this->userRepository->find($welcomeEmail->getUserId()); // ... send an email! } } This guarantees the entity contains fresh data. Handling Messages Synchronously If a message doesn't match any routing rules , it won't be sent to any transport and will be handled immediately. In some cases (like when", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_3", "source": "messenger.rst", "text": "int $userId, ) { } public function getUserId(): int { return $this->userId; } } Then, in your handler, you can query for a fresh object:: // src/MessageHandler/NewUserWelcomeEmailHandler.php namespace App\\MessageHandler; use App\\Message\\NewUserWelcomeEmail; use App\\Repository\\UserRepository; use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler; #[AsMessageHandler] class NewUserWelcomeEmailHandler { public function __construct( private UserRepository $userRepository, ) { } public function __invoke(NewUserWelcomeEmail $welcomeEmail): void { $user = $this->userRepository->find($welcomeEmail->getUserId()); // ... send an email! } } This guarantees the entity contains fresh data. Handling Messages Synchronously If a message doesn't match any routing rules , it won't be sent to any transport and will be handled immediately. In some cases (like when `binding handlers to different transports`_), it's easier or more flexible to handle this explicitly: by creating a sync transport and \"sending\" messages there to be handled immediately: # config/packages/messenger.yaml framework: messenger: transports: # ... other transports sync: 'sync://' routing: App\\Message\\SmsNotification: sync <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <!-- ... other transports --> <framework:transport name=\"sync\" dsn=\"sync://\"/> <framework:routing message-class=\"App\\Message\\SmsNotification\"> <framework:sender service=\"sync\"/> </framework:routing> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); // ... other transports $messenger->transport('sync')->dsn('sync://'); $messenger->routing('App\\Message\\SmsNotification')->senders(['sync']); }; Creating your Own Transport You can also create your own transport if you need to send or receive messages from something that is not supported. See /messenger/custom-transport. Consuming Messages (Running the Worker) Once your messages have been routed, in most cases, you'll need to \"consume\" them. You can do this with the messenger:consume command: $ php bin/console messenger:consume async # use -vv to see details about what's happening $ php bin/console messenger:consume async -vv The first argument is the receiver's name (or service id if you routed to a custom service). By default, the command will run forever: looking for new messages on your transport and handling them. This command is called your \"worker\". If you want to consume messages from all available receivers, you can use the command with the --all option: $ php bin/console messenger:consume --all The --all option was introduced in Symfony 7.1. Messages that take a long time to process may be redelivered prematurely because some transports assume that an unacknowledged message is lost. To prevent this issue, use the --keepalive command option to specify an interval (in seconds; default value = 5) at which the message is marked as \"in progress\". This prevents the message from being redelivered until the worker completes processing it: $ php bin/console messenger:consume --keepalive This option is only available for the following transports: Beanstalkd, AmazonSQS, Doctrine and Redis. The --keepalive option was introduced in Symfony 7.2. In a development environment and if you're using the Symfony CLI tool, you can configure workers to be automatically run along with the webserver. You can find more information in the Symfony CLI Workers documentation. To properly stop a worker, throw an instance of Symfony\\\\Component\\\\Messenger\\\\Exception\\\\StopWorkerException. Deploying to Production On production, there are a few important things to think about: **Use a Process Manager like Supervisor or systemd to keep", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_4", "source": "messenger.rst", "text": "worker completes processing it: $ php bin/console messenger:consume --keepalive This option is only available for the following transports: Beanstalkd, AmazonSQS, Doctrine and Redis. The --keepalive option was introduced in Symfony 7.2. In a development environment and if you're using the Symfony CLI tool, you can configure workers to be automatically run along with the webserver. You can find more information in the Symfony CLI Workers documentation. To properly stop a worker, throw an instance of Symfony\\\\Component\\\\Messenger\\\\Exception\\\\StopWorkerException. Deploying to Production On production, there are a few important things to think about: **Use a Process Manager like Supervisor or systemd to keep your worker(s) running** You'll want one or more \"workers\" running at all times. To do that, use a process control system like Supervisor or systemd . **Don't Let Workers Run Forever** Some services (like Doctrine's EntityManager) will consume more memory over time. So, instead of allowing your worker to run forever, use a flag like messenger:consume --limit=10 to tell your worker to only handle 10 messages before exiting (then the process manager will create a new process). There are also other options like --memory-limit=128M and --time-limit=3600. **Stopping Workers That Encounter Errors** If a worker dependency like your database server is down, or timeout is reached, you can try to add reconnect logic , or just quit the worker if it receives too many errors with the --failure-limit option of the messenger:consume command. **Restart Workers on Deploy** Each time you deploy, you'll need to restart all your worker processes so that they see the newly deployed code. To do this, run messenger:stop-workers on deployment. This will signal to each worker that it should finish the message it's currently handling and should shut down gracefully. Then, the process manager will create new worker processes. The command uses the app cache internally - so make sure this is configured to use an adapter you like. **Use the Same Cache Between Deploys** If your deploy strategy involves the creation of new target directories, you should set a value for the cache.prefix_seed configuration option in order to use the same cache namespace between deployments. Otherwise, the cache.app pool will use the value of the kernel.project_dir parameter as base for the namespace, which will lead to different namespaces each time a new deployment is made. Prioritized Transports Sometimes certain types of messages should have a higher priority and be handled before others. To make this possible, you can create multiple transports and route different messages to them. For example: # config/packages/messenger.yaml framework: messenger: transports: async_priority_high: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: # queue_name is specific to the doctrine transport queue_name: high # for AMQP send to a separate exchange then queue #exchange: # name: high #queues: # messages_high: ~ # for redis try \"group\" async_priority_low: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: queue_name: low routing: 'App\\Message\\SmsNotification': async_priority_low 'App\\Message\\NewUserWelcomeEmail': async_priority_high <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\"> <framework:options> <framework:queue> <framework:name>Queue</framework:name> </framework:queue> </framework:options> </framework:transport> <framework:transport name=\"async_priority_low\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\"> <option key=\"queue_name\">low</option> </framework:transport> <framework:routing message-class=\"App\\Message\\SmsNotification\">", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_5", "source": "messenger.rst", "text": "you can create multiple transports and route different messages to them. For example: # config/packages/messenger.yaml framework: messenger: transports: async_priority_high: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: # queue_name is specific to the doctrine transport queue_name: high # for AMQP send to a separate exchange then queue #exchange: # name: high #queues: # messages_high: ~ # for redis try \"group\" async_priority_low: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: queue_name: low routing: 'App\\Message\\SmsNotification': async_priority_low 'App\\Message\\NewUserWelcomeEmail': async_priority_high <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\"> <framework:options> <framework:queue> <framework:name>Queue</framework:name> </framework:queue> </framework:options> </framework:transport> <framework:transport name=\"async_priority_low\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\"> <option key=\"queue_name\">low</option> </framework:transport> <framework:routing message-class=\"App\\Message\\SmsNotification\"> <framework:sender service=\"async_priority_low\"/> </framework:routing> <framework:routing message-class=\"App\\Message\\NewUserWelcomeEmail\"> <framework:sender service=\"async_priority_high\"/> </framework:routing> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $messenger->transport('async_priority_high') ->dsn(env('MESSENGER_TRANSPORT_DSN')) ->options(['queue_name' => 'high']); $messenger->transport('async_priority_low') ->dsn(env('MESSENGER_TRANSPORT_DSN')) ->options(['queue_name' => 'low']); $messenger->routing('App\\Message\\SmsNotification')->senders(['async_priority_low']); $messenger->routing('App\\Message\\NewUserWelcomeEmail')->senders(['async_priority_high']); }; You can then run individual workers for each transport or instruct one worker to handle messages in a priority order: $ php bin/console messenger:consume async_priority_high async_priority_low The worker will always first look for messages waiting on async_priority_high. If there are none, *then* it will consume messages from async_priority_low. Limit Consuming to Specific Queues Some transports (notably AMQP) have the concept of exchanges and queues. A Symfony transport is always bound to an exchange. By default, the worker consumes from all queues attached to the exchange of the specified transport. However, there are use cases to want a worker to only consume from specific queues. You can limit the worker to only process messages from specific queue(s): $ php bin/console messenger:consume my_transport --queues=fasttrack # you can pass the --queues option more than once to process multiple queues $ php bin/console messenger:consume my_transport --queues=fasttrack1 --queues=fasttrack2 To allow using the queues option, the receiver must implement the Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Receiver\\\\QueueReceiverInterface. Checking the Number of Queued Messages Per Transport Run the messenger:stats command to know how many messages are in the \"queues\" of some or all transports: # displays the number of queued messages in all transports $ php bin/console messenger:stats # shows stats only for some transports $ php bin/console messenger:stats my_transport_name other_transport_name # you can also output the stats in JSON format $ php bin/console messenger:stats --format=json $ php bin/console messenger:stats my_transport_name other_transport_name --format=json The format option was introduced in Symfony 7.2. In order for this command to work, the configured transport's receiver must implement Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Receiver\\\\MessageCountAwareInterface. Supervisor Configuration Supervisor is a great tool to guarantee that your worker process(es) is *always* running (even if it closes due to failure, hitting a message limit or thanks to messenger:stop-workers). You can install it on Ubuntu, for example, via: $ sudo apt-get install supervisor Supervisor configuration files typically live in a /etc/supervisor/conf.d directory. For example, you can create a new messenger-worker.conf file there to make sure that 2 instances of messenger:consume are running at all times: ;/etc/supervisor/conf.d/messenger-worker.conf [program:messenger-consume] command=php /path/to/your/app/bin/console messenger:consume async --time-limit=3600 user=ubuntu numprocs=2 startsecs=0 autostart=true autorestart=true startretries=10 process_name=%(program_name)s_%(process_num)02d Change the async argument to use the name of your transport (or transports) and user to the Unix user", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_6", "source": "messenger.rst", "text": "your worker process(es) is *always* running (even if it closes due to failure, hitting a message limit or thanks to messenger:stop-workers). You can install it on Ubuntu, for example, via: $ sudo apt-get install supervisor Supervisor configuration files typically live in a /etc/supervisor/conf.d directory. For example, you can create a new messenger-worker.conf file there to make sure that 2 instances of messenger:consume are running at all times: ;/etc/supervisor/conf.d/messenger-worker.conf [program:messenger-consume] command=php /path/to/your/app/bin/console messenger:consume async --time-limit=3600 user=ubuntu numprocs=2 startsecs=0 autostart=true autorestart=true startretries=10 process_name=%(program_name)s_%(process_num)02d Change the async argument to use the name of your transport (or transports) and user to the Unix user on your server. During a deployment, something might be unavailable (e.g. the database) causing the consumer to fail to start. In this situation, Supervisor will try startretries number of times to restart the command. Make sure to change this setting to avoid getting the command in a FATAL state, which will never restart again. Each restart, Supervisor increases the delay by 1 second. For instance, if the value is 10, it will wait 1 sec, 2 sec, 3 sec, etc. This gives the service a total of 55 seconds to become available again. Increase the startretries setting to cover the maximum expected downtime. If you use the Redis Transport, note that each worker needs a unique consumer name to avoid the same message being handled by multiple workers. One way to achieve this is to set an environment variable in the Supervisor configuration file, which you can then refer to in messenger.yaml (see the Redis section below): environment=MESSENGER_CONSUMER_NAME=%(program_name)s_%(process_num)02d Next, tell Supervisor to read your config and start your workers: $ sudo supervisorctl reread $ sudo supervisorctl update $ sudo supervisorctl start messenger-consume:* # If you deploy an update of your code, don't forget to restart your workers # to run the new code $ sudo supervisorctl restart messenger-consume:* See the `Supervisor docs`_ for more details. Graceful Shutdown ................. If you install the `PCNTL`_ PHP extension in your project, workers will handle the SIGTERM or SIGINT POSIX signals to finish processing their current message before terminating. However, you might prefer to use different POSIX signals for graceful shutdown. You can override default ones by setting the framework.messenger.stop_worker_on_signals configuration option: # config/packages/messenger.yaml framework: messenger: stop_worker_on_signals: - SIGTERM - SIGINT - SIGUSR1 <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <!-- ... --> <framework:stop-worker-on-signal>SIGTERM</framework:stop-worker-on-signal> <framework:stop-worker-on-signal>SIGINT</framework:stop-worker-on-signal> <framework:stop-worker-on-signal>SIGUSR1</framework:stop-worker-on-signal> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->messenger() ->stopWorkerOnSignals(['SIGTERM', 'SIGINT', 'SIGUSR1']); }; Support for signals plain names in configuration was introduced in Symfony 7.3. Previously, you had to use the numeric values of signals as defined by the pcntl extension's `predefined constants`_. In some cases the SIGTERM signal is sent by Supervisor itself (e.g. stopping a Docker container having Supervisor as its entrypoint). In these cases you need to add a stopwaitsecs key to the program configuration (with a value of the desired grace period in seconds) in order to perform", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_7", "source": "messenger.rst", "text": "<framework:stop-worker-on-signal>SIGINT</framework:stop-worker-on-signal> <framework:stop-worker-on-signal>SIGUSR1</framework:stop-worker-on-signal> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->messenger() ->stopWorkerOnSignals(['SIGTERM', 'SIGINT', 'SIGUSR1']); }; Support for signals plain names in configuration was introduced in Symfony 7.3. Previously, you had to use the numeric values of signals as defined by the pcntl extension's `predefined constants`_. In some cases the SIGTERM signal is sent by Supervisor itself (e.g. stopping a Docker container having Supervisor as its entrypoint). In these cases you need to add a stopwaitsecs key to the program configuration (with a value of the desired grace period in seconds) in order to perform a graceful shutdown: [program:x] stopwaitsecs=20 Systemd Configuration While Supervisor is a great tool, it has the disadvantage that you need system access to run it. Systemd has become the standard on most Linux distributions, and has a good alternative called *user services*. Systemd user service configuration files typically live in a ~/.config/systemd/user directory. For example, you can create a new messenger-worker.service file. Or a messenger-worker@.service file if you want more instances running at the same time: [Unit] Description=Symfony messenger-consume %i [Service] ExecStart=php /path/to/your/app/bin/console messenger:consume async --time-limit=3600 # for Redis, set a custom consumer name for each instance Environment=\"MESSENGER_CONSUMER_NAME=symfony-%n-%i\" Restart=always RestartSec=30 [Install] WantedBy=default.target Now, tell systemd to enable and start one worker: $ systemctl --user enable messenger-worker@1.service $ systemctl --user start messenger-worker@1.service # to enable and start 20 workers $ systemctl --user enable messenger-worker@{1..20}.service $ systemctl --user start messenger-worker@{1..20}.service If you change your service config file, you need to reload the daemon: $ systemctl --user daemon-reload To restart all your consumers: $ systemctl --user restart messenger-consume@*.service The systemd user instance is only started after the first login of the particular user. Consumer often need to start on system boot instead. Enable lingering on the user to activate that behavior: $ loginctl enable-linger <your-username> Logs are managed by journald and can be worked with using the journalctl command: # follow logs of consumer nr 11 $ journalctl -f --user-unit messenger-consume@11.service # follow logs of all consumers $ journalctl -f --user-unit messenger-consume@* # follow all logs from your user services $ journalctl -f _UID=$UID See the `systemd docs`_ for more details. You either need elevated privileges for the journalctl command, or add your user to the systemd-journal group: $ sudo usermod -a -G systemd-journal <your-username> Stateless Worker PHP is designed to be stateless, there are no shared resources across different requests. In HTTP context PHP cleans everything after sending the response, so you can decide to not take care of services that may leak memory. On the other hand, it's common for workers to process messages sequentially in long-running CLI processes which don't finish after processing a single message. Beware about service states to prevent information and/or memory leakage as Symfony will inject the same instance of a service in all messages, preserving the internal state of the services. However, certain Symfony services, such as the Monolog fingers crossed handler , leak by design. Symfony provides a **service reset** feature to solve this", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_8", "source": "messenger.rst", "text": "context PHP cleans everything after sending the response, so you can decide to not take care of services that may leak memory. On the other hand, it's common for workers to process messages sequentially in long-running CLI processes which don't finish after processing a single message. Beware about service states to prevent information and/or memory leakage as Symfony will inject the same instance of a service in all messages, preserving the internal state of the services. However, certain Symfony services, such as the Monolog fingers crossed handler , leak by design. Symfony provides a **service reset** feature to solve this problem. When resetting the container automatically between two messages, Symfony looks for any services implementing Symfony\\\\Contracts\\\\Service\\\\ResetInterface (including your own services) and calls their reset() method so they can clean their internal state. If a service is not stateless and you want to reset its properties after each message, then the service must implement Symfony\\\\Contracts\\\\Service\\\\ResetInterface where you can reset the properties in the reset() method. If you don't want to reset the container, add the --no-reset option when running the messenger:consume command. Rate Limited Transport Sometimes you might need to rate limit your message worker. You can configure a rate limiter on a transport (requires the RateLimiter component ) by setting its rate_limiter option: # config/packages/messenger.yaml framework: messenger: transports: async: rate_limiter: your_rate_limiter_name <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async\"> <option key=\"rate_limiter\">your_rate_limiter_name</option> </framework:transport> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework) { $framework->messenger() ->transport('async') ->options(['rate_limiter' => 'your_rate_limiter_name']) ; }; When a rate limiter is configured on a transport, it will block the whole worker when the limit is hit. You should make sure you configure a dedicated worker for a rate limited transport to avoid other transports to be blocked. Retries & Failures If an exception is thrown while consuming a message from a transport it will automatically be re-sent to the transport to be tried again. By default, a message will be retried 3 times before being discarded or sent to the failure transport . Each retry will also be delayed, in case the failure was due to a temporary issue. All of this is configurable for each transport: # config/packages/messenger.yaml framework: messenger: transports: async_priority_high: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' # default configuration retry_strategy: max_retries: 3 # milliseconds delay delay: 1000 # causes the delay to be higher before each retry # e.g. 1 second delay, 2 seconds, 4 seconds multiplier: 2 max_delay: 0 # applies randomness to the delay that can prevent the thundering herd effect # the value (between 0 and 1.0) is the percentage of 'delay' that will be added/subtracted jitter: 0.1 # override all of this with a service that # implements Symfony\\Component\\Messenger\\Retry\\RetryStrategyInterface # service: null <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%?queue_name=high_priority\"> <framework:retry-strategy max-retries=\"3\" delay=\"1000\" multiplier=\"2\" max-delay=\"0\" jitter=\"0.1\"/> </framework:transport> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_9", "source": "messenger.rst", "text": "before each retry # e.g. 1 second delay, 2 seconds, 4 seconds multiplier: 2 max_delay: 0 # applies randomness to the delay that can prevent the thundering herd effect # the value (between 0 and 1.0) is the percentage of 'delay' that will be added/subtracted jitter: 0.1 # override all of this with a service that # implements Symfony\\Component\\Messenger\\Retry\\RetryStrategyInterface # service: null <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%?queue_name=high_priority\"> <framework:retry-strategy max-retries=\"3\" delay=\"1000\" multiplier=\"2\" max-delay=\"0\" jitter=\"0.1\"/> </framework:transport> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $messenger->transport('async_priority_high') ->dsn(env('MESSENGER_TRANSPORT_DSN')) // default configuration ->retryStrategy() ->maxRetries(3) // milliseconds delay ->delay(1000) // causes the delay to be higher before each retry // e.g. 1 second delay, 2 seconds, 4 seconds ->multiplier(2) ->maxDelay(0) // applies randomness to the delay that can prevent the thundering herd effect // the value (between 0 and 1.0) is the percentage of 'delay' that will be added/subtracted ->jitter(0.1) // override all of this with a service that // implements Symfony\\Component\\Messenger\\Retry\\RetryStrategyInterface ->service(null) ; }; The jitter option was introduced in Symfony 7.1. Symfony triggers a Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageRetriedEvent when a message is retried so you can run your own logic. Thanks to Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\SerializedMessageStamp, the serialized form of the message is saved, which prevents to serialize it again if the message is later retried. Avoiding Retrying Sometimes handling a message might fail in a way that you *know* is permanent and should not be retried. If you throw Symfony\\\\Component\\\\Messenger\\\\Exception\\\\UnrecoverableMessageHandlingException, the message will not be retried. Messages that will not be retried, will still show up in the configured failure transport. If you want to avoid that, consider handling the error yourself and let the handler successfully end. Forcing Retrying Sometimes handling a message must fail in a way that you *know* is temporary and must be retried. If you throw Symfony\\\\Component\\\\Messenger\\\\Exception\\\\RecoverableMessageHandlingException, the message will always be retried infinitely and max_retries setting will be ignored. You can define a custom retry delay in milliseconds (e.g., to use the value from the Retry-After header in an HTTP response) by setting the retryDelay argument in the constructor of the RecoverableMessageHandlingException. The retryDelay argument and the getRetryDelay() method were introduced in Symfony 7.2. Saving & Retrying Failed Messages If a message fails it is retried multiple times (max_retries) and then will be discarded. To avoid this happening, you can instead configure a failure_transport: # config/packages/messenger.yaml framework: messenger: # after retrying, messages will be sent to the \"failed\" transport failure_transport: failed transports: # ... other transports failed: 'doctrine://default?queue_name=failed' <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <!-- after retrying, messages will be sent to the \"failed\" transport --> <framework:messenger failure-transport=\"failed\"> <!-- ... other transports --> <framework:transport name=\"failed\" dsn=\"doctrine://default?queue_name=failed\"/> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); // after retrying, messages will be sent to the \"failed\" transport $messenger->failureTransport('failed'); // ... other transports", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_10", "source": "messenger.rst", "text": "can instead configure a failure_transport: # config/packages/messenger.yaml framework: messenger: # after retrying, messages will be sent to the \"failed\" transport failure_transport: failed transports: # ... other transports failed: 'doctrine://default?queue_name=failed' <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <!-- after retrying, messages will be sent to the \"failed\" transport --> <framework:messenger failure-transport=\"failed\"> <!-- ... other transports --> <framework:transport name=\"failed\" dsn=\"doctrine://default?queue_name=failed\"/> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); // after retrying, messages will be sent to the \"failed\" transport $messenger->failureTransport('failed'); // ... other transports $messenger->transport('failed') ->dsn('doctrine://default?queue_name=failed'); }; In this example, if handling a message fails 3 times (default max_retries), it will then be sent to the failed transport. While you *can* use messenger:consume failed to consume this like a normal transport, you'll usually want to manually view the messages in the failure transport and choose to retry them: # see all messages in the failure transport with a default limit of 50 $ php bin/console messenger:failed:show # see the 10 first messages $ php bin/console messenger:failed:show --max=10 # see only App\\Message\\MyMessage messages $ php bin/console messenger:failed:show --class-filter='App\\Message\\MyMessage' # see the number of messages by message class $ php bin/console messenger:failed:show --stats # see details about a specific failure $ php bin/console messenger:failed:show 20 -vv # for each message, this command asks whether to retry, skip, or delete $ php bin/console messenger:failed:retry -vv # retry specific messages $ php bin/console messenger:failed:retry 20 30 --force # remove a message without retrying it $ php bin/console messenger:failed:remove 20 # remove messages without retrying them and show each message before removing it $ php bin/console messenger:failed:remove 20 30 --show-messages # remove all messages in the failure transport $ php bin/console messenger:failed:remove --all # remove only App\\Message\\MyMessage messages $ php bin/console messenger:failed:remove --class-filter='App\\Message\\MyMessage' If the message fails again, it will be re-sent back to the failure transport due to the normal retry rules . Once the max retry has been hit, the message will be discarded permanently. The option to skip a message in the messenger:failed:retry command was introduced in Symfony 7.2 The option to filter by a message class in the messenger:failed:remove command was introduced in Symfony 7.3 Multiple Failed Transports Sometimes it is not enough to have a single, global failed transport configured because some messages are more important than others. In those cases, you can override the failure transport for only specific transports: # config/packages/messenger.yaml framework: messenger: # after retrying, messages will be sent to the \"failed\" transport # by default if no \"failed_transport\" is configured inside a transport failure_transport: failed_default transports: async_priority_high: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' failure_transport: failed_high_priority # since no failed transport is configured, the one used will be # the global \"failure_transport\" set async_priority_low: dsn: 'doctrine://default?queue_name=async_priority_low' failed_default: 'doctrine://default?queue_name=failed_default' failed_high_priority: 'doctrine://default?queue_name=failed_high_priority' <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <!-- after retrying, messages will be sent to the \"failed\" transport by default if no \"failed-transport\" is configured inside", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_11", "source": "messenger.rst", "text": "the failure transport for only specific transports: # config/packages/messenger.yaml framework: messenger: # after retrying, messages will be sent to the \"failed\" transport # by default if no \"failed_transport\" is configured inside a transport failure_transport: failed_default transports: async_priority_high: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' failure_transport: failed_high_priority # since no failed transport is configured, the one used will be # the global \"failure_transport\" set async_priority_low: dsn: 'doctrine://default?queue_name=async_priority_low' failed_default: 'doctrine://default?queue_name=failed_default' failed_high_priority: 'doctrine://default?queue_name=failed_high_priority' <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <!-- after retrying, messages will be sent to the \"failed\" transport by default if no \"failed-transport\" is configured inside a transport --> <framework:messenger failure-transport=\"failed_default\"> <framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\" failure-transport=\"failed_high_priority\"/> <!-- since no \"failed_transport\" is configured, the one used will be the global \"failed_transport\" set --> <framework:transport name=\"async_priority_low\" dsn=\"doctrine://default?queue_name=async_priority_low\"/> <framework:transport name=\"failed_default\" dsn=\"doctrine://default?queue_name=failed_default\"/> <framework:transport name=\"failed_high_priority\" dsn=\"doctrine://default?queue_name=failed_high_priority\"/> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); // after retrying, messages will be sent to the \"failed\" transport // by default if no \"failure_transport\" is configured inside a transport $messenger->failureTransport('failed_default'); $messenger->transport('async_priority_high') ->dsn(env('MESSENGER_TRANSPORT_DSN')) ->failureTransport('failed_high_priority'); // since no failed transport is configured, the one used will be // the global failure_transport set $messenger->transport('async_priority_low') ->dsn('doctrine://default?queue_name=async_priority_low'); $messenger->transport('failed_default') ->dsn('doctrine://default?queue_name=failed_default'); $messenger->transport('failed_high_priority') ->dsn('doctrine://default?queue_name=failed_high_priority'); }; If there is no failure_transport defined globally or on the transport level, the messages will be discarded after the number of retries. The failed commands have an optional option --transport to specify the failure_transport configured at the transport level. # see all messages in \"failure_transport\" transport $ php bin/console messenger:failed:show --transport=failure_transport # retry specific messages from \"failure_transport\" $ php bin/console messenger:failed:retry 20 30 --transport=failure_transport --force # remove a message without retrying it from \"failure_transport\" $ php bin/console messenger:failed:remove 20 --transport=failure_transport Transport Configuration Messenger supports a number of different transport types, each with their own options. Options can be passed to the transport via a DSN string or configuration. # .env MESSENGER_TRANSPORT_DSN=amqp://localhost/%2f/messages?auto_setup=false # config/packages/messenger.yaml framework: messenger: transports: my_transport: dsn: \"%env(MESSENGER_TRANSPORT_DSN)%\" options: auto_setup: false <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"my_transport\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\"> <framework:options auto-setup=\"false\"/> </framework:transport> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $messenger->transport('my_transport') ->dsn(env('MESSENGER_TRANSPORT_DSN')) ->options(['auto_setup' => false]); }; Options defined under options take precedence over ones defined in the DSN. AMQP Transport The AMQP transport uses the AMQP PHP extension to send messages to queues like RabbitMQ. Install it by running: $ composer require symfony/amqp-messenger The AMQP transport DSN may look like this: # .env MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages # or use the AMQPS protocol MESSENGER_TRANSPORT_DSN=amqps://guest:guest@localhost/%2f/messages If you want to use TLS/SSL encrypted AMQP, you must also provide a CA certificate. Define the certificate path in the amqp.cacert PHP.ini setting (e.g. amqp.cacert = /etc/ssl/certs) or in the cacert parameter of the DSN (e.g amqps://localhost?cacert=/etc/ssl/certs/). The default port used by TLS/SSL encrypted AMQP is 5671, but you can overwrite it in the port parameter of the DSN (e.g. amqps://localhost?cacert=/etc/ssl/certs/&port=12345). By default, the transport will automatically create any exchanges, queues and binding keys that", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_12", "source": "messenger.rst", "text": "by running: $ composer require symfony/amqp-messenger The AMQP transport DSN may look like this: # .env MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages # or use the AMQPS protocol MESSENGER_TRANSPORT_DSN=amqps://guest:guest@localhost/%2f/messages If you want to use TLS/SSL encrypted AMQP, you must also provide a CA certificate. Define the certificate path in the amqp.cacert PHP.ini setting (e.g. amqp.cacert = /etc/ssl/certs) or in the cacert parameter of the DSN (e.g amqps://localhost?cacert=/etc/ssl/certs/). The default port used by TLS/SSL encrypted AMQP is 5671, but you can overwrite it in the port parameter of the DSN (e.g. amqps://localhost?cacert=/etc/ssl/certs/&port=12345). By default, the transport will automatically create any exchanges, queues and binding keys that are needed. That can be disabled, but some functionality may not work correctly (like delayed queues). To not autocreate any queues, you can configure a transport with queues: []. You can limit the consumer of an AMQP transport to only process messages from some queues of an exchange. See messenger-limit-queues. The transport has a number of other options, including ways to configure the exchange, queues binding keys and more. See the documentation on Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\Amqp\\\\Transport\\\\Connection. The transport has a number of options: auto_setup (default: true) Whether the exchanges and queues should be created automatically during send / get. cacert Path to the CA cert file in PEM format. cert Path to the client certificate in PEM format. channel_max Specifies highest channel number that the server permits. 0 means standard extension limit confirm_timeout Timeout in seconds for confirmation; if none specified, transport will not wait for message confirmation. Note: 0 or greater seconds. May be fractional. connect_timeout Connection timeout. Note: 0 or greater seconds. May be fractional. frame_max The largest frame size that the server proposes for the connection, including frame header and end-byte. 0 means standard extension limit (depends on librabbimq default frame size limit) heartbeat The delay, in seconds, of the connection heartbeat that the server wants. 0 means the server does not want a heartbeat. Note, librabbitmq has limited heartbeat support, which means heartbeats checked only during blocking calls. host Hostname of the AMQP service key Path to the client key in PEM format. login Username to use to connect the AMQP service password Password to use to connect to the AMQP service persistent (default: 'false') Whether the connection is persistent port Port of the AMQP service read_timeout Timeout in for income activity. Note: 0 or greater seconds. May be fractional. retry (no description available) sasl_method (no description available) connection_name For custom connection names (requires at least version 1.10 of the PHP AMQP extension) verify Enable or disable peer verification. If peer verification is enabled then the common name in the server certificate must match the server name. Peer verification is enabled by default. vhost Virtual Host to use with the AMQP service write_timeout Timeout in for outcome activity. Note: 0 or greater seconds. May be fractional. delay[queue_name_pattern] (default: delay_%exchange_name%_%routing_key%_%delay%) Pattern to use to create the queues delay[exchange_name] (default: delays) Name of the exchange to be used for the delayed/retried messages queues[name][arguments] Extra arguments queues[name][binding_arguments] Arguments to be used", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_13", "source": "messenger.rst", "text": "connection_name For custom connection names (requires at least version 1.10 of the PHP AMQP extension) verify Enable or disable peer verification. If peer verification is enabled then the common name in the server certificate must match the server name. Peer verification is enabled by default. vhost Virtual Host to use with the AMQP service write_timeout Timeout in for outcome activity. Note: 0 or greater seconds. May be fractional. delay[queue_name_pattern] (default: delay_%exchange_name%_%routing_key%_%delay%) Pattern to use to create the queues delay[exchange_name] (default: delays) Name of the exchange to be used for the delayed/retried messages queues[name][arguments] Extra arguments queues[name][binding_arguments] Arguments to be used while binding the queue. queues[name][binding_keys] The binding keys (if any) to bind to this queue queues[name][flags] (default: AMQP_DURABLE) Queue flags exchange[arguments] Extra arguments for the exchange (e.g. alternate-exchange) exchange[default_publish_routing_key] Routing key to use when publishing, if none is specified on the message exchange[flags] (default: AMQP_DURABLE) Exchange flags exchange[name] Name of the exchange. Use an empty string to use the default exchange. exchange[type] (default: fanout) Type of exchange Empty string support for exchange[name] was introduced in Symfony 7.3. You can also configure AMQP-specific settings on your message by adding Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\Amqp\\\\Transport\\\\AmqpStamp to your Envelope:: use Symfony\\Component\\Messenger\\Bridge\\Amqp\\Transport\\AmqpStamp; // ... $attributes = []; $bus->dispatch(new SmsNotification(), [ new AmqpStamp('custom-routing-key', AMQP_NOPARAM, $attributes), ]); The consumers do not show up in an admin panel as this transport does not rely on \\AmqpQueue::consume() which is blocking. Having a blocking receiver makes the --time-limit/--memory-limit options of the messenger:consume command as well as the messenger:stop-workers command inefficient, as they all rely on the fact that the receiver returns immediately no matter if it finds a message or not. The consume worker is responsible for iterating until it receives a message to handle and/or until one of the stop conditions is reached. Thus, the worker's stop logic cannot be reached if it is stuck in a blocking call. If your application faces socket exceptions or `high connection churn`_ (shown by the rapid creation and deletion of connections), consider using `AMQProxy`_. This tool works as a gateway between Symfony Messenger and AMQP server, maintaining stable connections and minimizing overheads (which also improves the overall performance). Doctrine Transport The Doctrine transport can be used to store messages in a database table. Install it by running: $ composer require symfony/doctrine-messenger The Doctrine transport DSN may look like this: # .env MESSENGER_TRANSPORT_DSN=doctrine://default The format is doctrine://<connection_name>, in case you have multiple connections and want to use one other than the \"default\". The transport will automatically create a table named messenger_messages. If you want to change the default table name, pass a custom table name in the DSN by using the table_name option: # .env MESSENGER_TRANSPORT_DSN=doctrine://default?table_name=your_custom_table_name Or, to create the table yourself, set the auto_setup option to false and generate a migration . The transport has a number of options: table_name (default: messenger_messages) Name of the table queue_name (default: default) Name of the queue (a column in the table, to use one table for multiple transports) redeliver_timeout (default: 3600) Timeout before retrying a message that's in", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_14", "source": "messenger.rst", "text": "use one other than the \"default\". The transport will automatically create a table named messenger_messages. If you want to change the default table name, pass a custom table name in the DSN by using the table_name option: # .env MESSENGER_TRANSPORT_DSN=doctrine://default?table_name=your_custom_table_name Or, to create the table yourself, set the auto_setup option to false and generate a migration . The transport has a number of options: table_name (default: messenger_messages) Name of the table queue_name (default: default) Name of the queue (a column in the table, to use one table for multiple transports) redeliver_timeout (default: 3600) Timeout before retrying a message that's in the queue but in the \"handling\" state (if a worker stopped for some reason, this will occur, eventually you should retry the message) - in seconds. Set redeliver_timeout to a greater value than your longest message duration. Otherwise, some messages will start a second time while the first one is still being handled. auto_setup Whether the table should be created automatically during send / get. When using PostgreSQL, you have access to the following options to leverage the `LISTEN/NOTIFY`_ feature. This allow for a more performant approach than the default polling behavior of the Doctrine transport because PostgreSQL will directly notify the workers when a new message is inserted in the table. use_notify (default: true) Whether to use LISTEN/NOTIFY. check_delayed_interval (default: 60000) The interval to check for delayed messages, in milliseconds. Set to 0 to disable checks. get_notify_timeout (default: 0) The length of time to wait for a response when calling PDO::pgsqlGetNotify, in milliseconds. The Doctrine transport supports the --keepalive option by periodically updating the delivered_at timestamp to prevent the message from being redelivered. Keepalive support was introduced in Symfony 7.3. Beanstalkd Transport The Beanstalkd transport sends messages directly to a Beanstalkd work queue. Install it by running: $ composer require symfony/beanstalkd-messenger The Beanstalkd transport DSN may looks like this: # .env MESSENGER_TRANSPORT_DSN=beanstalkd://localhost:11300?tube_name=foo&timeout=4&ttr=120 # If no port, it will default to 11300 MESSENGER_TRANSPORT_DSN=beanstalkd://localhost The transport has a number of options: bury_on_reject (default: false) When set to true, rejected messages are placed into a \"buried\" state in Beanstalkd instead of being deleted. The bury_on_reject option was introduced in Symfony 7.3. timeout (default: 0) Message reservation timeout - in seconds. 0 will cause the server to immediately return either a response or a TransportException will be thrown. ttr (default: 90) The message time to run before it is put back in the ready queue - in seconds. tube_name (default: default) Name of the queue The Beanstalkd transport supports the --keepalive option by using Beanstalkd's touch command to periodically reset the job's ttr. Keepalive support was introduced in Symfony 7.2. The Beanstalkd transport lets you set the priority of the messages being dispatched. Use the Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\Beanstalkd\\\\Transport\\\\BeanstalkdPriorityStamp and pass a number to specify the priority (default = 1024; lower numbers mean higher priority):: use App\\Message\\SomeMessage; use Symfony\\Component\\Messenger\\Stamp\\BeanstalkdPriorityStamp; $this->bus->dispatch(new SomeMessage('some data'), [ // 0 = highest priority // 2**32 - 1 = lowest priority new BeanstalkdPriorityStamp(0), ]); BeanstalkdPriorityStamp support was introduced in Symfony 7.3. Redis", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_15", "source": "messenger.rst", "text": "ready queue - in seconds. tube_name (default: default) Name of the queue The Beanstalkd transport supports the --keepalive option by using Beanstalkd's touch command to periodically reset the job's ttr. Keepalive support was introduced in Symfony 7.2. The Beanstalkd transport lets you set the priority of the messages being dispatched. Use the Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\Beanstalkd\\\\Transport\\\\BeanstalkdPriorityStamp and pass a number to specify the priority (default = 1024; lower numbers mean higher priority):: use App\\Message\\SomeMessage; use Symfony\\Component\\Messenger\\Stamp\\BeanstalkdPriorityStamp; $this->bus->dispatch(new SomeMessage('some data'), [ // 0 = highest priority // 2**32 - 1 = lowest priority new BeanstalkdPriorityStamp(0), ]); BeanstalkdPriorityStamp support was introduced in Symfony 7.3. Redis Transport The Redis transport uses `streams`_ to queue messages. This transport requires the Redis PHP extension (>=4.3) and a running Redis server (^5.0). Install it by running: $ composer require symfony/redis-messenger The Redis transport DSN may looks like this: # .env MESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages # Full DSN Example MESSENGER_TRANSPORT_DSN=redis://password@localhost:6379/messages/symfony/consumer?auto_setup=true&serializer=1&stream_max_entries=0&dbindex=0 # Redis Cluster Example MESSENGER_TRANSPORT_DSN=redis://host-01:6379,redis://host-02:6379,redis://host-03:6379,redis://host-04:6379 # Unix Socket Example MESSENGER_TRANSPORT_DSN=redis:///var/run/redis.sock # TLS Example MESSENGER_TRANSPORT_DSN=rediss://localhost:6379/messages # Multiple Redis Sentinel Hosts Example MESSENGER_TRANSPORT_DSN=redis:?host[redis1:26379]&host[redis2:26379]&host[redis3:26379]&sentinel_master=db A number of options can be configured via the DSN or via the options key under the transport in messenger.yaml: stream (default: messages) The Redis stream name group (default: symfony) The Redis consumer group name consumer (default: consumer) Consumer name used in Redis. Allows setting an explicit consumer name identifier. Recommended in environments with multiple workers to prevent duplicate message processing. Typically set via an environment variable: # config/packages/messenger.yaml framework: messenger: transports: redis: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: consumer: '%env(MESSENGER_CONSUMER_NAME)%' auto_setup (default: true) Whether to create the Redis group automatically auth The Redis password delete_after_ack (default: true) If true, messages are deleted automatically after processing them delete_after_reject (default: true) If true, messages are deleted automatically if they are rejected lazy (default: false) Connect only when a connection is really needed serializer (default: Redis::SERIALIZER_PHP) How to serialize the final payload in Redis (the Redis::OPT_SERIALIZER option) stream_max_entries (default: 0) The maximum number of entries which the stream will be trimmed to. Set it to a large enough number to avoid losing pending messages redeliver_timeout (default: 3600) Timeout (in seconds) before retrying a pending message which is owned by an abandoned consumer (if a worker died for some reason, this will occur, eventually you should retry the message). claim_interval (default: 60000) Interval on which pending/abandoned messages should be checked for to claim - in milliseconds persistent_id (default: null) String, if null connection is non-persistent. retry_interval (default: 0) Int, value in milliseconds read_timeout (default: 0) Float, value in seconds default indicates unlimited timeout (default: 0) Connection timeout. Float, value in seconds default indicates unlimited sentinel_master (default: null) String, if null or empty Sentinel support is disabled redis_sentinel (default: null) An alias of the sentinel_master option The redis_sentinel option was introduced in Symfony 7.1. ssl (default: null) Map of `SSL context options`_ for the TLS channel. This is useful for example to change the requirements for the TLS channel in tests: # config/packages/test/messenger.yaml framework: messenger: transports: redis: dsn: \"rediss://localhost\" options: ssl: allow_self_signed: true capture_peer_cert: true capture_peer_cert_chain: true disable_compression: true", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_16", "source": "messenger.rst", "text": "Int, value in milliseconds read_timeout (default: 0) Float, value in seconds default indicates unlimited timeout (default: 0) Connection timeout. Float, value in seconds default indicates unlimited sentinel_master (default: null) String, if null or empty Sentinel support is disabled redis_sentinel (default: null) An alias of the sentinel_master option The redis_sentinel option was introduced in Symfony 7.1. ssl (default: null) Map of `SSL context options`_ for the TLS channel. This is useful for example to change the requirements for the TLS channel in tests: # config/packages/test/messenger.yaml framework: messenger: transports: redis: dsn: \"rediss://localhost\" options: ssl: allow_self_signed: true capture_peer_cert: true capture_peer_cert_chain: true disable_compression: true SNI_enabled: true verify_peer: true verify_peer_name: true There should never be more than one messenger:consume command running with the same combination of stream, group and consumer, or messages could end up being handled more than once. If you run multiple queue workers, consumer can be set to an environment variable, like %env(MESSENGER_CONSUMER_NAME)%, set by Supervisor (example below) or any other service used to manage the worker processes. In a container environment, the HOSTNAME can be used as the consumer name, since there is only one worker per container/host. If using Kubernetes to orchestrate the containers, consider using a StatefulSet to have stable names. Set delete_after_ack to true (if you use a single group) or define stream_max_entries (if you can estimate how many max entries is acceptable in your case) to avoid memory leaks. Otherwise, all messages will remain forever in Redis. The Redis transport supports the --keepalive option by using Redis's XCLAIM command to periodically reset the message's idle time to zero. Keepalive support was introduced in Symfony 7.3. In Memory Transport The in-memory transport does not actually deliver messages. Instead, it holds them in memory during the request, which can be useful for testing. For example, if you have an async_priority_normal transport, you could override it in the test environment to use this transport: # config/packages/test/messenger.yaml framework: messenger: transports: async_priority_normal: 'in-memory://' <!-- config/packages/test/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async_priority_normal\" dsn=\"in-memory://\"/> </framework:messenger> </framework:config> </container> // config/packages/test/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $messenger->transport('async_priority_normal') ->dsn('in-memory://'); }; Then, while testing, messages will *not* be delivered to the real transport. Even better, in a test, you can check that exactly one message was sent during a request:: // tests/Controller/DefaultControllerTest.php namespace App\\Tests\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase; use Symfony\\Component\\Messenger\\Transport\\InMemory\\InMemoryTransport; class DefaultControllerTest extends WebTestCase { public function testSomething(): void { $client = static::createClient(); // ... $this->assertSame(200, $client->getResponse()->getStatusCode()); /** @var InMemoryTransport $transport */ $transport = $this->getContainer()->get('messenger.transport.async_priority_normal'); $this->assertCount(1, $transport->getSent()); } } The transport has a number of options: serialize (boolean, default: false) Whether to serialize messages or not. This is useful to test an additional layer, especially when you use your own message serializer. All in-memory transports will be reset automatically after each test **in** test classes extending Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\KernelTestCase or Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\WebTestCase. Amazon SQS The Amazon SQS transport is perfect for applications hosted on AWS. Install it by running: $ composer require symfony/amazon-sqs-messenger The SQS", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_17", "source": "messenger.rst", "text": "extends WebTestCase { public function testSomething(): void { $client = static::createClient(); // ... $this->assertSame(200, $client->getResponse()->getStatusCode()); /** @var InMemoryTransport $transport */ $transport = $this->getContainer()->get('messenger.transport.async_priority_normal'); $this->assertCount(1, $transport->getSent()); } } The transport has a number of options: serialize (boolean, default: false) Whether to serialize messages or not. This is useful to test an additional layer, especially when you use your own message serializer. All in-memory transports will be reset automatically after each test **in** test classes extending Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\KernelTestCase or Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\WebTestCase. Amazon SQS The Amazon SQS transport is perfect for applications hosted on AWS. Install it by running: $ composer require symfony/amazon-sqs-messenger The SQS transport DSN may looks like this: # .env MESSENGER_TRANSPORT_DSN=https://sqs.eu-west-3.amazonaws.com/123456789012/messages?access_key=AKIAIOSFODNN7EXAMPLE&secret_key=j17M97ffSVoKI0briFoo9a MESSENGER_TRANSPORT_DSN=sqs://localhost:9494/messages?sslmode=disable The transport will automatically create queues that are needed. This can be disabled by setting the auto_setup option to false. Before sending or receiving a message, Symfony needs to convert the queue name into an AWS queue URL by calling the GetQueueUrl API in AWS. This extra API call can be avoided by providing a DSN which is the queue URL. The transport has a number of options: access_key AWS access key (must be urlencoded) account (default: The owner of the credentials) Identifier of the AWS account auto_setup (default: true) Whether the queue should be created automatically during send / get. buffer_size (default: 9) Number of messages to prefetch debug (default: false) If true it logs all HTTP requests and responses (it impacts performance) endpoint (default: https://sqs.eu-west-1.amazonaws.com) Absolute URL to the SQS service poll_timeout (default: 0.1) Wait for new message duration in seconds queue_name (default: messages) Name of the queue queue_attributes Attributes of a queue as per `SQS CreateQueue API`_. Array of strings indexed by keys of AsyncAws\\Sqs\\Enum\\QueueAttributeName. queue_tags Cost allocation tags of a queue as per `SQS CreateQueue API`_. Array of strings indexed by strings. region (default: eu-west-1) Name of the AWS region secret_key AWS secret key (must be urlencoded) session_token AWS session token visibility_timeout (default: Queue's configuration) Amount of seconds the message will not be visible (`Visibility Timeout`_) wait_time (default: 20) `Long polling`_ duration in seconds The queue_attributes and queue_tags options were introduced in Symfony 7.3. The wait_time parameter defines the maximum duration Amazon SQS should wait until a message is available in a queue before sending a response. It helps reducing the cost of using Amazon SQS by eliminating the number of empty responses. The poll_timeout parameter defines the duration the receiver should wait before returning null. It avoids blocking other receivers from being called. If the queue name is suffixed by .fifo, AWS will create a `FIFO queue`_. Use the stamp Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Transport\\\\AmazonSqsFifoStamp to define the Message group ID and the Message deduplication ID. Another possibility is to enable the Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Middleware\\\\AddFifoStampMiddleware. If your message implements Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\MessageDeduplicationAwareInterface, the middleware will automatically add the Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Transport\\\\AmazonSqsFifoStamp and set the Message deduplication ID. Additionally, if your message implements the Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\MessageGroupAwareInterface, the middleware will automatically set the Message group ID of the stamp. You can learn more about middlewares in the dedicated section . FIFO queues don't support setting a delay per", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_18", "source": "messenger.rst", "text": "It avoids blocking other receivers from being called. If the queue name is suffixed by .fifo, AWS will create a `FIFO queue`_. Use the stamp Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Transport\\\\AmazonSqsFifoStamp to define the Message group ID and the Message deduplication ID. Another possibility is to enable the Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Middleware\\\\AddFifoStampMiddleware. If your message implements Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\MessageDeduplicationAwareInterface, the middleware will automatically add the Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Transport\\\\AmazonSqsFifoStamp and set the Message deduplication ID. Additionally, if your message implements the Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\MessageGroupAwareInterface, the middleware will automatically set the Message group ID of the stamp. You can learn more about middlewares in the dedicated section . FIFO queues don't support setting a delay per message, a value of delay: 0 is required in the retry strategy settings. The SQS transport supports the --keepalive option by using the ChangeMessageVisibility action to periodically update the VisibilityTimeout of the message. Keepalive support was introduced in Symfony 7.2. Serializing Messages When messages are sent to (and received from) a transport, they're serialized using PHP's native serialize() & unserialize() functions. You can change this globally (or for each transport) to a service that implements Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Serialization\\\\SerializerInterface: # config/packages/messenger.yaml framework: messenger: serializer: default_serializer: messenger.transport.symfony_serializer symfony_serializer: format: json context: { } transports: async_priority_normal: dsn: # ... serializer: messenger.transport.symfony_serializer <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:serializer default-serializer=\"messenger.transport.symfony_serializer\"> <framework:symfony-serializer format=\"json\"> <framework:context/> </framework:symfony-serializer> </framework:serializer> <framework:transport name=\"async_priority_normal\" dsn=\"...\" serializer=\"messenger.transport.symfony_serializer\"/> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $messenger->serializer() ->defaultSerializer('messenger.transport.symfony_serializer') ->symfonySerializer() ->format('json') ->context('foo', 'bar'); $messenger->transport('async_priority_normal') ->dsn('...') ->serializer('messenger.transport.symfony_serializer'); }; The messenger.transport.symfony_serializer is a built-in service that uses the Serializer component and can be configured in a few ways. If you *do* choose to use the Symfony serializer, you can control the context on a case-by-case basis via the Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\SerializerStamp (see `Envelopes & Stamps`_). When sending/receiving messages to/from another application, you may need more control over the serialization process. Using a custom serializer provides that control. See `SymfonyCasts' message serializer tutorial`_ for details. Closing Connections When using a transport that requires a connection, you can close it by calling the Symfony\\\\Component\\\\Messenger\\\\Transport\\\\CloseableTransportInterface::close method to free up resources in long-running processes. This interface is implemented by the following transports: AmazonSqs, Amqp, and Redis. If you need to close a Doctrine connection, you can do so using middleware . The CloseableTransportInterface and its close() method were introduced in Symfony 7.3. Running Commands And External Processes Trigger a Command It is possible to trigger any command by dispatching a Symfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandMessage. Symfony will take care of handling this message and execute the command passed to the message parameter:: use Symfony\\Component\\Console\\Messenger\\RunCommandMessage; use Symfony\\Component\\Messenger\\MessageBusInterface; class CleanUpService { public function __construct(private readonly MessageBusInterface $bus) { } public function cleanUp(): void { // Long task with some caching... // Once finished, dispatch some clean up commands $this->bus->dispatch(new RunCommandMessage('app:my-cache:clean-up --dir=var/temp')); $this->bus->dispatch(new RunCommandMessage('cache:clear')); } } You can configure the behavior in the case of something going wrong during command execution. To do so, you can use the throwOnFailure and catchExceptions parameters when creating your instance of Symfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandMessage. Once handled, the", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_19", "source": "messenger.rst", "text": "trigger any command by dispatching a Symfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandMessage. Symfony will take care of handling this message and execute the command passed to the message parameter:: use Symfony\\Component\\Console\\Messenger\\RunCommandMessage; use Symfony\\Component\\Messenger\\MessageBusInterface; class CleanUpService { public function __construct(private readonly MessageBusInterface $bus) { } public function cleanUp(): void { // Long task with some caching... // Once finished, dispatch some clean up commands $this->bus->dispatch(new RunCommandMessage('app:my-cache:clean-up --dir=var/temp')); $this->bus->dispatch(new RunCommandMessage('cache:clear')); } } You can configure the behavior in the case of something going wrong during command execution. To do so, you can use the throwOnFailure and catchExceptions parameters when creating your instance of Symfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandMessage. Once handled, the handler will return a Symfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandContext which contains many useful information such as the exit code or the output of the process. You can refer to the page dedicated on handler results for more information. Trigger An External Process Messenger comes with a handy helper to run external processes by dispatching a message. This takes advantages of the Process component . By dispatching a Symfony\\\\Component\\\\Process\\\\Messenger\\\\RunProcessMessage, Messenger will take care of creating a new process with the parameters you passed:: use Symfony\\Component\\Messenger\\MessageBusInterface; use Symfony\\Component\\Process\\Messenger\\RunProcessMessage; class CleanUpService { public function __construct( private readonly MessageBusInterface $bus, ) { } public function cleanUp(): void { $this->bus->dispatch(new RunProcessMessage(['rm', '-rf', 'var/log/temp/*'], cwd: '/my/custom/working-dir')); // ... } } If you want to use shell features such as redirections or pipes, use the static Symfony\\\\Component\\\\Process\\\\Messenger\\\\RunProcessMessage::fromShellCommandline factory method:: use Symfony\\Component\\Messenger\\MessageBusInterface; use Symfony\\Component\\Process\\Messenger\\RunProcessMessage; class CleanUpService { public function __construct( private readonly MessageBusInterface $bus, ) { } public function cleanUp(): void { $this->bus->dispatch(RunProcessMessage::fromShellCommandline('echo \"Hello World\" > var/log/hello.txt')); // ... } } For more information, read the documentation about using features from the OS shell . The RunProcessMessage::fromShellCommandline() method was introduced in Symfony 7.3. Once handled, the handler will return a Symfony\\\\Component\\\\Process\\\\Messenger\\\\RunProcessContext which contains many useful information such as the exit code or the output of the process. You can refer to the page dedicated on handler results for more information. Pinging A Webservice Sometimes, you may need to regularly ping a webservice to get its status, e.g. is it up or down. It is possible to do so by dispatching a Symfony\\\\Component\\\\HttpClient\\\\Messenger\\\\PingWebhookMessage:: use Symfony\\Component\\HttpClient\\Messenger\\PingWebhookMessage; use Symfony\\Component\\Messenger\\MessageBusInterface; class LivenessService { public function __construct(private readonly MessageBusInterface $bus) { } public function ping(): void { // An HttpExceptionInterface is thrown on 3xx/4xx/5xx $this->bus->dispatch(new PingWebhookMessage('GET', 'https://example.com/status')); // Ping, but does not throw on 3xx/4xx/5xx $this->bus->dispatch(new PingWebhookMessage('GET', 'https://example.com/status', throw: false)); // Any valid HttpClientInterface option can be used $this->bus->dispatch(new PingWebhookMessage('POST', 'https://example.com/status', [ 'headers' => [ 'Authorization' => 'Bearer ...' ], 'json' => [ 'data' => 'some-data', ], ])); } } The handler will return a Symfony\\\\Contracts\\\\HttpClient\\\\ResponseInterface, allowing you to gather and process information returned by the HTTP request. Getting Results from your Handlers When a message is handled, the Symfony\\\\Component\\\\Messenger\\\\Middleware\\\\HandleMessageMiddleware adds a Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\HandledStamp for each object that handled the message. You can use this to get the value returned by the handler(s):: use Symfony\\Component\\Messenger\\MessageBusInterface; use Symfony\\Component\\Messenger\\Stamp\\HandledStamp; $envelope = $messageBus->dispatch(new SomeMessage()); // get the value that was returned by the last message handler $handledStamp = $envelope->last(HandledStamp::class); $handledStamp->getResult(); //", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_20", "source": "messenger.rst", "text": "used $this->bus->dispatch(new PingWebhookMessage('POST', 'https://example.com/status', [ 'headers' => [ 'Authorization' => 'Bearer ...' ], 'json' => [ 'data' => 'some-data', ], ])); } } The handler will return a Symfony\\\\Contracts\\\\HttpClient\\\\ResponseInterface, allowing you to gather and process information returned by the HTTP request. Getting Results from your Handlers When a message is handled, the Symfony\\\\Component\\\\Messenger\\\\Middleware\\\\HandleMessageMiddleware adds a Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\HandledStamp for each object that handled the message. You can use this to get the value returned by the handler(s):: use Symfony\\Component\\Messenger\\MessageBusInterface; use Symfony\\Component\\Messenger\\Stamp\\HandledStamp; $envelope = $messageBus->dispatch(new SomeMessage()); // get the value that was returned by the last message handler $handledStamp = $envelope->last(HandledStamp::class); $handledStamp->getResult(); // or get info about all of handlers $handledStamps = $envelope->all(HandledStamp::class); Getting Results when Working with Command & Query Buses The Messenger component can be used in CQRS architectures where command & query buses are central pieces of the application. Read Martin Fowler's `article about CQRS`_ to learn more and how to configure multiple buses . As queries are usually synchronous and expected to be handled once, getting the result from the handler is a common need. A Symfony\\\\Component\\\\Messenger\\\\HandleTrait exists to get the result of the handler when processing synchronously. It also ensures that exactly one handler is registered. The HandleTrait can be used in any class that has a $messageBus property:: // src/Action/ListItems.php namespace App\\Action; use App\\Message\\ListItemsQuery; use App\\MessageHandler\\ListItemsQueryResult; use Symfony\\Component\\Messenger\\HandleTrait; use Symfony\\Component\\Messenger\\MessageBusInterface; class ListItems { use HandleTrait; public function __construct( private MessageBusInterface $messageBus, ) { } public function __invoke(): void { $result = $this->query(new ListItemsQuery(/* ... */)); // Do something with the result // ... } // Creating such a method is optional, but allows type-hinting the result private function query(ListItemsQuery $query): ListItemsQueryResult { return $this->handle($query); } } Hence, you can use the trait to create command & query bus classes. For example, you could create a special QueryBus class and inject it wherever you need a query bus behavior instead of the MessageBusInterface:: // src/MessageBus/QueryBus.php namespace App\\MessageBus; use Symfony\\Component\\Messenger\\Envelope; use Symfony\\Component\\Messenger\\HandleTrait; use Symfony\\Component\\Messenger\\MessageBusInterface; class QueryBus { use HandleTrait; public function __construct( private MessageBusInterface $messageBus, ) { } /** * @param object|Envelope $query * * @return mixed The handler returned value */ public function query($query): mixed { return $this->handle($query); } } You can also add new stamps when handling a message; they will be appended to the existing ones:: $this->handle(new SomeMessage($data), [new SomeStamp(), new AnotherStamp()]); The $stamps parameter of the handle() method was introduced in Symfony 7.3. Customizing Handlers Manually Configuring Handlers Symfony will normally find and register your handler automatically . But, you can also configure a handler manually - and pass it some extra config - while using #AsMessageHandler attribute or tagging the handler service with messenger.message_handler. // src/MessageHandler/SmsNotificationHandler.php namespace App\\MessageHandler; use App\\Message\\OtherSmsNotification; use App\\Message\\SmsNotification; use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler; #[AsMessageHandler(fromTransport: 'async', priority: 10)] class SmsNotificationHandler { public function __invoke(SmsNotification $message): void { // ... } } # config/services.yaml services: App\\MessageHandler\\SmsNotificationHandler: tags: [messenger.message_handler] # or configure with options tags: - name: messenger.message_handler # only needed if can't be guessed by type-hint handles: App\\Message\\SmsNotification <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?>", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_21", "source": "messenger.rst", "text": "Manually Configuring Handlers Symfony will normally find and register your handler automatically . But, you can also configure a handler manually - and pass it some extra config - while using #AsMessageHandler attribute or tagging the handler service with messenger.message_handler. // src/MessageHandler/SmsNotificationHandler.php namespace App\\MessageHandler; use App\\Message\\OtherSmsNotification; use App\\Message\\SmsNotification; use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler; #[AsMessageHandler(fromTransport: 'async', priority: 10)] class SmsNotificationHandler { public function __invoke(SmsNotification $message): void { // ... } } # config/services.yaml services: App\\MessageHandler\\SmsNotificationHandler: tags: [messenger.message_handler] # or configure with options tags: - name: messenger.message_handler # only needed if can't be guessed by type-hint handles: App\\Message\\SmsNotification <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <service id=\"App\\MessageHandler\\SmsNotificationHandler\"> <!-- handles is only needed if it can't be guessed by type-hint --> <tag name=\"messenger.message_handler\" handles=\"App\\Message\\SmsNotification\"/> </service> </services> </container> // config/services.php use App\\Message\\SmsNotification; use App\\MessageHandler\\SmsNotificationHandler; $container->register(SmsNotificationHandler::class) ->addTag('messenger.message_handler', [ // only needed if can't be guessed by type-hint 'handles' => SmsNotification::class, ]); Possible options to configure with tags are: bus Name of the bus from which the handler can receive messages, by default all buses. from_transport Name of the transport from which the handler can receive messages, by default all transports. handles Type of messages (FQCN) that can be processed by the handler, only needed if can't be guessed by type-hint. method Name of the method that will process the message. priority Defines the order in which the handler is executed when multiple handlers can process the same message; those with higher priority run first. Handling Multiple Messages A single handler class can handle multiple messages. For that add the #AsMessageHandler attribute to all the handling methods:: // src/MessageHandler/SmsNotificationHandler.php namespace App\\MessageHandler; use App\\Message\\OtherSmsNotification; use App\\Message\\SmsNotification; class SmsNotificationHandler { #[AsMessageHandler] public function handleSmsNotification(SmsNotification $message): void { // ... } #[AsMessageHandler] public function handleOtherSmsNotification(OtherSmsNotification $message): void { // ... } } Transactional Messages: Handle New Messages After Handling is Done A message handler can dispatch new messages while handling others, to either the same or a different bus (if the application has multiple buses ). Any errors or exceptions that occur during this process can have unintended consequences, such as: #. If using the DoctrineTransactionMiddleware and a dispatched message throws an exception, then any database transactions in the original handler will be rolled back. #. If the message is dispatched to a different bus, then the dispatched message will be handled even if some code later in the current handler throws an exception. An Example RegisterUser Process ................................... Consider an application with both a *command* and an *event* bus. The application dispatches a command named RegisterUser to the command bus. The command is handled by the RegisterUserHandler which creates a User object, stores that object to a database and dispatches a UserRegistered message to the event bus. There are many handlers to the UserRegistered message, one handler may send a welcome email to the new user. We are using the DoctrineTransactionMiddleware to wrap all database queries in one database transaction. **Problem 1:** If an exception is thrown when sending the welcome email, then the user", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_22", "source": "messenger.rst", "text": "RegisterUser Process ................................... Consider an application with both a *command* and an *event* bus. The application dispatches a command named RegisterUser to the command bus. The command is handled by the RegisterUserHandler which creates a User object, stores that object to a database and dispatches a UserRegistered message to the event bus. There are many handlers to the UserRegistered message, one handler may send a welcome email to the new user. We are using the DoctrineTransactionMiddleware to wrap all database queries in one database transaction. **Problem 1:** If an exception is thrown when sending the welcome email, then the user will not be created because the DoctrineTransactionMiddleware will rollback the Doctrine transaction, in which the user has been created. **Problem 2:** If an exception is thrown when saving the user to the database, the welcome email is still sent because it is handled asynchronously. DispatchAfterCurrentBusMiddleware Middleware ............................................ For many applications, the desired behavior is to *only* handle messages that are dispatched by a handler once that handler has fully finished. This can be done by using the DispatchAfterCurrentBusMiddleware and adding a DispatchAfterCurrentBusStamp stamp to the message Envelope :: // src/Messenger/CommandHandler/RegisterUserHandler.php namespace App\\Messenger\\CommandHandler; use App\\Entity\\User; use App\\Messenger\\Command\\RegisterUser; use App\\Messenger\\Event\\UserRegistered; use Doctrine\\ORM\\EntityManagerInterface; use Symfony\\Component\\Messenger\\Envelope; use Symfony\\Component\\Messenger\\MessageBusInterface; use Symfony\\Component\\Messenger\\Stamp\\DispatchAfterCurrentBusStamp; class RegisterUserHandler { public function __construct( private MessageBusInterface $eventBus, private EntityManagerInterface $em, ) { } public function __invoke(RegisterUser $command): void { $user = new User($command->getUuid(), $command->getName(), $command->getEmail()); $this->em->persist($user); // The DispatchAfterCurrentBusStamp marks the event message to be handled // only if this handler does not throw an exception. $event = new UserRegistered($command->getUuid()); $this->eventBus->dispatch( (new Envelope($event)) ->with(new DispatchAfterCurrentBusStamp()) ); // ... } } // src/Messenger/EventSubscriber/WhenUserRegisteredThenSendWelcomeEmail.php namespace App\\Messenger\\EventSubscriber; use App\\Entity\\User; use App\\Messenger\\Event\\UserRegistered; use Doctrine\\ORM\\EntityManagerInterface; use Symfony\\Component\\Mailer\\MailerInterface; use Symfony\\Component\\Mime\\RawMessage; class WhenUserRegisteredThenSendWelcomeEmail { public function __construct( private MailerInterface $mailer, private EntityManagerInterface $em, ) { } public function __invoke(UserRegistered $event): void { $user = $this->em->getRepository(User::class)->find($event->getUuid()); $this->mailer->send(new RawMessage('Welcome '.$user->getFirstName())); } } This means that the UserRegistered message would not be handled until *after* the RegisterUserHandler had completed and the new User was persisted to the database. If the RegisterUserHandler encounters an exception, the UserRegistered event will never be handled. And if an exception is thrown while sending the welcome email, the Doctrine transaction will not be rolled back. If WhenUserRegisteredThenSendWelcomeEmail throws an exception, that exception will be wrapped into a DelayedMessageHandlingException. Using DelayedMessageHandlingException::getWrappedExceptions will give you all exceptions that are thrown while handling a message with the DispatchAfterCurrentBusStamp. The dispatch_after_current_bus middleware is enabled by default. If you're configuring your middleware manually, be sure to register dispatch_after_current_bus before doctrine_transaction in the middleware chain. Also, the dispatch_after_current_bus middleware must be loaded for *all* of the buses being used. Binding Handlers to Different Transports Each message can have multiple handlers, and when a message is consumed *all* of its handlers are called. But you can also configure a handler to only be called when it's received from a *specific* transport. This allows you to have a single message where each handler is called by a different \"worker\" that's consuming a different transport. Suppose", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_23", "source": "messenger.rst", "text": "middleware is enabled by default. If you're configuring your middleware manually, be sure to register dispatch_after_current_bus before doctrine_transaction in the middleware chain. Also, the dispatch_after_current_bus middleware must be loaded for *all* of the buses being used. Binding Handlers to Different Transports Each message can have multiple handlers, and when a message is consumed *all* of its handlers are called. But you can also configure a handler to only be called when it's received from a *specific* transport. This allows you to have a single message where each handler is called by a different \"worker\" that's consuming a different transport. Suppose you have an UploadedImage message with two handlers: * ThumbnailUploadedImageHandler: you want this to be handled by a transport called image_transport * NotifyAboutNewUploadedImageHandler: you want this to be handled by a transport called async_priority_normal To do this, add the from_transport option to each handler. For example:: // src/MessageHandler/ThumbnailUploadedImageHandler.php namespace App\\MessageHandler; use App\\Message\\UploadedImage; #[AsMessageHandler(fromTransport: 'image_transport')] class ThumbnailUploadedImageHandler { public function __invoke(UploadedImage $uploadedImage): void { // do some thumbnailing } } And similarly:: // src/MessageHandler/NotifyAboutNewUploadedImageHandler.php // ... #[AsMessageHandler(fromTransport: 'async_priority_normal')] class NotifyAboutNewUploadedImageHandler { // ... } Then, make sure to \"route\" your message to *both* transports: # config/packages/messenger.yaml framework: messenger: transports: async_priority_normal: # ... image_transport: # ... routing: # ... 'App\\Message\\UploadedImage': [image_transport, async_priority_normal] <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"async_priority_normal\" dsn=\"...\"/> <framework:transport name=\"image_transport\" dsn=\"...\"/> <framework:routing message-class=\"App\\Message\\UploadedImage\"> <framework:sender service=\"image_transport\"/> <framework:sender service=\"async_priority_normal\"/> </framework:routing> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $messenger->transport('async_priority_normal')->dsn('...'); $messenger->transport('image_transport')->dsn('...'); $messenger->routing('App\\Message\\UploadedImage') ->senders(['image_transport', 'async_priority_normal']); }; That's it! You can now consume each transport: # will only call ThumbnailUploadedImageHandler when handling the message $ php bin/console messenger:consume image_transport -vv $ php bin/console messenger:consume async_priority_normal -vv If a handler does *not* have from_transport config, it will be executed on *every* transport that the message is received from. Process Messages by Batches You can declare \"special\" handlers which will process messages by batch. By doing so, the handler will wait for a certain amount of messages to be pending before processing them. The declaration of a batch handler is done by implementing Symfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerInterface. The Symfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerTrait is also provided in order to ease the declaration of these special handlers:: use Symfony\\Component\\Messenger\\Handler\\Acknowledger; use Symfony\\Component\\Messenger\\Handler\\BatchHandlerInterface; use Symfony\\Component\\Messenger\\Handler\\BatchHandlerTrait; class MyBatchHandler implements BatchHandlerInterface { use BatchHandlerTrait; public function __invoke(MyMessage $message, ?Acknowledger $ack = null): mixed { return $this->handle($message, $ack); } private function process(array $jobs): void { foreach ($jobs as [$message, $ack]) { try { // Compute $result from $message... // Acknowledge the processing of the message $ack->ack($result); } catch (\\Throwable $e) { $ack->nack($e); } } } // Optionally, you can override some of the trait methods, such as the // `getBatchSize()` method, to specify your own batch size... private function getBatchSize(): int { return 100; } } When the $ack argument of __invoke() is null, the message is expected to be handled synchronously. Otherwise, __invoke() is expected to return the number of pending messages. The Symfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerTrait handles this for you.", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_24", "source": "messenger.rst", "text": "private function process(array $jobs): void { foreach ($jobs as [$message, $ack]) { try { // Compute $result from $message... // Acknowledge the processing of the message $ack->ack($result); } catch (\\Throwable $e) { $ack->nack($e); } } } // Optionally, you can override some of the trait methods, such as the // `getBatchSize()` method, to specify your own batch size... private function getBatchSize(): int { return 100; } } When the $ack argument of __invoke() is null, the message is expected to be handled synchronously. Otherwise, __invoke() is expected to return the number of pending messages. The Symfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerTrait handles this for you. By default, pending batches are flushed when the worker is idle as well as when it is stopped. Extending Messenger Envelopes & Stamps A message can be any PHP object. Sometimes, you may need to configure something extra about the message - like the way it should be handled inside AMQP or adding a delay before the message should be handled. You can do that by adding a \"stamp\" to your message:: use Symfony\\Component\\Messenger\\Envelope; use Symfony\\Component\\Messenger\\MessageBusInterface; use Symfony\\Component\\Messenger\\Stamp\\DelayStamp; public function index(MessageBusInterface $bus): void { // wait 5 seconds before processing $bus->dispatch(new SmsNotification('...'), [ new DelayStamp(5000), ]); // or explicitly create an Envelope $bus->dispatch(new Envelope(new SmsNotification('...'), [ new DelayStamp(5000), ])); // ... } Internally, each message is wrapped in an Envelope, which holds the message and stamps. You can create this manually or allow the message bus to do it. There are a variety of different stamps for different purposes and they're used internally to track information about a message - like the message bus that's handling it or if it's being retried after failure. Middleware What happens when you dispatch a message to a message bus depends on its collection of middleware and their order. By default, the middleware configured for each bus looks like this: #. add_bus_name_stamp_middleware - adds a stamp to record which bus this message was dispatched into; #. dispatch_after_current_bus- see messenger-transactional-messages; #. failed_message_processing_middleware - processes messages that are being retried via the failure transport to make them properly function as if they were being received from their original transport; #. Your own collection of middleware_; #. send_message - if routing is configured for the transport, this sends messages to that transport and stops the middleware chain; #. handle_message - calls the message handler(s) for the given message. These middleware names are actually shortcut names. The real service ids are prefixed with messenger.middleware. (e.g. messenger.middleware.handle_message). The middleware are executed when the message is dispatched but *also* again when a message is received via the worker (for messages that were sent to a transport to be handled asynchronously). Keep this in mind if you create your own middleware. You can add your own middleware to this list, or completely disable the default middleware and *only* include your own. If a middleware service is abstract, you can configure its constructor's arguments and a different instance will be created per bus. # config/packages/messenger.yaml framework: messenger: buses: messenger.bus.default: # disable the", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_25", "source": "messenger.rst", "text": "service ids are prefixed with messenger.middleware. (e.g. messenger.middleware.handle_message). The middleware are executed when the message is dispatched but *also* again when a message is received via the worker (for messages that were sent to a transport to be handled asynchronously). Keep this in mind if you create your own middleware. You can add your own middleware to this list, or completely disable the default middleware and *only* include your own. If a middleware service is abstract, you can configure its constructor's arguments and a different instance will be created per bus. # config/packages/messenger.yaml framework: messenger: buses: messenger.bus.default: # disable the default middleware default_middleware: false middleware: # use and configure parts of the default middleware you want - 'add_bus_name_stamp_middleware': ['messenger.bus.default'] # add your own services that implement Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface - 'App\\Middleware\\MyMiddleware' - 'App\\Middleware\\AnotherMiddleware' <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <!-- default-middleware: disable the default middleware --> <framework:bus name=\"messenger.bus.default\" default-middleware=\"false\"> <!-- use and configure parts of the default middleware you want --> <framework:middleware id=\"add_bus_name_stamp_middleware\"> <framework:argument>messenger.bus.default</framework:argument> </framework:middleware> <!-- add your own services that implement Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface --> <framework:middleware id=\"App\\Middleware\\MyMiddleware\"/> <framework:middleware id=\"App\\Middleware\\AnotherMiddleware\"/> </framework:bus> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $bus = $messenger->bus('messenger.bus.default') ->defaultMiddleware(false); // disable the default middleware // use and configure parts of the default middleware you want $bus->middleware()->id('add_bus_name_stamp_middleware')->arguments(['messenger.bus.default']); // add your own services that implement Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface $bus->middleware()->id('App\\Middleware\\MyMiddleware'); $bus->middleware()->id('App\\Middleware\\AnotherMiddleware'); }; If you have installed the MakerBundle, you can use the make:messenger-middleware command to bootstrap the creation of your own messenger middleware. Middleware for Doctrine If you use Doctrine in your app, a number of optional middleware exist that you may want to use: # config/packages/messenger.yaml framework: messenger: buses: command_bus: middleware: # each time a message is handled, the Doctrine connection # is \"pinged\" and reconnected if it's closed. Useful # if your workers run for a long time and the database # connection is sometimes lost - doctrine_ping_connection # After handling, the Doctrine connection is closed, # which can free up database connections in a worker, # instead of keeping them open forever - doctrine_close_connection # logs an error when a Doctrine transaction was opened but not closed - doctrine_open_transaction_logger # wraps all handlers in a single Doctrine transaction # handlers do not need to call flush() and an error # in any handler will cause a rollback - doctrine_transaction # or pass a different entity manager to any #- doctrine_transaction: ['custom'] <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:bus name=\"command_bus\"> <framework:middleware id=\"doctrine_transaction\"/> <framework:middleware id=\"doctrine_ping_connection\"/> <framework:middleware id=\"doctrine_close_connection\"/> <framework:middleware id=\"doctrine_open_transaction_logger\"/> <!-- or pass a different entity manager to any --> <!-- <framework:middleware id=\"doctrine_transaction\"> <framework:argument>custom</framework:argument> </framework:middleware> --> </framework:bus> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $bus = $messenger->bus('command_bus'); $bus->middleware()->id('doctrine_transaction'); $bus->middleware()->id('doctrine_ping_connection'); $bus->middleware()->id('doctrine_close_connection'); $bus->middleware()->id('doctrine_open_transaction_logger'); // Using another entity manager $bus->middleware()->id('doctrine_transaction') ->arguments(['custom']); }; Other Middlewares Add the router_context middleware if you need to generate absolute URLs in the", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_26", "source": "messenger.rst", "text": "a different entity manager to any #- doctrine_transaction: ['custom'] <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:bus name=\"command_bus\"> <framework:middleware id=\"doctrine_transaction\"/> <framework:middleware id=\"doctrine_ping_connection\"/> <framework:middleware id=\"doctrine_close_connection\"/> <framework:middleware id=\"doctrine_open_transaction_logger\"/> <!-- or pass a different entity manager to any --> <!-- <framework:middleware id=\"doctrine_transaction\"> <framework:argument>custom</framework:argument> </framework:middleware> --> </framework:bus> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $bus = $messenger->bus('command_bus'); $bus->middleware()->id('doctrine_transaction'); $bus->middleware()->id('doctrine_ping_connection'); $bus->middleware()->id('doctrine_close_connection'); $bus->middleware()->id('doctrine_open_transaction_logger'); // Using another entity manager $bus->middleware()->id('doctrine_transaction') ->arguments(['custom']); }; Other Middlewares Add the router_context middleware if you need to generate absolute URLs in the consumer (e.g. render a template with links). This middleware stores the original request context (i.e. the host, the HTTP port, etc.) which is needed when building absolute URLs. Add the validation middleware if you need to validate the message object using the Validator component before handling it. If validation fails, a ValidationFailedException will be thrown. The Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\ValidationStamp can be used to configure the validation groups. # config/packages/messenger.yaml framework: messenger: buses: command_bus: middleware: - router_context - validation <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:bus name=\"command_bus\"> <framework:middleware id=\"router_context\"/> <framework:middleware id=\"validation\"/> </framework:bus> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $bus = $messenger->bus('command_bus'); $bus->middleware()->id('router_context'); $bus->middleware()->id('validation'); }; Messenger Events In addition to middleware, Messenger also dispatches several events. You can create an event listener to hook into various parts of the process. For each, the event class is the event name: * Symfony\\\\Component\\\\Messenger\\\\Event\\\\SendMessageToTransportsEvent * Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageFailedEvent * Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageHandledEvent * Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageReceivedEvent * Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageRetriedEvent * Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerRateLimitedEvent * Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerRunningEvent * Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerStartedEvent * Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerStoppedEvent Additional Handler Arguments It's possible to have messenger pass additional data to the message handler using the Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\HandlerArgumentsStamp. Add this stamp to the envelope in a middleware and fill it with any additional data you want to have available in the handler:: // src/Messenger/AdditionalArgumentMiddleware.php namespace App\\Messenger; use Symfony\\Component\\Messenger\\Envelope; use Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface; use Symfony\\Component\\Messenger\\Middleware\\StackInterface; use Symfony\\Component\\Messenger\\Stamp\\HandlerArgumentsStamp; final class AdditionalArgumentMiddleware implements MiddlewareInterface { public function handle(Envelope $envelope, StackInterface $stack): Envelope { $envelope = $envelope->with(new HandlerArgumentsStamp([ $this->resolveAdditionalArgument($envelope->getMessage()), ])); return $stack->next()->handle($envelope, $stack); } private function resolveAdditionalArgument(object $message): mixed { // ... } } Then your handler will look like this:: // src/MessageHandler/SmsNotificationHandler.php namespace App\\MessageHandler; use App\\Message\\SmsNotification; final class SmsNotificationHandler { public function __invoke(SmsNotification $message, mixed $additionalArgument) { // ... } } Message Serializer For Custom Data Formats If you receive messages from other applications, it's possible that they are not exactly in the format you need. Not all applications will return a JSON message with body and headers fields. In those cases, you'll need to create a new message serializer implementing the Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Serialization\\\\SerializerInterface. Let's say you want to create a message decoder:: namespace App\\Messenger\\Serializer; use Symfony\\Component\\Messenger\\Envelope; use Symfony\\Component\\Messenger\\Transport\\Serialization\\SerializerInterface; class MessageWithTokenDecoder implements SerializerInterface { public function decode(array $encodedEnvelope): Envelope { try { // parse the data you received with your custom fields $data = $encodedEnvelope['data']; $data['token'] = $encodedEnvelope['token']; // other operations like getting information from stamps } catch (\\Throwable $throwable) {", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_27", "source": "messenger.rst", "text": "messages from other applications, it's possible that they are not exactly in the format you need. Not all applications will return a JSON message with body and headers fields. In those cases, you'll need to create a new message serializer implementing the Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Serialization\\\\SerializerInterface. Let's say you want to create a message decoder:: namespace App\\Messenger\\Serializer; use Symfony\\Component\\Messenger\\Envelope; use Symfony\\Component\\Messenger\\Transport\\Serialization\\SerializerInterface; class MessageWithTokenDecoder implements SerializerInterface { public function decode(array $encodedEnvelope): Envelope { try { // parse the data you received with your custom fields $data = $encodedEnvelope['data']; $data['token'] = $encodedEnvelope['token']; // other operations like getting information from stamps } catch (\\Throwable $throwable) { // wrap any exception that may occur in the envelope to send it to the failure transport return new Envelope($throwable); } return new Envelope($data); } public function encode(Envelope $envelope): array { // this decoder does not encode messages, but you can implement it by returning // an array with serialized stamps if you need to send messages in a custom format throw new \\LogicException('This serializer is only used for decoding messages.'); } } The next step is to tell Symfony to use this serializer in one or more of your transports: # config/packages/messenger.yaml framework: messenger: transports: my_transport: dsn: '%env(MY_TRANSPORT_DSN)%' serializer: 'App\\Messenger\\Serializer\\MessageWithTokenDecoder' <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:messenger> <framework:transport name=\"my_transport\" dsn=\"%env(MY_TRANSPORT_DSN)%\" serializer=\"App\\Messenger\\Serializer\\MessageWithTokenDecoder\"> <!-- ... --> </framework:transport> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use App\\Messenger\\Serializer\\MessageWithTokenDecoder; use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $messenger = $framework->messenger(); $messenger->transport('my_transport') ->dsn('%env(MY_TRANSPORT_DSN)%') ->serializer(MessageWithTokenDecoder::class); }; Multiple Buses, Command & Event Buses Messenger gives you a single message bus service by default. But, you can configure as many as you want, creating \"command\", \"query\" or \"event\" buses and controlling their middleware. A common architecture when building applications is to separate commands from queries. Commands are actions that do something and queries fetch data. This is called CQRS (Command Query Responsibility Segregation). See Martin Fowler's `article about CQRS`_ to learn more. This architecture could be used together with the Messenger component by defining multiple buses. A **command bus** is a little different from a **query bus**. For example, command buses usually don't provide any results and query buses are rarely asynchronous. You can configure these buses and their rules by using middleware. It might also be a good idea to separate actions from reactions by introducing an **event bus**. The event bus could have zero or more subscribers. framework: messenger: # The bus that is going to be injected when injecting MessageBusInterface default_bus: command.bus buses: command.bus: middleware: - validation - doctrine_transaction query.bus: middleware: - validation event.bus: default_middleware: enabled: true # set \"allow_no_handlers\" to true (default is false) to allow having # no handler configured for this bus without throwing an exception allow_no_handlers: false # set \"allow_no_senders\" to false (default is true) to throw an exception # if no sender is configured for this bus allow_no_senders: true middleware: - validation <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <!-- The bus", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_28", "source": "messenger.rst", "text": "framework: messenger: # The bus that is going to be injected when injecting MessageBusInterface default_bus: command.bus buses: command.bus: middleware: - validation - doctrine_transaction query.bus: middleware: - validation event.bus: default_middleware: enabled: true # set \"allow_no_handlers\" to true (default is false) to allow having # no handler configured for this bus without throwing an exception allow_no_handlers: false # set \"allow_no_senders\" to false (default is true) to throw an exception # if no sender is configured for this bus allow_no_senders: true middleware: - validation <!-- config/packages/messenger.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <!-- The bus that is going to be injected when injecting MessageBusInterface --> <framework:messenger default-bus=\"command.bus\"> <framework:bus name=\"command.bus\"> <framework:middleware id=\"validation\"/> <framework:middleware id=\"doctrine_transaction\"/> </framework:bus> <framework:bus name=\"query.bus\"> <framework:middleware id=\"validation\"/> </framework:bus> <framework:bus name=\"event.bus\"> <!-- set \"allow-no-handlers\" to true (default is false) to allow having no handler configured for this bus without throwing an exception --> <!-- set \"allow-no-senders\" to false (default is true) to throw an exception if no sender is configured for this bus --> <framework:default-middleware enabled=\"true\" allow-no-handlers=\"false\" allow-no-senders=\"true\"/> <framework:middleware id=\"validation\"/> </framework:bus> </framework:messenger> </framework:config> </container> // config/packages/messenger.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { // The bus that is going to be injected when injecting MessageBusInterface $framework->messenger()->defaultBus('command.bus'); $commandBus = $framework->messenger()->bus('command.bus'); $commandBus->middleware()->id('validation'); $commandBus->middleware()->id('doctrine_transaction'); $queryBus = $framework->messenger()->bus('query.bus'); $queryBus->middleware()->id('validation'); $eventBus = $framework->messenger()->bus('event.bus'); $eventBus->defaultMiddleware() ->enabled(true) // set \"allowNoHandlers\" to true (default is false) to allow having // no handler configured for this bus without throwing an exception ->allowNoHandlers(false) // set \"allowNoSenders\" to false (default is true) to throw an exception // if no sender is configured for this bus ->allowNoSenders(true) ; $eventBus->middleware()->id('validation'); }; This will create three new services: * command.bus: autowireable with the Symfony\\\\Component\\\\Messenger\\\\MessageBusInterface type-hint (because this is the default_bus); * query.bus: autowireable with MessageBusInterface $queryBus; * event.bus: autowireable with MessageBusInterface $eventBus. Restrict Handlers per Bus By default, each handler will be available to handle messages on *all* of your buses. To prevent dispatching a message to the wrong bus without an error, you can restrict each handler to a specific bus using the messenger.message_handler tag: # config/services.yaml services: App\\MessageHandler\\SomeCommandHandler: tags: [{ name: messenger.message_handler, bus: command.bus }] <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <service id=\"App\\MessageHandler\\SomeCommandHandler\"> <tag name=\"messenger.message_handler\" bus=\"command.bus\"/> </service> </services> </container> // config/services.php $container->services() ->set(App\\MessageHandler\\SomeCommandHandler::class) ->tag('messenger.message_handler', ['bus' => 'command.bus']); This way, the App\\MessageHandler\\SomeCommandHandler handler will only be known by the command.bus bus. You can also automatically add this tag to a number of classes by using the _instanceof service configuration . Using this, you can determine the message bus based on an implemented interface: # config/services.yaml services: # ... _instanceof: # all services implementing the CommandHandlerInterface # will be registered on the command.bus bus App\\MessageHandler\\CommandHandlerInterface: tags: - { name: messenger.message_handler, bus: command.bus } # while those implementing QueryHandlerInterface will be # registered on the query.bus bus App\\MessageHandler\\QueryHandlerInterface: tags: - { name: messenger.message_handler, bus: query.bus } <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... --> <!-- all services implementing the CommandHandlerInterface will be registered", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "messenger.rst_fixed_29", "source": "messenger.rst", "text": "a number of classes by using the _instanceof service configuration . Using this, you can determine the message bus based on an implemented interface: # config/services.yaml services: # ... _instanceof: # all services implementing the CommandHandlerInterface # will be registered on the command.bus bus App\\MessageHandler\\CommandHandlerInterface: tags: - { name: messenger.message_handler, bus: command.bus } # while those implementing QueryHandlerInterface will be # registered on the query.bus bus App\\MessageHandler\\QueryHandlerInterface: tags: - { name: messenger.message_handler, bus: query.bus } <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... --> <!-- all services implementing the CommandHandlerInterface will be registered on the command.bus bus --> <instanceof id=\"App\\MessageHandler\\CommandHandlerInterface\"> <tag name=\"messenger.message_handler\" bus=\"command.bus\"/> </instanceof> <!-- while those implementing QueryHandlerInterface will be registered on the query.bus bus --> <instanceof id=\"App\\MessageHandler\\QueryHandlerInterface\"> <tag name=\"messenger.message_handler\" bus=\"query.bus\"/> </instanceof> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\MessageHandler\\CommandHandlerInterface; use App\\MessageHandler\\QueryHandlerInterface; return function(ContainerConfigurator $container): void { $services = $container->services(); // ... // all services implementing the CommandHandlerInterface // will be registered on the command.bus bus $services->instanceof(CommandHandlerInterface::class) ->tag('messenger.message_handler', ['bus' => 'command.bus']); // while those implementing QueryHandlerInterface will be // registered on the query.bus bus $services->instanceof(QueryHandlerInterface::class) ->tag('messenger.message_handler', ['bus' => 'query.bus']); }; Debugging the Buses The debug:messenger command lists available messages & handlers per bus. You can also restrict the list to a specific bus by providing its name as an argument. $ php bin/console debug:messenger Messenger command.bus The following messages can be dispatched: App\\Message\\DummyCommand handled by App\\MessageHandler\\DummyCommandHandler App\\Message\\MultipleBusesMessage handled by App\\MessageHandler\\MultipleBusesMessageHandler query.bus The following messages can be dispatched: App\\Message\\DummyQuery handled by App\\MessageHandler\\DummyQueryHandler App\\Message\\MultipleBusesMessage handled by App\\MessageHandler\\MultipleBusesMessageHandler The command will also show the PHPDoc description of the message and handler classes. Redispatching a Message If you want to redispatch a message (using the same transport and envelope), create a new Symfony\\\\Component\\\\Messenger\\\\Message\\\\RedispatchMessage and dispatch it through your bus. Reusing the same SmsNotification example shown earlier:: // src/MessageHandler/SmsNotificationHandler.php namespace App\\MessageHandler; use App\\Message\\SmsNotification; use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler; use Symfony\\Component\\Messenger\\Message\\RedispatchMessage; use Symfony\\Component\\Messenger\\MessageBusInterface; #[AsMessageHandler] class SmsNotificationHandler { public function __construct(private MessageBusInterface $bus) { } public function __invoke(SmsNotification $message): void { // do something with the message // then redispatch it based on your own logic if ($needsRedispatch) { $this->bus->dispatch(new RedispatchMessage($message)); } } } The built-in Symfony\\\\Component\\\\Messenger\\\\Handler\\\\RedispatchMessageHandler will take care of this message to redispatch it through the same bus it was dispatched at first. You can also use the second argument of the RedispatchMessage constructor to provide transports to use when redispatching the message. Learn more :maxdepth: 1 :glob: /messenger/*", "title": "Messenger: Sync & Queued Message Handling", "category": "messenger"}
{"chunk_id": "performance.rst_fixed_0", "source": "performance.rst", "text": "Performance Symfony is fast, right out of the box. However, you can make it faster if you optimize your servers and your applications as explained in the following performance checklists. Performance Checklists Use these checklists to verify that your application and server are configured for maximum performance: * **Symfony Application Checklist**: #. Restrict the number of locales enabled in the application * **Production Server Checklist**: #. Dump the service container into a single file #. Use the OPcache byte code cache #. Configure OPcache for maximum performance #. Don't check PHP files timestamps #. Configure the PHP realpath Cache #. Optimize Composer Autoloader Restrict the Number of Locales Enabled in the Application Use the framework.enabled_locales option to only generate the translation files actually used in your application. Dump the Service Container into a Single File Symfony compiles the service container into multiple small files by default. Set this parameter to true to compile the entire container into a single file, which could improve performance when using \"class preloading\" in PHP 7.4 or newer versions: # config/services.yaml parameters: # ... .container.dumper.inline_factories: true <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters> <!-- ... --> <parameter key=\".container.dumper.inline_factories\">true</parameter> </parameters> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void { $container->parameters()->set('.container.dumper.inline_factories', true); }; The . prefix denotes a parameter that is only used during compilation of the container. See Configuration Parameters for more details. Use the OPcache Byte Code Cache OPcache stores the compiled PHP files to avoid having to recompile them for every request. There are some `byte code caches`_ available, but as of PHP 5.5, PHP comes with `OPcache`_ built-in. For older versions, the most widely used byte code cache is APC. Use the OPcache class preloading Starting from PHP 7.4, OPcache can compile and load classes at start-up and make them available to all requests until the server is restarted, improving performance significantly. During container compilation (e.g. when running the cache:clear command), Symfony generates a file with the list of classes to preload in the var/cache/ directory. Rather than use this file directly, use the config/preload.php file that is created when using Symfony Flex in your project : ; php.ini opcache.preload=/path/to/project/config/preload.php ; required for opcache.preload: opcache.preload_user=www-data If this file is missing, run this command to update the Symfony Flex recipe: composer recipes:update symfony/framework-bundle. Use the container.preload and container.no_preload service tags to define which classes should or should not be preloaded by PHP. Configure OPcache for Maximum Performance The default OPcache configuration is not suited for Symfony applications, so it's recommended to change these settings as follows: ; php.ini ; maximum memory that OPcache can use to store compiled PHP files opcache.memory_consumption=256 ; maximum number of files that can be stored in the cache opcache.max_accelerated_files=20000 Don't Check PHP Files Timestamps In production servers, PHP files should never change, unless a new application version is deployed. However, by default OPcache checks if cached files have changed their contents since they were cached. This check introduces some overhead that can", "title": "Performance", "category": "performance"}
{"chunk_id": "performance.rst_fixed_1", "source": "performance.rst", "text": "not be preloaded by PHP. Configure OPcache for Maximum Performance The default OPcache configuration is not suited for Symfony applications, so it's recommended to change these settings as follows: ; php.ini ; maximum memory that OPcache can use to store compiled PHP files opcache.memory_consumption=256 ; maximum number of files that can be stored in the cache opcache.max_accelerated_files=20000 Don't Check PHP Files Timestamps In production servers, PHP files should never change, unless a new application version is deployed. However, by default OPcache checks if cached files have changed their contents since they were cached. This check introduces some overhead that can be avoided as follows: ; php.ini opcache.validate_timestamps=0 After each deployment, you must empty and regenerate the cache of OPcache. Otherwise you won't see the updates made in the application. Given that in PHP, the CLI and the web processes don't share the same OPcache, you cannot clear the web server OPcache by executing some command in your terminal. These are some of the possible solutions: 1. Restart the web server; 2. Call the apc_clear_cache() or opcache_reset() functions via the web server (i.e. by having these in a script that you execute over the web); 3. Use the `cachetool`_ utility to control APC and OPcache from the CLI. Configure the PHP realpath Cache When a relative path is transformed into its real and absolute path, PHP caches the result to improve performance. Applications that open many PHP files, such as Symfony projects, should use at least these values: ; php.ini ; maximum memory allocated to store the results realpath_cache_size=4096K ; save the results for 10 minutes (600 seconds) realpath_cache_ttl=600 PHP disables the realpath cache when the `open_basedir`_ config option is enabled. Optimize Composer Autoloader The class loader used while developing the application is optimized to find new and changed classes. In production servers, PHP files should never change, unless a new application version is deployed. That's why you can optimize Composer's autoloader to scan the entire application once and build an optimized \"class map\", which is a big array of the locations of all the classes and it's stored in vendor/composer/autoload_classmap.php. Execute this command to generate the new class map (and make it part of your deployment process too): $ composer dump-autoload --no-dev --classmap-authoritative * --no-dev excludes the classes that are only needed in the development environment (i.e. require-dev dependencies and autoload-dev rules); * --classmap-authoritative creates a class map for PSR-0 and PSR-4 compatible classes used in your application and prevents Composer from scanning the file system for classes that are not found in the class map. (see: `Composer's autoloader optimization`_). Disable Dumping the Container as XML in Debug Mode In debug mode , Symfony generates an XML file with all the service container information (services, arguments, etc.) This XML file is used by various debugging commands such as debug:container and debug:autowiring. When the container grows larger and larger, so does the size of the file and the time to generate it. If the benefit of this XML file does not", "title": "Performance", "category": "performance"}
{"chunk_id": "performance.rst_fixed_2", "source": "performance.rst", "text": "and PSR-4 compatible classes used in your application and prevents Composer from scanning the file system for classes that are not found in the class map. (see: `Composer's autoloader optimization`_). Disable Dumping the Container as XML in Debug Mode In debug mode , Symfony generates an XML file with all the service container information (services, arguments, etc.) This XML file is used by various debugging commands such as debug:container and debug:autowiring. When the container grows larger and larger, so does the size of the file and the time to generate it. If the benefit of this XML file does not outweigh the decrease in performance, you can stop generating the file as follows: # config/services.yaml parameters: # ... debug.container.dump: false <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters> <!-- ... --> <parameter key=\"debug.container.dump\">false</parameter> </parameters> </container> // config/services.php // ... $container->parameters()->set('debug.container.dump', false); Profiling Symfony Applications Profiling with Blackfire `Blackfire`_ is the best tool to profile and optimize performance of Symfony applications during development, test and production. It's a commercial service, but provides a `full-featured demo`_. Profiling with Symfony Stopwatch Symfony provides a basic performance profiler in the development config environment . Click on the \"time panel\" of the web debug toolbar to see how much time Symfony spent on tasks such as making database queries and rendering templates. You can measure the execution time and memory consumption of your own code and display the result in the Symfony profiler thanks to the `Stopwatch component`_. When using autowiring , type-hint any controller or service argument with the Symfony\\\\Component\\\\Stopwatch\\\\Stopwatch class and Symfony will inject the debug.stopwatch service:: use Symfony\\Component\\Stopwatch\\Stopwatch; class DataExporter { public function __construct( private Stopwatch $stopwatch, ) { } public function export(): void { // the argument is the name of the \"profiling event\" $this->stopwatch->start('export-data'); // ...do things to export data... // reset the stopwatch to delete all the data measured so far // $this->stopwatch->reset(); $this->stopwatch->stop('export-data'); } } If the request calls this service during its execution, you'll see a new event called export-data in the Symfony profiler. The start(), stop() and getEvent() methods return a Symfony\\\\Component\\\\Stopwatch\\\\StopwatchEvent object that provides information about the current event, even while it's still running. This object can be converted to a string for a quick summary:: // ... dump((string) $this->stopwatch->getEvent('export-data')); // dumps e.g. '4.50 MiB - 26 ms' You can also profile your template code with the stopwatch Twig tag : {% stopwatch 'render-blog-posts' %} {% for post in blog_posts %} {# ... #} {% endfor %} {% endstopwatch %} Profiling Categories .................... Use the second optional argument of the start() method to define the category or tag of the event. This helps keep events organized by type:: $this->stopwatch->start('export-data', 'export'); Profiling Periods ................. A `real-world stopwatch`_ not only includes the start/stop button but also a \"lap button\" to measure each partial lap. This is exactly what the lap() method does, which stops an event and then restarts it immediately:: $this->stopwatch->start('process-data-records', 'export'); foreach ($records as $record) { // ... some code", "title": "Performance", "category": "performance"}
{"chunk_id": "performance.rst_fixed_3", "source": "performance.rst", "text": ": {% stopwatch 'render-blog-posts' %} {% for post in blog_posts %} {# ... #} {% endfor %} {% endstopwatch %} Profiling Categories .................... Use the second optional argument of the start() method to define the category or tag of the event. This helps keep events organized by type:: $this->stopwatch->start('export-data', 'export'); Profiling Periods ................. A `real-world stopwatch`_ not only includes the start/stop button but also a \"lap button\" to measure each partial lap. This is exactly what the lap() method does, which stops an event and then restarts it immediately:: $this->stopwatch->start('process-data-records', 'export'); foreach ($records as $record) { // ... some code goes here $this->stopwatch->lap('process-data-records'); } $event = $this->stopwatch->stop('process-data-records'); // $event->getDuration(), $event->getMemory(), etc. // Lap information is stored as \"periods\" within the event: // $event->getPeriods(); // Gets the last event period: // $event->getLastPeriod(); The getLastPeriod() method was introduced in Symfony 7.2. Profiling Sections .................. Sections are a way to split the profile timeline into groups. Example:: $this->stopwatch->openSection(); $this->stopwatch->start('validating-file', 'validation'); $this->stopwatch->stopSection('parsing'); $events = $this->stopwatch->getSectionEvents('parsing'); // later you can reopen a section passing its name to the openSection() method $this->stopwatch->openSection('parsing'); $this->stopwatch->start('processing-file'); $this->stopwatch->stopSection('parsing'); All events that don't belong to any named section are added to the special section called __root__. This way you can get all stopwatch events, even if you don't know their names, as follows:: use Symfony\\Component\\Stopwatch\\Stopwatch; foreach($this->stopwatch->getSectionEvents(Stopwatch::ROOT) as $event) { echo (string) $event; } The Stopwatch::ROOT constant as a shortcut for __root__ was introduced in Symfony 7.2. Learn more * /http_cache/varnish", "title": "Performance", "category": "performance"}
{"chunk_id": "routing.rst_fixed_0", "source": "routing.rst", "text": "Routing When your application receives a request, it calls a controller action to generate the response. The routing configuration defines which action to run for each incoming URL. It also provides other useful features, like generating SEO-friendly URLs (e.g. /read/intro-to-symfony instead of index.php?article_id=57). Creating Routes Routes can be configured in YAML, XML, PHP or using attributes. All formats provide the same features and performance, so choose your favorite. Symfony recommends attributes because it's convenient to put the route and controller in the same place. Creating Routes as Attributes PHP attributes allow you to define routes next to the code of the controllers associated to those routes. You need to add a bit of configuration to your project before using them. If your project uses Symfony Flex , this file is already created for you. Otherwise, create the following file manually: # config/routes/attributes.yaml controllers: resource: path: ../../src/Controller/ namespace: App\\Controller type: attribute kernel: resource: App\\Kernel type: attribute This configuration tells Symfony to look for routes defined as attributes on classes declared in the App\\Controller namespace and stored in the src/Controller/ directory which follows the PSR-4 standard. The kernel can act as a controller too, which is especially useful for small applications that use Symfony as a microframework. Suppose you want to define a route for the /blog URL in your application. To do so, create a controller class like the following: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { #[Route('/blog', name: 'blog_list')] public function list(): Response { // ... } } This configuration defines a route called blog_list that matches when the user requests the /blog URL. When the match occurs, the application runs the list() method of the BlogController class. The query string of a URL is not considered when matching routes. In this example, URLs like /blog?foo=bar and /blog?foo=bar&bar=foo will also match the blog_list route. If you define multiple PHP classes in the same file, Symfony only loads the routes of the first class, ignoring all the other routes. The route name (blog_list) is not important for now, but it will be essential later when generating URLs . You only have to keep in mind that each route name must be unique in the application. Creating Routes in YAML, XML or PHP Files Instead of defining routes in the controller classes, you can define them in a separate YAML, XML or PHP file. The main advantage is that they don't require any extra dependency. The main drawback is that you have to work with multiple files when checking the routing of some controller action. The following example shows how to define in YAML/XML/PHP a route called blog_list that associates the /blog URL with the list() action of the BlogController: # config/routes.yaml blog_list: path: /blog # the controller value has the format 'controller_class::method_name' controller: App\\Controller\\BlogController::list # if the action is implemented as the __invoke() method of the # controller class, you can skip the '::method_name' part: # controller: App\\Controller\\BlogController <!-- config/routes.xml --> <?xml version=\"1.0\"", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_1", "source": "routing.rst", "text": "The main advantage is that they don't require any extra dependency. The main drawback is that you have to work with multiple files when checking the routing of some controller action. The following example shows how to define in YAML/XML/PHP a route called blog_list that associates the /blog URL with the list() action of the BlogController: # config/routes.yaml blog_list: path: /blog # the controller value has the format 'controller_class::method_name' controller: App\\Controller\\BlogController::list # if the action is implemented as the __invoke() method of the # controller class, you can skip the '::method_name' part: # controller: App\\Controller\\BlogController <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <!-- the controller value has the format 'controller_class::method_name' --> <route id=\"blog_list\" path=\"/blog\" controller=\"App\\Controller\\BlogController::list\"/> <!-- if the action is implemented as the __invoke() method of the controller class, you can skip the '::method_name' part: controller=\"App\\Controller\\BlogController\"/> --> </routes> // config/routes.php use App\\Controller\\BlogController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void { $routes->add('blog_list', '/blog') // the controller value has the format [controller_class, method_name] ->controller([BlogController::class, 'list']) // if the action is implemented as the __invoke() method of the // controller class, you can skip the 'method_name' part: // ->controller(BlogController::class) ; }; By default, Symfony loads the routes defined in both YAML and PHP formats. If you define routes in XML format, you need to update the src/Kernel.php file . Matching HTTP Methods By default, routes match any HTTP verb (GET, POST, PUT, etc.) Use the methods option to restrict the verbs each route should respond to: // src/Controller/BlogApiController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogApiController extends AbstractController { #[Route('/api/posts/{id}', methods: ['GET', 'HEAD'])] public function show(int $id): Response { // ... return a JSON response with the post } #[Route('/api/posts/{id}', methods: ['PUT'])] public function edit(int $id): Response { // ... edit a post } } # config/routes.yaml api_post_show: path: /api/posts/{id} controller: App\\Controller\\BlogApiController::show methods: GET|HEAD api_post_edit: path: /api/posts/{id} controller: App\\Controller\\BlogApiController::edit methods: PUT <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"api_post_show\" path=\"/api/posts/{id}\" controller=\"App\\Controller\\BlogApiController::show\" methods=\"GET|HEAD\"/> <route id=\"api_post_edit\" path=\"/api/posts/{id}\" controller=\"App\\Controller\\BlogApiController::edit\" methods=\"PUT\"/> </routes> // config/routes.php use App\\Controller\\BlogApiController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void { $routes->add('api_post_show', '/api/posts/{id}') ->controller([BlogApiController::class, 'show']) ->methods(['GET', 'HEAD']) ; $routes->add('api_post_edit', '/api/posts/{id}') ->controller([BlogApiController::class, 'edit']) ->methods(['PUT']) ; }; HTML forms only support GET and POST methods. If you're calling a route with a different method from an HTML form, add a hidden field called _method with the method to use (e.g. <input type=\"hidden\" name=\"_method\" value=\"PUT\">). If you create your forms with Symfony Forms this is done automatically for you when the framework.http_method_override option is true. Matching Environments Use the env option to register a route only when the current configuration environment matches the given value: // src/Controller/DefaultController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class DefaultController extends AbstractController { #[Route('/tools', name: 'tools', env: 'dev')] public function developerTools(): Response { // ... } } # config/routes.yaml when@dev: tools: path: /tools controller: App\\Controller\\DefaultController::developerTools <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <when env=\"dev\"> <route id=\"tools\" path=\"/tools\" controller=\"App\\Controller\\DefaultController::developerTools\"/> </when> </routes> // config/routes.php", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_2", "source": "routing.rst", "text": "value=\"PUT\">). If you create your forms with Symfony Forms this is done automatically for you when the framework.http_method_override option is true. Matching Environments Use the env option to register a route only when the current configuration environment matches the given value: // src/Controller/DefaultController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class DefaultController extends AbstractController { #[Route('/tools', name: 'tools', env: 'dev')] public function developerTools(): Response { // ... } } # config/routes.yaml when@dev: tools: path: /tools controller: App\\Controller\\DefaultController::developerTools <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <when env=\"dev\"> <route id=\"tools\" path=\"/tools\" controller=\"App\\Controller\\DefaultController::developerTools\"/> </when> </routes> // config/routes.php use App\\Controller\\DefaultController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void { if('dev' === $routes->env()) { $routes->add('tools', '/tools') ->controller([DefaultController::class, 'developerTools']) ; } }; Matching Expressions Use the condition option if you need some route to match based on some arbitrary matching logic: // src/Controller/DefaultController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class DefaultController extends AbstractController { #[Route( '/contact', name: 'contact', condition: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\", // expressions can also include config parameters: // condition: \"request.headers.get('User-Agent') matches '%app.allowed_browsers%'\" )] public function contact(): Response { // ... } #[Route( '/posts/{id}', name: 'post_show', // expressions can retrieve route parameter values using the \"params\" variable condition: \"params['id'] < 1000\" )] public function showPost(int $id): Response { // ... return a JSON response with the post } } # config/routes.yaml contact: path: /contact controller: App\\Controller\\DefaultController::contact condition: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\" # expressions can also include configuration parameters: # condition: \"request.headers.get('User-Agent') matches '%app.allowed_browsers%'\" # expressions can even use environment variables: # condition: \"context.getHost() == env('APP_MAIN_HOST')\" post_show: path: /posts/{id} controller: App\\Controller\\DefaultController::showPost # expressions can retrieve route parameter values using the \"params\" variable condition: \"params['id'] < 1000\" <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"contact\" path=\"/contact\" controller=\"App\\Controller\\DefaultController::contact\"> <condition>context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'</condition> <!-- expressions can also include configuration parameters: --> <!-- <condition>request.headers.get('User-Agent') matches '%app.allowed_browsers%'</condition> --> <!-- expressions can even use environment variables: --> <!-- <condition>context.getHost() == env('APP_MAIN_HOST')</condition> --> </route> <route id=\"post_show\" path=\"/posts/{id}\" controller=\"App\\Controller\\DefaultController::showPost\"> <!-- expressions can retrieve route parameter values using the \"params\" variable --> <condition>params['id'] &lt; 1000</condition> </route> </routes> // config/routes.php use App\\Controller\\DefaultController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void { $routes->add('contact', '/contact') ->controller([DefaultController::class, 'contact']) ->condition('context.getMethod() in [\"GET\", \"HEAD\"] and request.headers.get(\"User-Agent\") matches \"/firefox/i\"') // expressions can also include configuration parameters: // ->condition('request.headers.get(\"User-Agent\") matches \"%app.allowed_browsers%\"') // expressions can even use environment variables: // ->condition('context.getHost() == env(\"APP_MAIN_HOST\")') ; $routes->add('post_show', '/posts/{id}') ->controller([DefaultController::class, 'showPost']) // expressions can retrieve route parameter values using the \"params\" variable ->condition('params[\"id\"] < 1000') ; }; The value of the condition option is an expression using any valid expression language syntax and can use any of these variables created by Symfony: context An instance of Symfony\\\\Component\\\\Routing\\\\RequestContext, which holds the most fundamental information about the route being matched. request The Symfony Request object that represents the current request. params An array of matched route parameters for the current route. You can also use these functions: env(string $name) Returns the value of a", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_3", "source": "routing.rst", "text": "// ->condition('context.getHost() == env(\"APP_MAIN_HOST\")') ; $routes->add('post_show', '/posts/{id}') ->controller([DefaultController::class, 'showPost']) // expressions can retrieve route parameter values using the \"params\" variable ->condition('params[\"id\"] < 1000') ; }; The value of the condition option is an expression using any valid expression language syntax and can use any of these variables created by Symfony: context An instance of Symfony\\\\Component\\\\Routing\\\\RequestContext, which holds the most fundamental information about the route being matched. request The Symfony Request object that represents the current request. params An array of matched route parameters for the current route. You can also use these functions: env(string $name) Returns the value of a variable using Environment Variable Processors service(string $alias) Returns a routing condition service. First, add the #[AsRoutingConditionService] attribute or routing.condition_service tag to the services that you want to use in route conditions:: use Symfony\\Bundle\\FrameworkBundle\\Routing\\Attribute\\AsRoutingConditionService; use Symfony\\Component\\HttpFoundation\\Request; #[AsRoutingConditionService(alias: 'route_checker')] class RouteChecker { public function check(Request $request): bool { // ... } } Then, use the service() function to refer to that service inside conditions:: // Controller (using an alias): #[Route(condition: \"service('route_checker').check(request)\")] // Or without alias: #[Route(condition: \"service('App\\\\\\Service\\\\\\RouteChecker').check(request)\")] Behind the scenes, expressions are compiled down to raw PHP. Because of this, using the condition key causes no extra overhead beyond the time it takes for the underlying PHP to execute. Conditions are *not* taken into account when generating URLs (which is explained later in this article). Debugging Routes As your application grows, you'll eventually have a *lot* of routes. Symfony includes some commands to help you debug routing issues. First, the debug:router command lists all your application routes in the same order in which Symfony evaluates them: $ php bin/console debug:router ---------------- ------- ------- ----- -------------------------------------------- Name Method Scheme Host Path ---------------- ------- ------- ----- -------------------------------------------- homepage ANY ANY ANY / contact GET ANY ANY /contact contact_process POST ANY ANY /contact article_show ANY ANY ANY /articles/{_locale}/{year}/{title}.{_format} blog ANY ANY ANY /blog/{page} blog_show ANY ANY ANY /blog/{slug} ---------------- ------- ------- ----- -------------------------------------------- # pass this option to also display all the defined route aliases $ php bin/console debug:router --show-aliases # pass this option to only display routes that match the given HTTP method # (you can use the special value ANY to see routes that match any method) $ php bin/console debug:router --method=GET $ php bin/console debug:router --method=ANY The --method option was introduced in Symfony 7.3. Pass the name (or part of the name) of some route to this argument to print the route details: $ php bin/console debug:router app_lucky_number | Property | Value | | Route Name | app_lucky_number | | Path | /lucky/number/{max} | | ... | ... | | Options | compiler_class: Symfony\\Component\\Routing\\RouteCompiler | | | utf8: true | The other command is called router:match and it shows which route will match the given URL. It's useful to find out why some URL is not executing the controller action that you expect: $ php bin/console router:match /lucky/number/8 [OK] Route \"app_lucky_number\" matches Route Parameters The previous examples defined routes where the URL never changes (e.g. /blog). However, it's common to define routes", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_4", "source": "routing.rst", "text": "details: $ php bin/console debug:router app_lucky_number | Property | Value | | Route Name | app_lucky_number | | Path | /lucky/number/{max} | | ... | ... | | Options | compiler_class: Symfony\\Component\\Routing\\RouteCompiler | | | utf8: true | The other command is called router:match and it shows which route will match the given URL. It's useful to find out why some URL is not executing the controller action that you expect: $ php bin/console router:match /lucky/number/8 [OK] Route \"app_lucky_number\" matches Route Parameters The previous examples defined routes where the URL never changes (e.g. /blog). However, it's common to define routes where some parts are variable. For example, the URL to display some blog post will probably include the title or slug (e.g. /blog/my-first-post or /blog/all-about-symfony). In Symfony routes, variable parts are wrapped in { }. For example, the route to display the blog post contents is defined as /blog/{slug}: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { // ... #[Route('/blog/{slug}', name: 'blog_show')] public function show(string $slug): Response { // $slug will equal the dynamic part of the URL // e.g. at /blog/yay-routing, then $slug='yay-routing' // ... } } # config/routes.yaml blog_show: path: /blog/{slug} controller: App\\Controller\\BlogController::show <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_show\" path=\"/blog/{slug}\" controller=\"App\\Controller\\BlogController::show\"/> </routes> // config/routes.php use App\\Controller\\BlogController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void { $routes->add('blog_show', '/blog/{slug}') ->controller([BlogController::class, 'show']) ; }; The name of the variable part ({slug} in this example) is used to create a PHP variable where that route content is stored and passed to the controller. If a user visits the /blog/my-first-post URL, Symfony executes the show() method in the BlogController class and passes a $slug = 'my-first-post' argument to the show() method. Routes can define any number of parameters, but each of them can only be used once on each route (e.g. /blog/posts-about-{category}/page/{pageNumber}). Parameters Validation Imagine that your application has a blog_show route (URL: /blog/{slug}) and a blog_list route (URL: /blog/{page}). Given that route parameters accept any value, there's no way to differentiate both routes. If the user requests /blog/my-first-post, both routes will match and Symfony will use the route which was defined first. To fix this, add some validation to the {page} parameter using the requirements option: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { #[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\\d+'])] public function list(int $page): Response { // ... } #[Route('/blog/{slug}', name: 'blog_show')] public function show(string $slug): Response { // ... } } # config/routes.yaml blog_list: path: /blog/{page} controller: App\\Controller\\BlogController::list requirements: page: '\\d+' blog_show: path: /blog/{slug} controller: App\\Controller\\BlogController::show <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_list\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::list\"> <requirement key=\"page\">\\d+</requirement> </route> <route id=\"blog_show\" path=\"/blog/{slug}\" controller=\"App\\Controller\\BlogController::show\"/> </routes> // config/routes.php use App\\Controller\\BlogController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('blog_list', '/blog/{page}') ->controller([BlogController::class, 'list']) ->requirements(['page' => '\\d+']) ; $routes->add('blog_show', '/blog/{slug}') ->controller([BlogController::class, 'show']) ; // ... }; The requirements option defines the `PHP regular expressions`_ that route", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_5", "source": "routing.rst", "text": "public function list(int $page): Response { // ... } #[Route('/blog/{slug}', name: 'blog_show')] public function show(string $slug): Response { // ... } } # config/routes.yaml blog_list: path: /blog/{page} controller: App\\Controller\\BlogController::list requirements: page: '\\d+' blog_show: path: /blog/{slug} controller: App\\Controller\\BlogController::show <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_list\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::list\"> <requirement key=\"page\">\\d+</requirement> </route> <route id=\"blog_show\" path=\"/blog/{slug}\" controller=\"App\\Controller\\BlogController::show\"/> </routes> // config/routes.php use App\\Controller\\BlogController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('blog_list', '/blog/{page}') ->controller([BlogController::class, 'list']) ->requirements(['page' => '\\d+']) ; $routes->add('blog_show', '/blog/{slug}') ->controller([BlogController::class, 'show']) ; // ... }; The requirements option defines the `PHP regular expressions`_ that route parameters must match for the entire route to match. In this example, \\d+ is a regular expression that matches a *digit* of any length. Now: ======================== ============= =============================== URL Route Parameters ======================== ============= =============================== /blog/2 blog_list $page = 2 /blog/my-first-post blog_show $slug = my-first-post ======================== ============= =============================== The Symfony\\\\Component\\\\Routing\\\\Requirement\\\\Requirement enum contains a collection of commonly used regular-expression constants such as digits, dates and UUIDs which can be used as route parameter requirements. // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; use Symfony\\Component\\Routing\\Requirement\\Requirement; class BlogController extends AbstractController { #[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => Requirement::DIGITS])] public function list(int $page): Response { // ... } } # config/routes.yaml blog_list: path: /blog/{page} controller: App\\Controller\\BlogController::list requirements: page: !php/const Symfony\\Component\\Routing\\Requirement\\Requirement::DIGITS // config/routes.php use App\\Controller\\BlogController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; use Symfony\\Component\\Routing\\Requirement\\Requirement; return static function (RoutingConfigurator $routes): void { $routes->add('blog_list', '/blog/{page}') ->controller([BlogController::class, 'list']) ->requirements(['page' => Requirement::DIGITS]) ; // ... }; Route requirements (and route paths too) can include configuration parameters , which is useful to define complex regular expressions once and reuse them in multiple routes. Parameters also support `PCRE Unicode properties`_, which are escape sequences that match generic character types. For example, \\p{Lu} matches any uppercase character in any language, \\p{Greek} matches any Greek characters, etc. If you prefer, requirements can be inlined in each parameter using the syntax {parameter_name<requirements>}. This feature makes configuration more concise, but it can decrease route readability when requirements are complex: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { #[Route('/blog/{page<\\d+>}', name: 'blog_list')] public function list(int $page): Response { // ... } } # config/routes.yaml blog_list: path: /blog/{page<\\d+>} controller: App\\Controller\\BlogController::list <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_list\" path=\"/blog/{page<\\d+>}\" controller=\"App\\Controller\\BlogController::list\"/> <!-- ... --> </routes> // config/routes.php use App\\Controller\\BlogController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('blog_list', '/blog/{page<\\d+>}') ->controller([BlogController::class, 'list']) ; // ... }; Optional Parameters In the previous example, the URL of blog_list is /blog/{page}. If users visit /blog/1, it will match. But if they visit /blog, it will **not** match. As soon as you add a parameter to a route, it must have a value. You can make blog_list once again match when the user visits /blog by adding a default value for the {page} parameter. When using attributes, default values are defined in the arguments of the controller action. In the other configuration formats they are defined with the defaults option: // src/Controller/BlogController.php namespace App\\Controller;", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_6", "source": "routing.rst", "text": "->controller([BlogController::class, 'list']) ; // ... }; Optional Parameters In the previous example, the URL of blog_list is /blog/{page}. If users visit /blog/1, it will match. But if they visit /blog, it will **not** match. As soon as you add a parameter to a route, it must have a value. You can make blog_list once again match when the user visits /blog by adding a default value for the {page} parameter. When using attributes, default values are defined in the arguments of the controller action. In the other configuration formats they are defined with the defaults option: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { #[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\\d+'])] public function list(int $page = 1): Response { // ... } } # config/routes.yaml blog_list: path: /blog/{page} controller: App\\Controller\\BlogController::list defaults: page: 1 requirements: page: '\\d+' blog_show: # ... <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_list\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::list\"> <default key=\"page\">1</default> <requirement key=\"page\">\\d+</requirement> </route> <!-- ... --> </routes> // config/routes.php use App\\Controller\\BlogController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('blog_list', '/blog/{page}') ->controller([BlogController::class, 'list']) ->defaults(['page' => 1]) ->requirements(['page' => '\\d+']) ; }; Now, when the user visits /blog, the blog_list route will match and $page will default to a value of 1. The default value is allowed to not match the requirement. You can have more than one optional parameter (e.g. /blog/{slug}/{page}), but everything after an optional parameter must be optional. For example, /{page}/blog is a valid path, but page will always be required (i.e. /blog will not match this route). If you want to always include some default value in the generated URL (for example to force the generation of /blog/1 instead of /blog in the previous example) add the ! character before the parameter name: /blog/{!page} As it happens with requirements, default values can also be inlined in each parameter using the syntax {parameter_name?default_value}. This feature is compatible with inlined requirements, so you can inline both in a single parameter: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { #[Route('/blog/{page<\\d+>?1}', name: 'blog_list')] public function list(int $page): Response { // ... } } # config/routes.yaml blog_list: path: /blog/{page<\\d+>?1} controller: App\\Controller\\BlogController::list <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_list\" path=\"/blog/{page<\\d+>?1}\" controller=\"App\\Controller\\BlogController::list\"/> <!-- ... --> </routes> // config/routes.php use App\\Controller\\BlogController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('blog_list', '/blog/{page<\\d+>?1}') ->controller([BlogController::class, 'list']) ; }; To give a null default value to any parameter, add nothing after the ? character (e.g. /blog/{page?}). If you do this, don't forget to update the types of the related controller arguments to allow passing null values (e.g. replace int $page by ?int $page). Priority Parameter Symfony evaluates routes in the order they are defined. If the path of a route matches many different patterns, it might prevent other routes from being matched. In YAML and XML you can move the route definitions up or down in the configuration file", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_7", "source": "routing.rst", "text": "(RoutingConfigurator $routes): void { $routes->add('blog_list', '/blog/{page<\\d+>?1}') ->controller([BlogController::class, 'list']) ; }; To give a null default value to any parameter, add nothing after the ? character (e.g. /blog/{page?}). If you do this, don't forget to update the types of the related controller arguments to allow passing null values (e.g. replace int $page by ?int $page). Priority Parameter Symfony evaluates routes in the order they are defined. If the path of a route matches many different patterns, it might prevent other routes from being matched. In YAML and XML you can move the route definitions up or down in the configuration file to control their priority. In routes defined as PHP attributes this is much harder to do, so you can set the optional priority parameter in those routes to control their priority: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { /** * This route has a greedy pattern and is defined first. */ #[Route('/blog/{slug}', name: 'blog_show')] public function show(string $slug): Response { // ... } /** * This route could not be matched without defining a higher priority than 0. */ #[Route('/blog/list', name: 'blog_list', priority: 2)] public function list(): Response { // ... } } The priority parameter expects an integer value. Routes with higher priority are sorted before routes with lower priority. The default value when it is not defined is 0. Parameter Conversion A common routing need is to convert the value stored in some parameter (e.g. an integer acting as the user ID) into another value (e.g. the object that represents the user). This feature is called a \"param converter\". Now, keep the previous route configuration, but change the arguments of the controller action. Instead of string $slug, add BlogPost $post:: // src/Controller/BlogController.php namespace App\\Controller; use App\\Entity\\BlogPost; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { // ... #[Route('/blog/{slug:post}', name: 'blog_show')] public function show(BlogPost $post): Response { // $post is the object whose slug matches the routing parameter // ... } } If your controller arguments include type-hints for objects (BlogPost in this case), the \"param converter\" makes a database request to find the object using the request parameters (slug in this case). If no object is found, Symfony generates a 404 response automatically. The {slug:post} syntax maps the route parameter named slug to the controller argument named $post. It also hints the \"param converter\" to look up the corresponding BlogPost object from the database using the slug. Route parameter mapping was introduced in Symfony 7.1. When mapping multiple entities from route parameters, name collisions can occur. In this example, the route tries to define two mappings: one for an author and one for a category; both using the same name parameter. This isn't allowed because the route ends up declaring name twice:: #[Route('/search-book/{name:author}/{name:category}')] Such routes should instead be defined using the following syntax:: #[Route('/search-book/{authorName:author.name}/{categoryName:category.name}')] This way, the route parameter names are unique (authorName and categoryName), and the \"param converter\" can correctly map them to controller arguments ($author and", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_8", "source": "routing.rst", "text": "corresponding BlogPost object from the database using the slug. Route parameter mapping was introduced in Symfony 7.1. When mapping multiple entities from route parameters, name collisions can occur. In this example, the route tries to define two mappings: one for an author and one for a category; both using the same name parameter. This isn't allowed because the route ends up declaring name twice:: #[Route('/search-book/{name:author}/{name:category}')] Such routes should instead be defined using the following syntax:: #[Route('/search-book/{authorName:author.name}/{categoryName:category.name}')] This way, the route parameter names are unique (authorName and categoryName), and the \"param converter\" can correctly map them to controller arguments ($author and $category), loading them both by their name. This more advanced style of route parameter mapping was introduced in Symfony 7.3. More advanced mappings can be achieved using the #[MapEntity] attribute. Check out the Doctrine param conversion documentation to learn how to customize the database queries used to fetch the object from the route parameter. Backed Enum Parameters You can use PHP `backed enumerations`_ as route parameters because Symfony will convert them automatically to their scalar values. // src/Controller/OrderController.php namespace App\\Controller; use App\\Enum\\OrderStatusEnum; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class OrderController extends AbstractController { #[Route('/orders/list/{status}', name: 'list_orders_by_status')] public function list(OrderStatusEnum $status = OrderStatusEnum::Paid): Response { // ... } } Special Parameters In addition to your own parameters, routes can include any of the following special parameters created by Symfony: _controller This parameter is used to determine which controller and action is executed when the route is matched. _format The matched value is used to set the \"request format\" of the Request object. This is used for such things as setting the Content-Type of the response (e.g. a json format translates into a Content-Type of application/json). _fragment Used to set the fragment identifier, which is the optional last part of a URL that starts with a # character and is used to identify a portion of a document. _locale Used to set the locale on the request. You can include these attributes (except _fragment) both in individual routes and in route imports. Symfony defines some special attributes with the same name (except for the leading underscore) so you can define them easier: // src/Controller/ArticleController.php namespace App\\Controller; // ... class ArticleController extends AbstractController { #[Route( path: '/articles/{_locale}/search.{_format}', locale: 'en', format: 'html', requirements: [ '_locale' => 'en|fr', '_format' => 'html|xml', ], )] public function search(): Response { } } # config/routes.yaml article_search: path: /articles/{_locale}/search.{_format} controller: App\\Controller\\ArticleController::search locale: en format: html requirements: _locale: en|fr _format: html|xml <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"article_search\" path=\"/articles/{_locale}/search.{_format}\" controller=\"App\\Controller\\ArticleController::search\" locale=\"en\" format=\"html\"> <requirement key=\"_locale\">en|fr</requirement> <requirement key=\"_format\">html|xml</requirement> </route> </routes> // config/routes.php namespace Symfony\\Component\\Routing\\Loader\\Configurator; use App\\Controller\\ArticleController; return static function (RoutingConfigurator $routes): void { $routes->add('article_show', '/articles/{_locale}/search.{_format}') ->controller([ArticleController::class, 'search']) ->locale('en') ->format('html') ->requirements([ '_locale' => 'en|fr', '_format' => 'html|xml', ]) ; }; Extra Parameters In the defaults option of a route you can optionally define parameters not included in the route configuration. This is useful to pass extra arguments to the controllers of the routes: // src/Controller/BlogController.php namespace", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_9", "source": "routing.rst", "text": "controller: App\\Controller\\ArticleController::search locale: en format: html requirements: _locale: en|fr _format: html|xml <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"article_search\" path=\"/articles/{_locale}/search.{_format}\" controller=\"App\\Controller\\ArticleController::search\" locale=\"en\" format=\"html\"> <requirement key=\"_locale\">en|fr</requirement> <requirement key=\"_format\">html|xml</requirement> </route> </routes> // config/routes.php namespace Symfony\\Component\\Routing\\Loader\\Configurator; use App\\Controller\\ArticleController; return static function (RoutingConfigurator $routes): void { $routes->add('article_show', '/articles/{_locale}/search.{_format}') ->controller([ArticleController::class, 'search']) ->locale('en') ->format('html') ->requirements([ '_locale' => 'en|fr', '_format' => 'html|xml', ]) ; }; Extra Parameters In the defaults option of a route you can optionally define parameters not included in the route configuration. This is useful to pass extra arguments to the controllers of the routes: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { #[Route('/blog/{page}', name: 'blog_index', defaults: ['page' => 1, 'title' => 'Hello world!'])] public function index(int $page, string $title): Response { // ... } } # config/routes.yaml blog_index: path: /blog/{page} controller: App\\Controller\\BlogController::index defaults: page: 1 title: \"Hello world!\" <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"blog_index\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::index\"> <default key=\"page\">1</default> <default key=\"title\">Hello world!</default> </route> </routes> // config/routes.php use App\\Controller\\BlogController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('blog_index', '/blog/{page}') ->controller([BlogController::class, 'index']) ->defaults([ 'page' => 1, 'title' => 'Hello world!', ]) ; }; Slash Characters in Route Parameters Route parameters can contain any values except the / slash character, because that's the character used to separate the different parts of the URLs. For example, if the token value in the /share/{token} route contains a / character, this route won't match. A possible solution is to change the parameter requirements to be more permissive: // src/Controller/DefaultController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class DefaultController extends AbstractController { #[Route('/share/{token}', name: 'share', requirements: ['token' => '.+'])] public function share($token): Response { // ... } } # config/routes.yaml share: path: /share/{token} controller: App\\Controller\\DefaultController::share requirements: token: .+ <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"share\" path=\"/share/{token}\" controller=\"App\\Controller\\DefaultController::share\"> <requirement key=\"token\">.+</requirement> </route> </routes> // config/routes.php use App\\Controller\\DefaultController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('share', '/share/{token}') ->controller([DefaultController::class, 'share']) ->requirements([ 'token' => '.+', ]) ; }; If the route defines several parameters and you apply this permissive regular expression to all of them, you might get unexpected results. For example, if the route definition is /share/{path}/{token} and both path and token accept /, then token will only get the last part and the rest is matched by path. If the route includes the special {_format} parameter, you shouldn't use the .+ requirement for the parameters that allow slashes. For example, if the pattern is /share/{token}.{_format} and {token} allows any character, the /share/foo/bar.json URL will consider foo/bar.json as the token and the format will be empty. This can be solved by replacing the .+ requirement by [^.]+ to allow any character except dots. Route Aliasing Route alias allows you to have multiple names for the same route and can be used to provide backward compatibility for routes that have been renamed. Let's say you have a route called product_show: // src/Controller/ProductController.php namespace App\\Controller;", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_10", "source": "routing.rst", "text": "the special {_format} parameter, you shouldn't use the .+ requirement for the parameters that allow slashes. For example, if the pattern is /share/{token}.{_format} and {token} allows any character, the /share/foo/bar.json URL will consider foo/bar.json as the token and the format will be empty. This can be solved by replacing the .+ requirement by [^.]+ to allow any character except dots. Route Aliasing Route alias allows you to have multiple names for the same route and can be used to provide backward compatibility for routes that have been renamed. Let's say you have a route called product_show: // src/Controller/ProductController.php namespace App\\Controller; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class ProductController { #[Route('/product/{id}', name: 'product_show')] public function show(): Response { // ... } } # config/routes.yaml product_show: path: /product/{id} controller: App\\Controller\\ProductController::show <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"product_show\" path=\"/product/{id}\" controller=\"App\\Controller\\ProductController::show\"/> </routes> // config/routes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('product_show', '/product/{id}') ->controller('App\\Controller\\ProductController::show'); }; Now, let's say you want to create a new route called product_details that acts exactly the same as product_show. Instead of duplicating the original route, you can create an alias for it. // src/Controller/ProductController.php namespace App\\Controller; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class ProductController { // the \"alias\" argument assigns an alternate name to this route; // the alias will point to the actual route \"product_show\" #[Route('/product/{id}', name: 'product_show', alias: ['product_details'])] public function show(): Response { // ... } } # config/routes.yaml product_show: path: /product/{id} controller: App\\Controller\\ProductController::show product_details: # \"alias\" option refers to the name of the route declared above alias: product_show <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"product_show\" path=\"/product/{id}\" controller=\"App\\Controller\\ProductController::show\"/> <!-- \"alias\" attribute value refers to the name of the route declared above --> <route id=\"product_details\" alias=\"product_show\"/> </routes> // config/routes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('product_show', '/product/{id}') ->controller('App\\Controller\\ProductController::show'); // second argument refers to the name of the route declared above $routes->alias('product_details', 'product_show'); }; Support for route aliases in PHP attributes was introduced in Symfony 7.3. In this example, both product_show and product_details routes can be used in the application and will produce the same result. YAML, XML, and PHP configuration formats are the only ways to define an alias for a route that you do not own. You can't do this when using PHP attributes. This allows you for example to use your own route name for URL generation, while still targeting a route defined by a third-party bundle. The alias and the original route do not need to be declared in the same file or format. Deprecating Route Aliases Route aliases can be used to provide backward compatibility for routes that have been renamed. Now, let's say you want to replace the product_show route in favor of product_details and mark the old one as deprecated. In the previous example, the alias product_details was pointing to product_show route. To mark the product_show route as deprecated, you need to \"switch\" the alias. The product_show become the alias, and will now point to the", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_11", "source": "routing.rst", "text": "a route defined by a third-party bundle. The alias and the original route do not need to be declared in the same file or format. Deprecating Route Aliases Route aliases can be used to provide backward compatibility for routes that have been renamed. Now, let's say you want to replace the product_show route in favor of product_details and mark the old one as deprecated. In the previous example, the alias product_details was pointing to product_show route. To mark the product_show route as deprecated, you need to \"switch\" the alias. The product_show become the alias, and will now point to the product_details route. This way, the product_show alias could be deprecated. // src/Controller/ProductController.php namespace App\\Controller; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\DeprecatedAlias; use Symfony\\Component\\Routing\\Attribute\\Route; class ProductController { // this outputs the following generic deprecation message: // Since acme/package 1.2: The \"product_show\" route alias is deprecated. You should stop using it, as it will be removed in the future. #[Route('/product/{id}', name: 'product_details', alias: new DeprecatedAlias( aliasName: 'product_show', package: 'acme/package', version: '1.2', ), )] // Or, you can also define a custom deprecation message (%alias_id% placeholder is available) #[Route('/product/{id}', name: 'product_details', alias: new DeprecatedAlias( aliasName: 'product_show', package: 'acme/package', version: '1.2', message: 'The \"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead.', ), )] public function show(): Response { // ... } } # Move the concrete route definition under product_details product_details: path: /product/{id} controller: App\\Controller\\ProductController::show # Define the alias and the deprecation under the product_show definition product_show: alias: product_details # this outputs the following generic deprecation message: # Since acme/package 1.2: The \"product_show\" route alias is deprecated. You should stop using it, as it will be removed in the future. deprecated: package: 'acme/package' version: '1.2' # or # you can define a custom deprecation message (%alias_id% placeholder is available) deprecated: package: 'acme/package' version: '1.2' message: 'The \"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead.' <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <!-- Move the concrete route definition under product_details --> <route id=\"product_details\" path=\"/product/{id}\" controller=\"App\\Controller\\ProductController::show\"/> <!-- Define the alias and the deprecation under the product_show definition --> <route id=\"product_show\" alias=\"product_details\"> <!-- this outputs the following generic deprecation message: Since acme/package 1.2: The \"product_show\" route alias is deprecated. You should stop using it, as it will be removed in the future. --> <deprecated package=\"acme/package\" version=\"1.2\"/> <!-- or --> <!-- you can define a custom deprecation message (%alias_id% placeholder is available) --> <deprecated package=\"acme/package\" version=\"1.2\"> The \"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead. </deprecated> </route> </routes> $routes->add('product_details', '/product/{id}') ->controller('App\\Controller\\ProductController::show'); $routes->alias('product_show', 'product_details') // this outputs the following generic deprecation message: // Since acme/package 1.2: The \"product_show\" route alias is deprecated. You should stop using it, as it will be removed in the future. ->deprecate('acme/package', '1.2', '') // or // you can define a custom deprecation message (%alias_id% placeholder is available) ->deprecate( 'acme/package', '1.2', 'The \"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead.' ) ; The DeprecatedAlias class for PHP attributes was introduced in Symfony 7.3. In this example, every time the product_show alias is", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_12", "source": "routing.rst", "text": "\"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead. </deprecated> </route> </routes> $routes->add('product_details', '/product/{id}') ->controller('App\\Controller\\ProductController::show'); $routes->alias('product_show', 'product_details') // this outputs the following generic deprecation message: // Since acme/package 1.2: The \"product_show\" route alias is deprecated. You should stop using it, as it will be removed in the future. ->deprecate('acme/package', '1.2', '') // or // you can define a custom deprecation message (%alias_id% placeholder is available) ->deprecate( 'acme/package', '1.2', 'The \"%alias_id%\" route alias is deprecated. Please use \"product_details\" instead.' ) ; The DeprecatedAlias class for PHP attributes was introduced in Symfony 7.3. In this example, every time the product_show alias is used, a deprecation warning is triggered, advising you to stop using this route and prefer using product_details. The message is actually a message template, which replaces occurrences of the %alias_id% placeholder by the route alias name. You **must** have at least one occurrence of the %alias_id% placeholder in your template. Route Groups and Prefixes It's common for a group of routes to share some options (e.g. all routes related to the blog start with /blog) That's why Symfony includes a feature to share route configuration. When defining routes as attributes, put the common configuration in the #[Route] attribute of the controller class. In other routing formats, define the common configuration using options when importing the routes. // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; #[Route('/blog', requirements: ['_locale' => 'en|es|fr'], name: 'blog_')] class BlogController extends AbstractController { #[Route('/{_locale}', name: 'index')] public function index(): Response { // ... } #[Route('/{_locale}/posts/{slug}', name: 'show')] public function show(string $slug): Response { // ... } } # config/routes/attributes.yaml controllers: resource: '../../src/Controller/' type: attribute # this is added to the beginning of all imported route URLs prefix: '/blog' # this is added to the beginning of all imported route names name_prefix: 'blog_' # these requirements are added to all imported routes requirements: _locale: 'en|es|fr' # An imported route with an empty URL will become \"/blog/\" # Uncomment this option to make that URL \"/blog\" instead # trailing_slash_on_root: false # you can optionally exclude some files/subdirectories when loading attributes # (the value must be a string or an array of PHP glob patterns) # exclude: '../../src/Controller/{Debug*Controller.php}' <!-- config/routes/attributes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <!-- the 'prefix' value is added to the beginning of all imported route URLs the 'name-prefix' value is added to the beginning of all imported route names the 'exclude' option defines the files or subdirectories ignored when loading attributes (the value must be a PHP glob pattern and you can repeat this option any number of times) --> <import resource=\"../../src/Controller/\" type=\"attribute\" prefix=\"/blog\" name-prefix=\"blog_\" exclude=\"../../src/Controller/{Debug*Controller.php}\"> <!-- these requirements are added to all imported routes --> <requirement key=\"_locale\">en|es|fr</requirement> </import> <!-- An imported route with an empty URL will become \"/blog/\" Uncomment this option to make that URL \"/blog\" instead --> <import resource=\"../../src/Controller/\" type=\"attribute\" prefix=\"/blog\" trailing-slash-on-root=\"false\"> <!-- ... --> </import> </routes> // config/routes/attributes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->import( '../../src/Controller/', 'attribute', false, // the optional fourth argument", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_13", "source": "routing.rst", "text": "'exclude' option defines the files or subdirectories ignored when loading attributes (the value must be a PHP glob pattern and you can repeat this option any number of times) --> <import resource=\"../../src/Controller/\" type=\"attribute\" prefix=\"/blog\" name-prefix=\"blog_\" exclude=\"../../src/Controller/{Debug*Controller.php}\"> <!-- these requirements are added to all imported routes --> <requirement key=\"_locale\">en|es|fr</requirement> </import> <!-- An imported route with an empty URL will become \"/blog/\" Uncomment this option to make that URL \"/blog\" instead --> <import resource=\"../../src/Controller/\" type=\"attribute\" prefix=\"/blog\" trailing-slash-on-root=\"false\"> <!-- ... --> </import> </routes> // config/routes/attributes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->import( '../../src/Controller/', 'attribute', false, // the optional fourth argument is used to exclude some files // or subdirectories when loading attributes // (the value must be a string or an array of PHP glob patterns) '../../src/Controller/{Debug*Controller.php}' ) // this is added to the beginning of all imported route URLs ->prefix('/blog') // An imported route with an empty URL will become \"/blog/\" // Pass FALSE as the second argument to make that URL \"/blog\" instead // ->prefix('/blog', false) // this is added to the beginning of all imported route names ->namePrefix('blog_') // these requirements are added to all imported routes ->requirements(['_locale' => 'en|es|fr']) ; }; The exclude option only works when the resource value is a glob string. If you use a regular string (e.g. '../src/Controller') the exclude value will be ignored. In this example, the route of the index() action will be called blog_index and its URL will be /blog/{_locale}. The route of the show() action will be called blog_show and its URL will be /blog/{_locale}/posts/{slug}. Both routes will also validate that the _locale parameter matches the regular expression defined in the class attribute. If any of the prefixed routes defines an empty path, Symfony adds a trailing slash to it. In the previous example, an empty path prefixed with /blog will result in the /blog/ URL. If you want to avoid this behavior, set the trailing_slash_on_root option to false (this option is not available when using PHP attributes): # config/routes/attributes.yaml controllers: resource: '../../src/Controller/' type: attribute prefix: '/blog' trailing_slash_on_root: false # ... <!-- config/routes/attributes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"../../src/Controller/\" type=\"attribute\" prefix=\"/blog\" name-prefix=\"blog_\" trailing-slash-on-root=\"false\" exclude=\"../../src/Controller/{DebugEmailController}.php\"> <!-- ... --> </import> </routes> // config/routes/attributes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->import('../../src/Controller/', 'attribute') // the second argument is the $trailingSlashOnRoot option ->prefix('/blog', false) // ... ; }; Symfony can import routes from different sources and you can even create your own route loader. Getting the Route Name and Parameters The Request object created by Symfony stores all the route configuration (such as the name and parameters) in the \"request attributes\". You can get this information in a controller via the Request object:: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { #[Route('/blog', name: 'blog_list')] public function list(Request $request): Response { $routeName = $request->attributes->get('_route'); $routeParameters = $request->attributes->get('_route_params'); // use this to get all the available attributes (not only routing ones): $allAttributes = $request->attributes->all(); // ... }", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_14", "source": "routing.rst", "text": "sources and you can even create your own route loader. Getting the Route Name and Parameters The Request object created by Symfony stores all the route configuration (such as the name and parameters) in the \"request attributes\". You can get this information in a controller via the Request object:: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class BlogController extends AbstractController { #[Route('/blog', name: 'blog_list')] public function list(Request $request): Response { $routeName = $request->attributes->get('_route'); $routeParameters = $request->attributes->get('_route_params'); // use this to get all the available attributes (not only routing ones): $allAttributes = $request->attributes->all(); // ... } } In services, you can get this information by injecting the RequestStack service . In templates, use the Twig global app variable to get the current route name (app.current_route) and its parameters (app.current_route_parameters). Special Routes Symfony defines some special controllers to render templates and redirect to other routes from the route configuration so you don't have to create a controller action. Rendering a Template Directly from a Route Read the section about rendering a template from a route in the main article about Symfony templates. Redirecting to URLs and Routes Directly from a Route Use the RedirectController to redirect to other routes and URLs: # config/routes.yaml doc_shortcut: path: /doc controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController defaults: route: 'doc_page' # optionally you can define some arguments passed to the route page: 'index' version: 'current' # redirections are temporary by default (code 302) but you can make them permanent (code 301) permanent: true # add this to keep the original query string parameters when redirecting keepQueryParams: true # add this to keep the HTTP method when redirecting. The redirect status changes # * for temporary redirects, it uses the 307 status code instead of 302 # * for permanent redirects, it uses the 308 status code instead of 301 keepRequestMethod: true # add this to remove all original route attributes when redirecting ignoreAttributes: true # or specify which attributes to ignore: # ignoreAttributes: ['offset', 'limit'] legacy_doc: path: /legacy/doc controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController defaults: # this value can be an absolute path or an absolute URL path: 'https://legacy.example.com/doc' permanent: true <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"doc_shortcut\" path=\"/doc\" controller=\"Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\"> <default key=\"route\">doc_page</default> <!-- optionally you can define some arguments passed to the route --> <default key=\"page\">index</default> <default key=\"version\">current</default> <!-- redirections are temporary by default (code 302) but you can make them permanent (code 301)--> <default key=\"permanent\">true</default> <!-- add this to keep the original query string parameters when redirecting --> <default key=\"keepQueryParams\">true</default> <!-- add this to keep the HTTP method when redirecting. The redirect status changes: * for temporary redirects, it uses the 307 status code instead of 302 * for permanent redirects, it uses the 308 status code instead of 301 --> <default key=\"keepRequestMethod\">true</default> </route> <route id=\"legacy_doc\" path=\"/legacy/doc\" controller=\"Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\"> <!-- this value can be an absolute path or an absolute URL --> <default key=\"path\">https://legacy.example.com/doc</default> <!-- redirections are temporary by default (code 302) but you can make them permanent (code 301)--> <default key=\"permanent\">true</default> </route>", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_15", "source": "routing.rst", "text": "301)--> <default key=\"permanent\">true</default> <!-- add this to keep the original query string parameters when redirecting --> <default key=\"keepQueryParams\">true</default> <!-- add this to keep the HTTP method when redirecting. The redirect status changes: * for temporary redirects, it uses the 307 status code instead of 302 * for permanent redirects, it uses the 308 status code instead of 301 --> <default key=\"keepRequestMethod\">true</default> </route> <route id=\"legacy_doc\" path=\"/legacy/doc\" controller=\"Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\"> <!-- this value can be an absolute path or an absolute URL --> <default key=\"path\">https://legacy.example.com/doc</default> <!-- redirections are temporary by default (code 302) but you can make them permanent (code 301)--> <default key=\"permanent\">true</default> </route> </routes> // config/routes.php use App\\Controller\\DefaultController; use Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('doc_shortcut', '/doc') ->controller(RedirectController::class) ->defaults([ 'route' => 'doc_page', // optionally you can define some arguments passed to the route 'page' => 'index', 'version' => 'current', // redirections are temporary by default (code 302) but you can make them permanent (code 301) 'permanent' => true, // add this to keep the original query string parameters when redirecting 'keepQueryParams' => true, // add this to keep the HTTP method when redirecting. The redirect status changes: // * for temporary redirects, it uses the 307 status code instead of 302 // * for permanent redirects, it uses the 308 status code instead of 301 'keepRequestMethod' => true, ]) ; $routes->add('legacy_doc', '/legacy/doc') ->controller(RedirectController::class) ->defaults([ // this value can be an absolute path or an absolute URL 'path' => 'https://legacy.example.com/doc', // redirections are temporary by default (code 302) but you can make them permanent (code 301) 'permanent' => true, ]) ; }; Symfony also provides some utilities to redirect inside controllers Redirecting URLs with Trailing Slashes ...................................... Historically, URLs have followed the UNIX convention of adding trailing slashes for directories (e.g. https://example.com/foo/) and removing them to refer to files (https://example.com/foo). Although serving different contents for both URLs is OK, nowadays it's common to treat both URLs as the same URL and redirect between them. Symfony follows this logic to redirect between URLs with and without trailing slashes (but only for GET and HEAD requests): ========== ======================================== ========================================== Route URL If the requested URL is /foo If the requested URL is /foo/ ========== ======================================== ========================================== /foo It matches (200 status response) It makes a 301 redirect to /foo /foo/ It makes a 301 redirect to /foo/ It matches (200 status response) ========== ======================================== ========================================== Sub-Domain Routing Routes can configure a host option to require that the HTTP host of the incoming requests matches some specific value. In the following example, both routes match the same path (/) but one of them only responds to a specific host name: // src/Controller/MainController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class MainController extends AbstractController { #[Route('/', name: 'mobile_homepage', host: 'm.example.com')] public function mobileHomepage(): Response { // ... } #[Route('/', name: 'homepage')] public function homepage(): Response { // ... } } # config/routes.yaml mobile_homepage: path: / host: m.example.com controller: App\\Controller\\MainController::mobileHomepage homepage: path: / controller: App\\Controller\\MainController::homepage <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\"", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_16", "source": "routing.rst", "text": "option to require that the HTTP host of the incoming requests matches some specific value. In the following example, both routes match the same path (/) but one of them only responds to a specific host name: // src/Controller/MainController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class MainController extends AbstractController { #[Route('/', name: 'mobile_homepage', host: 'm.example.com')] public function mobileHomepage(): Response { // ... } #[Route('/', name: 'homepage')] public function homepage(): Response { // ... } } # config/routes.yaml mobile_homepage: path: / host: m.example.com controller: App\\Controller\\MainController::mobileHomepage homepage: path: / controller: App\\Controller\\MainController::homepage <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"mobile_homepage\" path=\"/\" host=\"m.example.com\" controller=\"App\\Controller\\MainController::mobileHomepage\"/> <route id=\"homepage\" path=\"/\" controller=\"App\\Controller\\MainController::homepage\"/> </routes> // config/routes.php use App\\Controller\\MainController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('mobile_homepage', '/') ->controller([MainController::class, 'mobileHomepage']) ->host('m.example.com') ; $routes->add('homepage', '/') ->controller([MainController::class, 'homepage']) ; }; The value of the host option can include parameters (which is useful in multi-tenant applications) and these parameters can be validated too with requirements: // src/Controller/MainController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class MainController extends AbstractController { #[Route( '/', name: 'mobile_homepage', host: '{subdomain}.example.com', defaults: ['subdomain' => 'm'], requirements: ['subdomain' => 'm|mobile'], )] public function mobileHomepage(): Response { // ... } #[Route('/', name: 'homepage')] public function homepage(): Response { // ... } } # config/routes.yaml mobile_homepage: path: / host: \"{subdomain}.example.com\" controller: App\\Controller\\MainController::mobileHomepage defaults: subdomain: m requirements: subdomain: m|mobile homepage: path: / controller: App\\Controller\\MainController::homepage <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"mobile_homepage\" path=\"/\" host=\"{subdomain}.example.com\" controller=\"App\\Controller\\MainController::mobileHomepage\"> <default key=\"subdomain\">m</default> <requirement key=\"subdomain\">m|mobile</requirement> </route> <route id=\"homepage\" path=\"/\" controller=\"App\\Controller\\MainController::homepage\"/> </routes> // config/routes.php use App\\Controller\\MainController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('mobile_homepage', '/') ->controller([MainController::class, 'mobileHomepage']) ->host('{subdomain}.example.com') ->defaults([ 'subdomain' => 'm', ]) ->requirements([ 'subdomain' => 'm|mobile', ]) ; $routes->add('homepage', '/') ->controller([MainController::class, 'homepage']) ; }; In the above example, the subdomain parameter defines a default value because otherwise you need to include a subdomain value each time you generate a URL using these routes. You can also set the host option when importing routes to make all of them require that host name. When using sub-domain routing, you must set the Host HTTP headers in functional tests or routes won't match:: $crawler = $client->request( 'GET', '/', [], [], ['HTTP_HOST' => 'm.example.com'] // or get the value from some configuration parameter: // ['HTTP_HOST' => 'm.'.$client->getContainer()->getParameter('domain')] ); You can also use the inline defaults and requirements format in the host option: {subdomain<m|mobile>?m}.example.com Localized Routes (i18n) If your application is translated into multiple languages, each route can define a different URL per each translation locale . This avoids the need for duplicating routes, which also reduces the potential bugs: // src/Controller/CompanyController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class CompanyController extends AbstractController { #[Route(path: [ 'en' => '/about-us', 'nl' => '/over-ons' ], name: 'about_us')] public function about(): Response { // ... } } # config/routes.yaml about_us: path: en: /about-us nl: /over-ons controller: App\\Controller\\CompanyController::about <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"about_us\" controller=\"App\\Controller\\CompanyController::about\"> <path locale=\"en\">/about-us</path> <path locale=\"nl\">/over-ons</path> </route>", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_17", "source": "routing.rst", "text": "Routes (i18n) If your application is translated into multiple languages, each route can define a different URL per each translation locale . This avoids the need for duplicating routes, which also reduces the potential bugs: // src/Controller/CompanyController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class CompanyController extends AbstractController { #[Route(path: [ 'en' => '/about-us', 'nl' => '/over-ons' ], name: 'about_us')] public function about(): Response { // ... } } # config/routes.yaml about_us: path: en: /about-us nl: /over-ons controller: App\\Controller\\CompanyController::about <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"about_us\" controller=\"App\\Controller\\CompanyController::about\"> <path locale=\"en\">/about-us</path> <path locale=\"nl\">/over-ons</path> </route> </routes> // config/routes.php use App\\Controller\\CompanyController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('about_us', [ 'en' => '/about-us', 'nl' => '/over-ons', ]) ->controller([CompanyController::class, 'about']) ; }; When using PHP attributes for localized routes, you have to use the path named parameter to specify the array of paths. When a localized route is matched, Symfony uses the same locale automatically during the entire request. When the application uses full \"language + territory\" locales (e.g. fr_FR, fr_BE), if the URLs are the same in all related locales, routes can use only the language part (e.g. fr) to avoid repeating the same URLs. A common requirement for internationalized applications is to prefix all routes with a locale. This can be done by defining a different prefix for each locale (and setting an empty prefix for your default locale if you prefer it): # config/routes/attributes.yaml controllers: resource: '../../src/Controller/' type: attribute prefix: en: '' # don't prefix URLs for English, the default locale nl: '/nl' <!-- config/routes/attributes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"../../src/Controller/\" type=\"attribute\"> <!-- don't prefix URLs for English, the default locale --> <prefix locale=\"en\"></prefix> <prefix locale=\"nl\">/nl</prefix> </import> </routes> // config/routes/attributes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->import('../../src/Controller/', 'attribute') ->prefix([ // don't prefix URLs for English, the default locale 'en' => '', 'nl' => '/nl', ]) ; }; If a route being imported includes the special _locale parameter in its own definition, Symfony will only import it for that locale and not for the other configured locale prefixes. E.g. if a route contains locale: 'en' in its definition and it's being imported with en (prefix: empty) and nl (prefix: /nl) locales, that route will be available only in en locale and not in nl. Another common requirement is to host the website on a different domain according to the locale. This can be done by defining a different host for each locale. # config/routes/attributes.yaml controllers: resource: '../../src/Controller/' type: attribute host: en: 'www.example.com' nl: 'www.example.nl' <!-- config/routes/attributes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"../../src/Controller/\" type=\"attribute\"> <host locale=\"en\">www.example.com</host> <host locale=\"nl\">www.example.nl</host> </import> </routes> // config/routes/attributes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->import('../../src/Controller/', 'attribute') ->host([ 'en' => 'www.example.com', 'nl' => 'www.example.nl', ]) ; }; Stateless Routes Sometimes, when an HTTP response should be cached, it is important to ensure that can happen. However, whenever a session is started during a", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_18", "source": "routing.rst", "text": "different domain according to the locale. This can be done by defining a different host for each locale. # config/routes/attributes.yaml controllers: resource: '../../src/Controller/' type: attribute host: en: 'www.example.com' nl: 'www.example.nl' <!-- config/routes/attributes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"../../src/Controller/\" type=\"attribute\"> <host locale=\"en\">www.example.com</host> <host locale=\"nl\">www.example.nl</host> </import> </routes> // config/routes/attributes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->import('../../src/Controller/', 'attribute') ->host([ 'en' => 'www.example.com', 'nl' => 'www.example.nl', ]) ; }; Stateless Routes Sometimes, when an HTTP response should be cached, it is important to ensure that can happen. However, whenever a session is started during a request, Symfony turns the response into a private non-cacheable response. For details, see /http_cache. Routes can configure a stateless boolean option in order to declare that the session shouldn't be used when matching a request: // src/Controller/MainController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\Routing\\Attribute\\Route; class MainController extends AbstractController { #[Route('/', name: 'homepage', stateless: true)] public function homepage(): Response { // ... } } # config/routes.yaml homepage: controller: App\\Controller\\MainController::homepage path: / stateless: true <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"homepage\" controller=\"App\\Controller\\MainController::homepage\" path=\"/\" stateless=\"true\"/> </routes> // config/routes.php use App\\Controller\\MainController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('homepage', '/') ->controller([MainController::class, 'homepage']) ->stateless() ; }; Now, if the session is used, the application will report it based on your kernel.debug parameter: * enabled: will throw an Symfony\\\\Component\\\\HttpKernel\\\\Exception\\\\UnexpectedSessionUsageException exception * disabled: will log a warning It will help you understand and hopefully fixing unexpected behavior in your application. Generating URLs Routing systems are bidirectional: 1. they associate URLs with controllers (as explained in the previous sections); 2. they generate URLs for a given route. Generating URLs from routes allows you to not write the <a href=\"...\"> values manually in your HTML templates. Also, if the URL of some route changes, you only have to update the route configuration and all links will be updated. To generate a URL, you need to specify the name of the route (e.g. blog_show) and the values of the parameters defined by the route (e.g. slug = my-blog-post). For that reason each route has an internal name that must be unique in the application. If you don't set the route name explicitly with the name option, Symfony generates an automatic name based on the controller and action. Symfony declares route aliases based on the FQCN if the target class has an __invoke() method that adds a route **and** if the target class added one route exactly. Symfony also automatically adds an alias for every method that defines only one route. Consider the following class:: // src/Controller/MainController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\Routing\\Attribute\\Route; final class MainController extends AbstractController { #[Route('/', name: 'homepage')] public function homepage(): Response { // ... } } Symfony will add a route alias named App\\Controller\\MainController::homepage. Generating URLs in Controllers If your controller extends from the AbstractController , use the generateUrl() helper:: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface; class BlogController extends AbstractController { #[Route('/blog',", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_19", "source": "routing.rst", "text": "method that adds a route **and** if the target class added one route exactly. Symfony also automatically adds an alias for every method that defines only one route. Consider the following class:: // src/Controller/MainController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\Routing\\Attribute\\Route; final class MainController extends AbstractController { #[Route('/', name: 'homepage')] public function homepage(): Response { // ... } } Symfony will add a route alias named App\\Controller\\MainController::homepage. Generating URLs in Controllers If your controller extends from the AbstractController , use the generateUrl() helper:: // src/Controller/BlogController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface; class BlogController extends AbstractController { #[Route('/blog', name: 'blog_list')] public function list(): Response { // generate a URL with no route arguments $signUpPage = $this->generateUrl('sign_up'); // generate a URL with route arguments $userProfilePage = $this->generateUrl('user_profile', [ 'username' => $user->getUserIdentifier(), ]); // generated URLs are \"absolute paths\" by default. Pass a third optional // argument to generate different URLs (e.g. an \"absolute URL\") $signUpPage = $this->generateUrl('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL); // when a route is localized, Symfony uses by default the current request locale // pass a different '_locale' value if you want to set the locale explicitly $signUpPageInDutch = $this->generateUrl('sign_up', ['_locale' => 'nl']); // ... } } If you pass to the generateUrl() method some parameters that are not part of the route definition, they are included in the generated URL as a query string:: $this->generateUrl('blog', ['page' => 2, 'category' => 'Symfony']); // the 'blog' route only defines the 'page' parameter; the generated URL is: // /blog/2?category=Symfony While objects are converted to string when used as placeholders, they are not converted when used as extra parameters. So, if you're passing an object (e.g. an Uuid) as value of an extra parameter, you need to explicitly convert it to a string:: $this->generateUrl('blog', ['uuid' => (string) $entity->getUuid()]); If your controller does not extend from AbstractController, you'll need to fetch services in your controller and follow the instructions of the next section. Generating URLs in Services Inject the router Symfony service into your own services and use its generate() method. When using service autowiring you only need to add an argument in the service constructor and type-hint it with the Symfony\\\\Component\\\\Routing\\\\Generator\\\\UrlGeneratorInterface class:: // src/Service/SomeService.php namespace App\\Service; use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface; class SomeService { public function __construct( private UrlGeneratorInterface $urlGenerator, ) { } public function someMethod(): void { // ... // generate a URL with no route arguments $signUpPage = $this->urlGenerator->generate('sign_up'); // generate a URL with route arguments $userProfilePage = $this->urlGenerator->generate('user_profile', [ 'username' => $user->getUserIdentifier(), ]); // generated URLs are \"absolute paths\" by default. Pass a third optional // argument to generate different URLs (e.g. an \"absolute URL\") $signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL); // when a route is localized, Symfony uses by default the current request locale // pass a different '_locale' value if you want to set the locale explicitly $signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']); } } Generating URLs in Templates Read the section about creating links between pages in the main article about Symfony templates. Generating URLs in JavaScript If your JavaScript", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_20", "source": "routing.rst", "text": "with route arguments $userProfilePage = $this->urlGenerator->generate('user_profile', [ 'username' => $user->getUserIdentifier(), ]); // generated URLs are \"absolute paths\" by default. Pass a third optional // argument to generate different URLs (e.g. an \"absolute URL\") $signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL); // when a route is localized, Symfony uses by default the current request locale // pass a different '_locale' value if you want to set the locale explicitly $signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']); } } Generating URLs in Templates Read the section about creating links between pages in the main article about Symfony templates. Generating URLs in JavaScript If your JavaScript code is included in a Twig template, you can use the path() and url() Twig functions to generate the URLs and store them in JavaScript variables. The escape() filter is needed to escape any non-JavaScript-safe values: <script> const route = \"{{ path('blog_show', {slug: 'my-blog-post'})|escape('js') }}\"; </script> If you need to generate URLs dynamically or if you are using pure JavaScript code, this solution doesn't work. In those cases, consider using the `FOSJsRoutingBundle`_. Generating URLs in Commands Generating URLs in commands works the same as generating URLs in services . The only difference is that commands are not executed in the HTTP context. Therefore, if you generate absolute URLs, you'll get http://localhost/ as the host name instead of your real host name. The solution is to configure the default_uri option to define the \"request context\" used by commands when they generate URLs: # config/packages/routing.yaml framework: router: # ... default_uri: 'https://example.org/my/path/' <!-- config/packages/routing.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:router default-uri=\"https://example.org/my/path/\"> <!-- ... --> </framework:router> </framework:config> </container> // config/packages/routing.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->router()->defaultUri('https://example.org/my/path/'); }; Now you'll get the expected results when generating URLs in your commands:: // src/Command/MyCommand.php namespace App\\Command; use Symfony\\Component\\Console\\Attribute\\AsCommand; use Symfony\\Component\\Console\\Style\\SymfonyStyle; use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface; // ... #[AsCommand(name: 'app:my-command')] class MyCommand { public function __construct( private UrlGeneratorInterface $urlGenerator, ) { } public function __invoke(SymfonyStyle $io): int { // generate a URL with no route arguments $signUpPage = $this->urlGenerator->generate('sign_up'); // generate a URL with route arguments $userProfilePage = $this->urlGenerator->generate('user_profile', [ 'username' => $user->getUserIdentifier(), ]); // by default, generated URLs are \"absolute paths\". Pass a third optional // argument to generate different URIs (e.g. an \"absolute URL\") $signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL); // when a route is localized, Symfony uses by default the current request locale // pass a different '_locale' value if you want to set the locale explicitly $signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']); // ... } } By default, the URLs generated for web assets use the same default_uri value, but you can change it with the asset.request_context.base_path and asset.request_context.secure container parameters. Checking if a Route Exists In highly dynamic applications, it may be necessary to check whether a route exists before using it to generate a URL. In those cases, don't use the Symfony\\\\Component\\\\Routing\\\\Router::getRouteCollection method because that regenerates the routing cache and slows down the application. Instead, try to generate the URL and catch the", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_21", "source": "routing.rst", "text": "different '_locale' value if you want to set the locale explicitly $signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']); // ... } } By default, the URLs generated for web assets use the same default_uri value, but you can change it with the asset.request_context.base_path and asset.request_context.secure container parameters. Checking if a Route Exists In highly dynamic applications, it may be necessary to check whether a route exists before using it to generate a URL. In those cases, don't use the Symfony\\\\Component\\\\Routing\\\\Router::getRouteCollection method because that regenerates the routing cache and slows down the application. Instead, try to generate the URL and catch the Symfony\\\\Component\\\\Routing\\\\Exception\\\\RouteNotFoundException thrown when the route doesn't exist:: use Symfony\\Component\\Routing\\Exception\\RouteNotFoundException; // ... try { $url = $this->router->generate($routeName, $routeParameters); } catch (RouteNotFoundException $e) { // the route is not defined... } Forcing HTTPS on Generated URLs If your server runs behind a proxy that terminates SSL, make sure to configure Symfony to work behind a proxy The configuration for the scheme is only used for non-HTTP requests. The schemes option together with incorrect proxy configuration will lead to a redirect loop. By default, generated URLs use the same HTTP scheme as the current request. In console commands, where there is no HTTP request, URLs use http by default. You can change this per command (via the router's getContext() method) or globally with these configuration parameters: # config/services.yaml parameters: router.request_context.scheme: 'https' asset.request_context.secure: true <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <parameters> <parameter key=\"router.request_context.scheme\">https</parameter> <parameter key=\"asset.request_context.secure\">true</parameter> </parameters> </container> // config/services.php $container->parameters() ->set('router.request_context.scheme', 'https') ->set('asset.request_context.secure', true) ; Outside of console commands, use the schemes option to define the scheme of each route explicitly: // src/Controller/SecurityController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class SecurityController extends AbstractController { #[Route('/login', name: 'login', schemes: ['https'])] public function login(): Response { // ... } } # config/routes.yaml login: path: /login controller: App\\Controller\\SecurityController::login schemes: [https] <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"login\" path=\"/login\" schemes=\"https\" controller=\"App\\Controller\\SecurityController::login\"/> </routes> // config/routes.php use App\\Controller\\SecurityController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->add('login', '/login') ->controller([SecurityController::class, 'login']) ->schemes(['https']) ; }; The URL generated for the login route will always use HTTPS. This means that when using the path() Twig function to generate URLs, you may get an absolute URL instead of a relative URL if the HTTP scheme of the original request is different from the scheme used by the route: {# if the current scheme is HTTPS, generates a relative URL: /login #} {{ path('login') }} {# if the current scheme is HTTP, generates an absolute URL to change the scheme: https://example.com/login #} {{ path('login') }} The scheme requirement is also enforced for incoming requests. If you try to access the /login URL with HTTP, you will automatically be redirected to the same URL, but with the HTTPS scheme. If you want to force a group of routes to use HTTPS, you can define the default scheme when importing them. The following example forces HTTPS on all routes defined as", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_22", "source": "routing.rst", "text": "{# if the current scheme is HTTPS, generates a relative URL: /login #} {{ path('login') }} {# if the current scheme is HTTP, generates an absolute URL to change the scheme: https://example.com/login #} {{ path('login') }} The scheme requirement is also enforced for incoming requests. If you try to access the /login URL with HTTP, you will automatically be redirected to the same URL, but with the HTTPS scheme. If you want to force a group of routes to use HTTPS, you can define the default scheme when importing them. The following example forces HTTPS on all routes defined as attributes: # config/routes/attributes.yaml controllers: resource: '../../src/Controller/' type: attribute schemes: [https] <!-- config/routes/attributes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"../../src/Controller/\" type=\"attribute\" schemes=\"https\"/> </routes> // config/routes/attributes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->import('../../src/Controller/', 'attribute') ->schemes(['https']) ; }; The Security component provides another way to enforce HTTP or HTTPS via the requires_channel setting. Signing URIs A signed URI is an URI that includes a hash value that depends on the contents of the URI. This way, you can later check the integrity of the signed URI by recomputing its hash value and comparing it with the hash included in the URI. Symfony provides a utility to sign URIs via the Symfony\\\\Component\\\\HttpFoundation\\\\UriSigner service, which you can inject in your services or controllers:: // src/Service/SomeService.php namespace App\\Service; use Symfony\\Component\\HttpFoundation\\UriSigner; class SomeService { public function __construct( private UriSigner $uriSigner, ) { } public function someMethod(): void { // ... // generate a URL yourself or get it somehow... $url = 'https://example.com/foo/bar?sort=desc'; // sign the URL (it adds a query parameter called '_hash') $signedUrl = $this->uriSigner->sign($url); // $url = 'https://example.com/foo/bar?sort=desc&_hash=e4a21b9' // check the URL signature $uriSignatureIsValid = $this->uriSigner->check($signedUrl); // $uriSignatureIsValid = true // if you have access to the current Request object, you can use this // other method to pass the entire Request object instead of the URI: $uriSignatureIsValid = $this->uriSigner->checkRequest($request); } } For security reasons, it's common to make signed URIs expire after some time (e.g. when using them to reset user credentials). By default, signed URIs don't expire, but you can define an expiration date/time using the $expiration argument of Symfony\\\\Component\\\\HttpFoundation\\\\UriSigner::sign:: // src/Service/SomeService.php namespace App\\Service; use Symfony\\Component\\HttpFoundation\\UriSigner; class SomeService { public function __construct( private UriSigner $uriSigner, ) { } public function someMethod(): void { // ... // generate a URL yourself or get it somehow... $url = 'https://example.com/foo/bar?sort=desc'; // sign the URL with an explicit expiration date $signedUrl = $this->uriSigner->sign($url, new \\DateTimeImmutable('2050-01-01')); // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=2524608000&_hash=e4a21b9' // if you pass a \\DateInterval, it will be added from now to get the expiration date $signedUrl = $this->uriSigner->sign($url, new \\DateInterval('PT10S')); // valid for 10 seconds from now // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=1712414278&_hash=e4a21b9' // you can also use a timestamp in seconds $signedUrl = $this->uriSigner->sign($url, 4070908800); // timestamp for the date 2099-01-01 // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=4070908800&_hash=e4a21b9' } } The expiration date/time is included in the signed URIs as a timestamp via the _expiration query parameter. The feature to add an", "title": "Routing", "category": "routing"}
{"chunk_id": "routing.rst_fixed_23", "source": "routing.rst", "text": "= 'https://example.com/foo/bar?sort=desc'; // sign the URL with an explicit expiration date $signedUrl = $this->uriSigner->sign($url, new \\DateTimeImmutable('2050-01-01')); // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=2524608000&_hash=e4a21b9' // if you pass a \\DateInterval, it will be added from now to get the expiration date $signedUrl = $this->uriSigner->sign($url, new \\DateInterval('PT10S')); // valid for 10 seconds from now // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=1712414278&_hash=e4a21b9' // you can also use a timestamp in seconds $signedUrl = $this->uriSigner->sign($url, 4070908800); // timestamp for the date 2099-01-01 // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=4070908800&_hash=e4a21b9' } } The expiration date/time is included in the signed URIs as a timestamp via the _expiration query parameter. The feature to add an expiration date for a signed URI was introduced in Symfony 7.1. If you need to know the reason why a signed URI is invalid, you can use the verify() method which throws exceptions on failure:: use Symfony\\Component\\HttpFoundation\\Exception\\ExpiredSignedUriException; use Symfony\\Component\\HttpFoundation\\Exception\\UnsignedUriException; use Symfony\\Component\\HttpFoundation\\Exception\\UnverifiedSignedUriException; // ... try { $uriSigner->verify($uri); // $uri can be a string or Request object // the URI is valid } catch (UnsignedUriException) { // the URI isn't signed } catch (UnverifiedSignedUriException) { // the URI is signed but the signature is invalid } catch (ExpiredSignedUriException) { // the URI is signed but expired } The verify() method was introduced in Symfony 7.3. If symfony/clock is installed, it will be used to create and verify expirations. This allows you to mock the current time in your tests . Support for Symfony Clock in UriSigner was introduced in Symfony 7.3. Troubleshooting Here are some common errors you might see while working with routing: Controller \"App\\\\Controller\\\\BlogController::show()\" requires that you provide a value for the \"$slug\" argument. This happens when your controller method has an argument (e.g. $slug):: public function show(string $slug): Response { // ... } But your route path does *not* have a {slug} parameter (e.g. it is /blog/show). Add a {slug} to your route path: /blog/show/{slug} or give the argument a default value (i.e. $slug = null). Some mandatory parameters are missing (\"slug\") to generate a URL for route \"blog_show\". This means that you're trying to generate a URL to the blog_show route but you are *not* passing a slug value (which is required, because it has a {slug} parameter in the route path). To fix this, pass a slug value when generating the route:: $this->generateUrl('blog_show', ['slug' => 'slug-value']); or, in Twig: {{ path('blog_show', {slug: 'slug-value'}) }} Learn more about Routing :maxdepth: 1 :glob: routing/*", "title": "Routing", "category": "routing"}
{"chunk_id": "security.rst_fixed_0", "source": "security.rst", "text": "Security Symfony provides many tools to secure your application. Some HTTP-related security tools, like secure session cookies and CSRF protection are provided by default. The SecurityBundle, which you will learn about in this guide, provides all authentication and authorization features needed to secure your application. To get started, install the SecurityBundle: $ composer require symfony/security-bundle If you have Symfony Flex installed, this also creates a security.yaml configuration file for you: # config/packages/security.yaml security: # https://symfony.com/doc/current/security.html#registering-the-user-hashing-passwords password_hashers: Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface: 'auto' # https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers providers: users_in_memory: { memory: null } firewalls: dev: pattern: ^/(_(profiler|wdt)|css|images|js)/ security: false main: lazy: true provider: users_in_memory # activate different ways to authenticate # https://symfony.com/doc/current/security.html#firewalls-authentication # https://symfony.com/doc/current/security/impersonating_user.html # switch_user: true # An easy way to control access for large sections of your site # Note: Only the *first* access control that matches will be used access_control: # - { path: ^/admin, roles: ROLE_ADMIN } # - { path: ^/profile, roles: ROLE_USER } That's a lot of config! In the next sections, the three main elements are discussed: `The User`_ (providers) Any secured section of your application needs some concept of a user. The user provider loads users from any storage (e.g. the database) based on a \"user identifier\" (e.g. the user's email address); `The Firewall`_ & `Authenticating Users`_ (firewalls) The firewall is the core of securing your application. Every request within the firewall is checked if it needs an authenticated user. The firewall also takes care of authenticating this user (e.g. using a login form); `Access Control (Authorization)`_ (access_control) Using access control and the authorization checker, you control the required permissions to perform a specific action or visit a specific URL. The User Permissions in Symfony are always linked to a user object. If you need to secure (parts of) your application, you need to create a user class. This is a class that implements Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\UserInterface. This is often a Doctrine entity, but you can also use a dedicated Security user class. The easiest way to generate a user class is using the make:user command from the `MakerBundle`_: $ php bin/console make:user The name of the security user class (e.g. User) [User]: > User Do you want to store user data in the database (via Doctrine)? (yes/no) [yes]: > yes Enter a property name that will be the unique \"display\" name for the user (e.g. email, username, uuid) [email]: > email Will this app need to hash/check user passwords? Choose No if passwords are not needed or will be checked/hashed by some other system (e.g. a single sign-on server). Does this app need to hash/check user passwords? (yes/no) [yes]: > yes created: src/Entity/User.php created: src/Repository/UserRepository.php updated: src/Entity/User.php updated: config/packages/security.yaml // src/Entity/User.php namespace App\\Entity; use App\\Repository\\UserRepository; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface; use Symfony\\Component\\Security\\Core\\User\\UserInterface; #[ORM\\Entity(repositoryClass: UserRepository::class)] class User implements UserInterface, PasswordAuthenticatedUserInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] private int $id; #[ORM\\Column(type: 'string', length: 180, unique: true)] private ?string $email; #[ORM\\Column(type: 'json')] private array $roles = []; #[ORM\\Column(type: 'string')] private string $password; public function getId(): ?int { return $this->id; } public function getEmail():", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_1", "source": "security.rst", "text": "No if passwords are not needed or will be checked/hashed by some other system (e.g. a single sign-on server). Does this app need to hash/check user passwords? (yes/no) [yes]: > yes created: src/Entity/User.php created: src/Repository/UserRepository.php updated: src/Entity/User.php updated: config/packages/security.yaml // src/Entity/User.php namespace App\\Entity; use App\\Repository\\UserRepository; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface; use Symfony\\Component\\Security\\Core\\User\\UserInterface; #[ORM\\Entity(repositoryClass: UserRepository::class)] class User implements UserInterface, PasswordAuthenticatedUserInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] private int $id; #[ORM\\Column(type: 'string', length: 180, unique: true)] private ?string $email; #[ORM\\Column(type: 'json')] private array $roles = []; #[ORM\\Column(type: 'string')] private string $password; public function getId(): ?int { return $this->id; } public function getEmail(): ?string { return $this->email; } public function setEmail(string $email): self { $this->email = $email; return $this; } /** * The public representation of the user (e.g. a username, an email address, etc.) * * @see UserInterface */ public function getUserIdentifier(): string { return (string) $this->email; } /** * @see UserInterface */ public function getRoles(): array { $roles = $this->roles; // guarantee every user at least has ROLE_USER $roles[] = 'ROLE_USER'; return array_unique($roles); } public function setRoles(array $roles): self { $this->roles = $roles; return $this; } /** * @see PasswordAuthenticatedUserInterface */ public function getPassword(): string { return $this->password; } public function setPassword(string $password): self { $this->password = $password; return $this; } // [...] } Starting in `MakerBundle`_: v1.57.0 - You can pass either --with-uuid or --with-ulid to make:user. Leveraging Symfony's Uid Component , this generates a User entity with the id type as Uuid or Ulid instead of int. If your user is a Doctrine entity, like in the example above, don't forget to create the tables by creating and running a migration : $ php bin/console make:migration $ php bin/console doctrine:migrations:migrate Starting in `MakerBundle`_: v1.56.0 - Passing --formatted to make:migration generates a nice and tidy migration file. Loading the User: The User Provider Besides creating the entity, the make:user command also adds config for a user provider in your security configuration: # config/packages/security.yaml security: # ... providers: app_user_provider: entity: class: App\\Entity\\User property: email <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <provider name=\"app_user_provider\"> <entity class=\"App\\Entity\\User\" property=\"email\"/> </provider> </config> </srv:container> // config/packages/security.php use App\\Entity\\User; use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $security->provider('app_user_provider') ->entity() ->class(User::class) ->property('email') ; }; This user provider knows how to (re)load users from a storage (e.g. a database) based on a \"user identifier\" (e.g. the user's email address or username). The configuration above uses Doctrine to load the User entity using the email property as \"user identifier\". User providers are used in a couple places during the security lifecycle: **Load the User based on an identifier** During login (or any other authenticator), the provider loads the user based on the user identifier. Some other features, like user impersonation and Remember Me also use this. **Reload the User from the session** At the beginning of each request, the user is loaded from the session (unless your firewall is stateless). The provider \"refreshes\" the user", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_2", "source": "security.rst", "text": "(e.g. the user's email address or username). The configuration above uses Doctrine to load the User entity using the email property as \"user identifier\". User providers are used in a couple places during the security lifecycle: **Load the User based on an identifier** During login (or any other authenticator), the provider loads the user based on the user identifier. Some other features, like user impersonation and Remember Me also use this. **Reload the User from the session** At the beginning of each request, the user is loaded from the session (unless your firewall is stateless). The provider \"refreshes\" the user (e.g. the database is queried again for fresh data) to make sure all user information is up to date (and if necessary, the user is de-authenticated/logged out if something changed). See user_session_refresh for more information about this process. Symfony comes with several built-in user providers: Entity User Provider Loads users from a database using Doctrine ; LDAP User Provider Loads users from a LDAP server; Memory User Provider Loads users from a configuration file; Chain User Provider Merges two or more user providers into a new user provider. Since each firewall has exactly *one* user provider, you can use this to chain multiple providers together. The built-in user providers cover the most common needs for applications, but you can also create your own custom user provider . Sometimes, you need to inject the user provider in another class (e.g. in your custom authenticator). All user providers follow this pattern for their service ID: security.user.provider.concrete.<your-provider-name> (where <your-provider-name> is the configuration key, e.g. app_user_provider). If you only have one user provider, you can autowire it using the Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\UserProviderInterface type-hint. Registering the User: Hashing Passwords Many applications require a user to log in with a password. For these applications, the SecurityBundle provides password hashing and verification functionality. First, make sure your User class implements the Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\PasswordAuthenticatedUserInterface:: // src/Entity/User.php // ... use Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface; class User implements UserInterface, PasswordAuthenticatedUserInterface { // ... /** * @return string the hashed password for this user */ public function getPassword(): string { return $this->password; } } Then, configure which password hasher should be used for this class. If your security.yaml file wasn't already pre-configured, then make:user should have done this for you: # config/packages/security.yaml security: # ... password_hashers: # Use native password hasher, which auto-selects and migrates the best # possible hashing algorithm (which currently is \"bcrypt\") Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface: 'auto' <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <!-- Use native password hasher, which auto-selects and migrates the best possible hashing algorithm (currently this is \"bcrypt\") --> <password-hasher class=\"Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface\" algorithm=\"auto\"/> </config> </srv:container> // config/packages/security.php use App\\Entity\\User; use Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface; return static function (SecurityConfig $security): void { // ... // Use native password hasher, which auto-selects and migrates the best // possible hashing algorithm (currently this is \"bcrypt\") $security->passwordHasher(PasswordAuthenticatedUserInterface::class) ->algorithm('auto') ; }; Now that Symfony knows *how* you want to hash the passwords, you can use the UserPasswordHasherInterface service to do", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_3", "source": "security.rst", "text": "<!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <!-- Use native password hasher, which auto-selects and migrates the best possible hashing algorithm (currently this is \"bcrypt\") --> <password-hasher class=\"Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface\" algorithm=\"auto\"/> </config> </srv:container> // config/packages/security.php use App\\Entity\\User; use Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface; return static function (SecurityConfig $security): void { // ... // Use native password hasher, which auto-selects and migrates the best // possible hashing algorithm (currently this is \"bcrypt\") $security->passwordHasher(PasswordAuthenticatedUserInterface::class) ->algorithm('auto') ; }; Now that Symfony knows *how* you want to hash the passwords, you can use the UserPasswordHasherInterface service to do this before saving your users to the database:: // src/Controller/RegistrationController.php namespace App\\Controller; // ... use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\PasswordHasher\\Hasher\\UserPasswordHasherInterface; class RegistrationController extends AbstractController { public function index(UserPasswordHasherInterface $passwordHasher): Response { // ... e.g. get the user data from a registration form $user = new User(...); $plaintextPassword = ...; // hash the password (based on the security.yaml config for the $user class) $hashedPassword = $passwordHasher->hashPassword( $user, $plaintextPassword ); $user->setPassword($hashedPassword); // ... } } If your user class is a Doctrine entity and you hash user passwords, the Doctrine repository class related to the user class must implement the Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\PasswordUpgraderInterface. The make:registration-form maker command can help you set-up the registration controller and add features like email address verification using the `SymfonyCastsVerifyEmailBundle`_. $ composer require symfonycasts/verify-email-bundle $ php bin/console make:registration-form You can also manually hash a password by running: $ php bin/console security:hash-password Read more about all available hashers and password migration in /security/passwords. The Firewall The firewalls section of config/packages/security.yaml is the *most* important section. A \"firewall\" is your authentication system: the firewall defines which parts of your application are secured and *how* your users will be able to authenticate (e.g. login form, API token, etc). # config/packages/security.yaml security: # ... firewalls: # the order in which firewalls are defined is very important, as the # request will be handled by the first firewall whose pattern matches dev: pattern: ^/(_(profiler|wdt)|css|images|js)/ security: false # a firewall with no pattern should be defined last because it will match all requests main: lazy: true # provider that you set earlier inside providers provider: app_user_provider # activate different ways to authenticate # https://symfony.com/doc/current/security.html#firewalls-authentication # https://symfony.com/doc/current/security/impersonating_user.html # switch_user: true <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <!-- the order in which firewalls are defined is very important, as the request will be handled by the first firewall whose pattern matches --> <firewall name=\"dev\" pattern=\"^/(_(profiler|wdt)|css|images|js)/\" security=\"false\"/> <!-- a firewall with no pattern should be defined last because it will match all requests --> <firewall name=\"main\" lazy=\"true\"/> <!-- activate different ways to authenticate https://symfony.com/doc/current/security.html#firewalls-authentication --> <!-- https://symfony.com/doc/current/security/impersonating_user.html --> <!-- <switch-user/> --> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... // the order in which firewalls are defined is very important, as the // request will be handled by the first firewall whose pattern matches $security->firewall('dev') ->pattern('^/(_(profiler|wdt)|css|images|js)/') ->security(false) ; // a firewall", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_4", "source": "security.rst", "text": "important, as the request will be handled by the first firewall whose pattern matches --> <firewall name=\"dev\" pattern=\"^/(_(profiler|wdt)|css|images|js)/\" security=\"false\"/> <!-- a firewall with no pattern should be defined last because it will match all requests --> <firewall name=\"main\" lazy=\"true\"/> <!-- activate different ways to authenticate https://symfony.com/doc/current/security.html#firewalls-authentication --> <!-- https://symfony.com/doc/current/security/impersonating_user.html --> <!-- <switch-user/> --> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... // the order in which firewalls are defined is very important, as the // request will be handled by the first firewall whose pattern matches $security->firewall('dev') ->pattern('^/(_(profiler|wdt)|css|images|js)/') ->security(false) ; // a firewall with no pattern should be defined last because it will match all requests $security->firewall('main') ->lazy(true) // activate different ways to authenticate // https://symfony.com/doc/current/security.html#firewalls-authentication // https://symfony.com/doc/current/security/impersonating_user.html // ->switchUser(true) ; }; Only one firewall is active on each request: Symfony uses the pattern key to find the first match (you can also match by host or other things ). Here, all real URLs are handled by the main firewall (no pattern key means it matches *all* URLs). The dev firewall is really a fake firewall: it makes sure that you don't accidentally block Symfony's dev tools - which live under URLs like /_profiler and /_wdt. When matching several routes, instead of creating a long regex you can also use an array of simpler regexes to match each route: # config/packages/security.yaml security: # ... firewalls: dev: pattern: - ^/_profiler/ - ^/_wdt/ - ^/css/ - ^/images/ - ^/js/ # ... // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $security->firewall('dev') ->pattern([ '^/_profiler/', '^/_wdt/', '^/css/', '^/images/', '^/js/', ]) ->security(false) ; // ... }; This feature is not supported by the XML configuration format. A firewall can have many modes of authentication, in other words, it enables many ways to ask the question \"Who are you?\". Often, the user is unknown (i.e. not logged in) when they first visit your website. If you visit your homepage right now, you *will* have access and you'll see that you're visiting a page behind the firewall in the toolbar: :alt: The Symfony profiler toolbar where the Security information shows \"Authenticated: no\" and \"Firewall name: main\" Visiting a URL under a firewall doesn't necessarily require you to be authenticated (e.g. the login form has to be accessible or some parts of your application are public). On the other hand, all pages that you want to be *aware* of a logged in user have to be under the same firewall. So if you want to display a *\"You are logged in as ...\"* message on every page, they all have to be included in the same firewall. You'll learn how to restrict access to URLs, controllers or anything else within your firewall in the access control section. The lazy anonymous mode prevents the session from being started if there is no need for authorization (i.e. explicit check for a user privilege). This is important to keep requests cacheable (see /http_cache). If you do not see the toolbar,", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_5", "source": "security.rst", "text": "*aware* of a logged in user have to be under the same firewall. So if you want to display a *\"You are logged in as ...\"* message on every page, they all have to be included in the same firewall. You'll learn how to restrict access to URLs, controllers or anything else within your firewall in the access control section. The lazy anonymous mode prevents the session from being started if there is no need for authorization (i.e. explicit check for a user privilege). This is important to keep requests cacheable (see /http_cache). If you do not see the toolbar, install the profiler with: $ composer require --dev symfony/profiler-pack Fetching the Firewall Configuration for a Request If you need to get the configuration of the firewall that matched a given request, use the Symfony\\\\Bundle\\\\SecurityBundle\\\\Security service:: // src/Service/ExampleService.php // ... use Symfony\\Bundle\\SecurityBundle\\Security; use Symfony\\Component\\HttpFoundation\\RequestStack; class ExampleService { public function __construct( // Avoid calling getFirewallConfig() in the constructor: auth may not // be complete yet. Instead, store the entire Security object. private Security $security, private RequestStack $requestStack, ) { } public function someMethod(): void { $request = $this->requestStack->getCurrentRequest(); $firewallName = $this->security->getFirewallConfig($request)?->getName(); // ... } } Authenticating Users During authentication, the system tries to find a matching user for the visitor of the webpage. Traditionally, this was done using a login form or a HTTP basic dialog in the browser. However, the SecurityBundle comes with many other authenticators: * `Form Login`_ * `JSON Login`_ * `HTTP Basic`_ * `Login Link`_ * `X.509 Client Certificates`_ * `Remote users`_ * Custom Authenticators If your application logs users in via a third-party service such as Google, Facebook or Twitter (social login), check out the `HWIOAuthBundle`_ community bundle or `Oauth2-client`_ package. Form Login Most websites have a login form where users authenticate using an identifier (e.g. email address or username) and a password. This functionality is provided by the built-in Symfony\\\\Component\\\\Security\\\\Http\\\\Authenticator\\\\FormLoginAuthenticator. You can run the following command to create everything needed to add a login form in your application: $ php bin/console make:security:form-login This command will create the required controller and template and it will also update the security configuration. Alternatively, if you prefer to make these changes manually, follow the next steps. First, create a controller for the login form: $ php bin/console make:controller Login created: src/Controller/LoginController.php created: templates/login/index.html.twig // src/Controller/LoginController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class LoginController extends AbstractController { #[Route('/login', name: 'app_login')] public function index(): Response { return $this->render('login/index.html.twig', [ 'controller_name' => 'LoginController', ]); } } Then, enable the FormLoginAuthenticator using the form_login setting: # config/packages/security.yaml security: # ... firewalls: main: # ... form_login: # \"app_login\" is the name of the route created previously login_path: app_login check_path: app_login <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"main\"> <!-- \"app_login\" is the name of the route created previously --> <form-login login-path=\"app_login\" check-path=\"app_login\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $mainFirewall =", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_6", "source": "security.rst", "text": "'app_login')] public function index(): Response { return $this->render('login/index.html.twig', [ 'controller_name' => 'LoginController', ]); } } Then, enable the FormLoginAuthenticator using the form_login setting: # config/packages/security.yaml security: # ... firewalls: main: # ... form_login: # \"app_login\" is the name of the route created previously login_path: app_login check_path: app_login <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"main\"> <!-- \"app_login\" is the name of the route created previously --> <form-login login-path=\"app_login\" check-path=\"app_login\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $mainFirewall = $security->firewall('main'); // \"app_login\" is the name of the route created previously $mainFirewall->formLogin() ->loginPath('app_login') ->checkPath('app_login') ; }; The login_path and check_path support URLs and route names (but cannot have mandatory wildcards - e.g. /login/{foo} where foo has no default value). Once enabled, the security system redirects unauthenticated visitors to the login_path when they try to access a secured place (this behavior can be customized using authentication entry points ). Edit the login controller to render the login form: // ... + use Symfony\\Component\\Security\\Http\\Authentication\\AuthenticationUtils; class LoginController extends AbstractController { #[Route('/login', name: 'app_login')] - public function index(): Response + public function index(AuthenticationUtils $authenticationUtils): Response { + // get the login error if there is one + $error = $authenticationUtils->getLastAuthenticationError(); + + // last username entered by the user + $lastUsername = $authenticationUtils->getLastUsername(); + return $this->render('login/index.html.twig', [ - 'controller_name' => 'LoginController', + 'last_username' => $lastUsername, + 'error' => $error, ]); } } Don't let this controller confuse you. Its job is only to *render* the form. The FormLoginAuthenticator will handle the form *submission* automatically. If the user submits an invalid email or password, that authenticator will store the error and redirect back to this controller, where we read the error (using AuthenticationUtils) so that it can be displayed back to the user. Finally, create or update the template: {# templates/login/index.html.twig #} {% extends 'base.html.twig' %} {# ... #} {% block body %} {% if error %} <div>{{ error.messageKey|trans(error.messageData, 'security') }}</div> {% endif %} <form action=\"{{ path('app_login') }}\" method=\"post\"> <label for=\"username\">Email:</label> <input type=\"text\" id=\"username\" name=\"_username\" value=\"{{ last_username }}\" required> <label for=\"password\">Password:</label> <input type=\"password\" id=\"password\" name=\"_password\" required> {# If you want to control the URL the user is redirected to on success <input type=\"hidden\" name=\"_target_path\" value=\"/account\"> #} <button type=\"submit\">login</button> </form> {% endblock %} The error variable passed into the template is an instance of Symfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AuthenticationException. It may contain sensitive information about the authentication failure. *Never* use error.message: use the messageKey property instead, as shown in the example. This message is always safe to display. The form can look like anything, but it usually follows some conventions: * The <form> element sends a POST request to the app_login route, since that's what you configured as the check_path under the form_login key in security.yaml; * The username (or whatever your user's \"identifier\" is, like an email) field has the name _username and the password field has the name _password. Actually, all of this can be configured under the", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_7", "source": "security.rst", "text": "may contain sensitive information about the authentication failure. *Never* use error.message: use the messageKey property instead, as shown in the example. This message is always safe to display. The form can look like anything, but it usually follows some conventions: * The <form> element sends a POST request to the app_login route, since that's what you configured as the check_path under the form_login key in security.yaml; * The username (or whatever your user's \"identifier\" is, like an email) field has the name _username and the password field has the name _password. Actually, all of this can be configured under the form_login key. See reference-security-firewall-form-login for more details. This login form is currently not protected against CSRF attacks. Read form_login-csrf on how to protect your login form. And that's it! When you submit the form, the security system automatically reads the _username and _password POST parameter, loads the user via the user provider, checks the user's credentials and either authenticates the user or sends them back to the login form where the error can be displayed. To review the whole process: #. The user tries to access a resource that is protected (e.g. /admin); #. The firewall initiates the authentication process by redirecting the user to the login form (/login); #. The /login page renders login form via the route and controller created in this example; #. The user submits the login form to /login; #. The security system (i.e. the FormLoginAuthenticator) intercepts the request, checks the user's submitted credentials, authenticates the user if they are correct, and sends the user back to the login form if they are not. You can customize the responses on a successful or failed login attempt. See /security/form_login. CSRF Protection in Login Forms .............................. `Login CSRF attacks`_ can be prevented using the same technique of adding hidden CSRF tokens into the login forms. The Security component already provides CSRF protection, but you need to configure some options before using it. First, you need to enable CSRF on the form login: # config/packages/security.yaml security: # ... firewalls: secured_area: # ... form_login: # ... enable_csrf: true <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"secured_area\"> <!-- ... --> <form-login enable-csrf=\"true\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $mainFirewall = $security->firewall('main'); $mainFirewall->formLogin() // ... ->enableCsrf(true) ; }; Then, use the csrf_token() function in the Twig template to generate a CSRF token and store it as a hidden field of the form. By default, the HTML field must be called _csrf_token and the string used to generate the value must be authenticate: {# templates/login/index.html.twig #} {# ... #} <form action=\"{{ path('app_login') }}\" method=\"post\"> {# ... the login fields #} <input type=\"hidden\" name=\"_csrf_token\" data-controller=\"csrf-protection\" value=\"{{ csrf_token('authenticate') }}\"> <button type=\"submit\">login</button> </form> After this, you have protected your login form against CSRF attacks. You can change the name of the field by setting csrf_parameter and change the token ID by setting", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_8", "source": "security.rst", "text": "Then, use the csrf_token() function in the Twig template to generate a CSRF token and store it as a hidden field of the form. By default, the HTML field must be called _csrf_token and the string used to generate the value must be authenticate: {# templates/login/index.html.twig #} {# ... #} <form action=\"{{ path('app_login') }}\" method=\"post\"> {# ... the login fields #} <input type=\"hidden\" name=\"_csrf_token\" data-controller=\"csrf-protection\" value=\"{{ csrf_token('authenticate') }}\"> <button type=\"submit\">login</button> </form> After this, you have protected your login form against CSRF attacks. You can change the name of the field by setting csrf_parameter and change the token ID by setting csrf_token_id in your configuration. See reference-security-firewall-form-login for more details. JSON Login Some applications provide an API that is secured using tokens. These applications may use an endpoint that provides these tokens based on a username (or email) and password. The JSON login authenticator helps you create this functionality. Enable the authenticator using the json_login setting: # config/packages/security.yaml security: # ... firewalls: main: # ... json_login: # api_login is a route we will create below check_path: api_login <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"main\"> <json-login check-path=\"api_login\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $mainFirewall = $security->firewall('main'); $mainFirewall->jsonLogin() ->checkPath('api_login') ; }; The check_path supports URLs and route names (but cannot have mandatory wildcards - e.g. /login/{foo} where foo has no default value). The authenticator runs when a client requests the check_path. First, create a controller for this path: $ php bin/console make:controller --no-template ApiLogin created: src/Controller/ApiLoginController.php // src/Controller/ApiLoginController.php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class ApiLoginController extends AbstractController { #[Route('/api/login', name: 'api_login')] public function index(): Response { return $this->json([ 'message' => 'Welcome to your new controller!', 'path' => 'src/Controller/ApiLoginController.php', ]); } } This login controller will be called after the authenticator successfully authenticates the user. You can get the authenticated user, generate a token (or whatever you need to return) and return the JSON response: // ... + use App\\Entity\\User; + use Symfony\\Component\\Security\\Http\\Attribute\\CurrentUser; class ApiLoginController extends AbstractController { - #[Route('/api/login', name: 'api_login')] + #[Route('/api/login', name: 'api_login', methods: ['POST'])] - public function index(): Response + public function index(#[CurrentUser] ?User $user): Response { + if (null === $user) { + return $this->json([ + 'message' => 'missing credentials', + ], Response::HTTP_UNAUTHORIZED); + } + + $token = ...; // somehow create an API token for $user + return $this->json([ - 'message' => 'Welcome to your new controller!', - 'path' => 'src/Controller/ApiLoginController.php', + 'user' => $user->getUserIdentifier(), + 'token' => $token, ]); } } The #[CurrentUser] can only be used in controller arguments to retrieve the authenticated user. In services, you would use Symfony\\\\Bundle\\\\SecurityBundle\\\\Security::getUser. That's it! To summarize the process: #. A client (e.g. the front-end) makes a *POST request* with the Content-Type: application/json header to /api/login with username (even if your identifier is actually an email) and password keys: { \"username\": \"dunglas@example.com\", \"password\": \"MyPassword\" } #. The security system intercepts the", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_9", "source": "security.rst", "text": "create an API token for $user + return $this->json([ - 'message' => 'Welcome to your new controller!', - 'path' => 'src/Controller/ApiLoginController.php', + 'user' => $user->getUserIdentifier(), + 'token' => $token, ]); } } The #[CurrentUser] can only be used in controller arguments to retrieve the authenticated user. In services, you would use Symfony\\\\Bundle\\\\SecurityBundle\\\\Security::getUser. That's it! To summarize the process: #. A client (e.g. the front-end) makes a *POST request* with the Content-Type: application/json header to /api/login with username (even if your identifier is actually an email) and password keys: { \"username\": \"dunglas@example.com\", \"password\": \"MyPassword\" } #. The security system intercepts the request, checks the user's submitted credentials and authenticates the user. If the credentials are incorrect, an HTTP 401 Unauthorized JSON response is returned, otherwise your controller is run; #. Your controller creates the correct response: { \"user\": \"dunglas@example.com\", \"token\": \"45be42...\" } The JSON request format can be configured under the json_login key. See reference-security-firewall-json-login for more details. HTTP Basic `HTTP Basic authentication`_ is a standardized HTTP authentication framework. It asks credentials (username and password) using a dialog in the browser and the HTTP basic authenticator of Symfony will verify these credentials. Add the http_basic key to your firewall to enable HTTP Basic authentication: # config/packages/security.yaml security: # ... firewalls: main: # ... http_basic: realm: Secured Area <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"main\"> <http-basic realm=\"Secured Area\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $mainFirewall = $security->firewall('main'); $mainFirewall->httpBasic() ->realm('Secured Area') ; }; That's it! Whenever an unauthenticated user tries to visit a protected page, Symfony will inform the browser that it needs to start HTTP basic authentication (using the WWW-Authenticate response header). Then, the authenticator verifies the credentials and authenticates the user. You cannot use log out with the HTTP basic authenticator. Even if you log out from Symfony, your browser \"remembers\" your credentials and will send them on every request. Login Link Login links are a passwordless authentication mechanism. The user will receive a short-lived link (e.g. via email) which will authenticate them to the website. You can learn all about this authenticator in /security/login_link. Access Tokens Access Tokens are often used in API contexts. The user receives a token from an authorization server which authenticates them. You can learn all about this authenticator in /security/access_token. X.509 Client Certificates When using client certificates, your web server does all the authentication itself. The X.509 authenticator provided by Symfony extracts the email from the \"distinguished name\" (DN) of the client certificate. Then, it uses this email as user identifier in the user provider. First, configure your web server to enable client certificate verification and to expose the certificate's DN to the Symfony application: server { # ... ssl_client_certificate /path/to/my-custom-CA.pem; # enable client certificate verification ssl_verify_client optional; ssl_verify_depth 1; location / { # pass the DN as \"SSL_CLIENT_S_DN\" to the application fastcgi_param SSL_CLIENT_S_DN $ssl_client_s_dn; # ... } } # ... SSLCACertificateFile \"/path/to/my-custom-CA.pem\"", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_10", "source": "security.rst", "text": "When using client certificates, your web server does all the authentication itself. The X.509 authenticator provided by Symfony extracts the email from the \"distinguished name\" (DN) of the client certificate. Then, it uses this email as user identifier in the user provider. First, configure your web server to enable client certificate verification and to expose the certificate's DN to the Symfony application: server { # ... ssl_client_certificate /path/to/my-custom-CA.pem; # enable client certificate verification ssl_verify_client optional; ssl_verify_depth 1; location / { # pass the DN as \"SSL_CLIENT_S_DN\" to the application fastcgi_param SSL_CLIENT_S_DN $ssl_client_s_dn; # ... } } # ... SSLCACertificateFile \"/path/to/my-custom-CA.pem\" SSLVerifyClient optional SSLVerifyDepth 1 # pass the DN to the application SSLOptions +StdEnvVars tls { client_auth { mode verify_if_given # check the Caddy documentation for more information trusted_ca_cert_file /path/to/my-custom-CA.pem } } route { # Other configuration options go here php_fastcgi unix//var/run/php/php-fpm.sock { env SSL_CLIENT_S_DN {tls_client_subject} # Environment variables for other certificate fields that you might need. # They are not used by Symfony, but you can use them in your application. # See all placeholders: https://caddyserver.com/docs/caddyfile/concepts#placeholders env SSL_CLIENT_S_FINGERPRINT {tls_client_fingerprint} env SSL_CLIENT_S_CERTIFICATE {tls_client_certificate_der_base64} env SSL_CLIENT_S_ISSUER {tls_client_issuer} env SSL_CLIENT_S_SERIAL {tls_client_serial} env SSL_CLIENT_S_VERSION {tls_version} } } Then, enable the X.509 authenticator using x509 on your firewall: # config/packages/security.yaml security: # ... firewalls: main: # ... x509: provider: your_user_provider <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"main\"> <!-- ... --> <x509 provider=\"your_user_provider\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $mainFirewall = $security->firewall('main'); $mainFirewall->x509() ->provider('your_user_provider') ; }; By default, Symfony extracts the email address from the DN in two different ways: #. First, it tries the SSL_CLIENT_S_DN_Email server parameter, which is exposed by Apache; #. If it is not set (e.g. when using Nginx), it uses SSL_CLIENT_S_DN and matches the value following emailAddress. You can customize the name of some parameters under the x509 key. See the x509 configuration reference for more details. Remote Users Besides client certificate authentication, there are more web server modules that pre-authenticate a user (e.g. kerberos). The remote user authenticator provides a basic integration for these services. These modules often expose the authenticated user in the REMOTE_USER environment variable. The remote user authenticator uses this value as the user identifier to load the corresponding user. Enable remote user authentication using the remote_user key: # config/packages/security.yaml security: firewalls: main: # ... remote_user: provider: your_user_provider <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <firewall name=\"main\"> <remote-user provider=\"your_user_provider\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $mainFirewall = $security->firewall('main'); $mainFirewall->remoteUser() ->provider('your_user_provider') ; }; You can customize the name of this server variable under the remote_user key. See the configuration reference for more details. Limiting Login Attempts Symfony provides basic protection against `brute force login attacks`_ thanks to the Rate Limiter component . If you haven't used this component in your application yet, install it before using this feature: $", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_11", "source": "security.rst", "text": "remote_user: provider: your_user_provider <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <firewall name=\"main\"> <remote-user provider=\"your_user_provider\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $mainFirewall = $security->firewall('main'); $mainFirewall->remoteUser() ->provider('your_user_provider') ; }; You can customize the name of this server variable under the remote_user key. See the configuration reference for more details. Limiting Login Attempts Symfony provides basic protection against `brute force login attacks`_ thanks to the Rate Limiter component . If you haven't used this component in your application yet, install it before using this feature: $ composer require symfony/rate-limiter Then, enable this feature using the login_throttling setting: # config/packages/security.yaml security: firewalls: # ... main: # ... # by default, the feature allows 5 login attempts per minute login_throttling: null # configure the maximum login attempts login_throttling: max_attempts: 3 # per minute ... # interval: '15 minutes' # ... or in a custom period # use a custom rate limiter via its service ID login_throttling: limiter: app.my_login_rate_limiter <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <!-- you must use the authenticator manager --> <config enable-authenticator-manager=\"true\"> <!-- ... --> <firewall name=\"main\"> <!-- by default, the feature allows 5 login attempts per minute max-attempts: (optional) You can configure the maximum attempts ... interval: (optional) ... and the period of time. --> <login-throttling max-attempts=\"3\" interval=\"15 minutes\"/> <!-- use a custom rate limiter via its service ID --> <login-throttling limiter=\"app.my_login_rate_limiter\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $security->enableAuthenticatorManager(true); $mainFirewall = $security->firewall('main'); // by default, the feature allows 5 login attempts per minute $mainFirewall->loginThrottling() // ->maxAttempts(3) // Optional: You can configure the maximum attempts ... // ->interval('15 minutes') // ... and the period of time. ; }; The value of the interval option must be a number followed by any of the units accepted by the `PHP date relative formats`_ (e.g. 3 seconds, 10 hours, 1 day, etc.) Internally, Symfony uses the Rate Limiter component which by default uses Symfony's cache to store the previous login attempts. However, you can implement a custom storage . Login attempts are limited on max_attempts (default: 5) failed requests for IP address + username and 5 * max_attempts failed requests for IP address. The second limit protects against an attacker using multiple usernames from bypassing the first limit, without disrupting normal users on big networks (such as offices). Limiting the failed login attempts is only one basic protection against brute force attacks. The `OWASP Brute Force Attacks`_ guidelines mention several other protections that you should consider depending on the level of protection required. If you need a more complex limiting algorithm, create a class that implements Symfony\\\\Component\\\\HttpFoundation\\\\RateLimiter\\\\RequestRateLimiterInterface (or use Symfony\\\\Component\\\\Security\\\\Http\\\\RateLimiter\\\\DefaultLoginRateLimiter) and set the limiter option to its service ID: # config/packages/security.yaml framework: rate_limiter: # define 2 rate limiters (one for username+IP, the other for IP) username_ip_login: policy: token_bucket limit: 5 rate: { interval: '5 minutes' } ip_login: policy: sliding_window limit: 50 interval: '15", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_12", "source": "security.rst", "text": "big networks (such as offices). Limiting the failed login attempts is only one basic protection against brute force attacks. The `OWASP Brute Force Attacks`_ guidelines mention several other protections that you should consider depending on the level of protection required. If you need a more complex limiting algorithm, create a class that implements Symfony\\\\Component\\\\HttpFoundation\\\\RateLimiter\\\\RequestRateLimiterInterface (or use Symfony\\\\Component\\\\Security\\\\Http\\\\RateLimiter\\\\DefaultLoginRateLimiter) and set the limiter option to its service ID: # config/packages/security.yaml framework: rate_limiter: # define 2 rate limiters (one for username+IP, the other for IP) username_ip_login: policy: token_bucket limit: 5 rate: { interval: '5 minutes' } ip_login: policy: sliding_window limit: 50 interval: '15 minutes' services: # our custom login rate limiter app.login_rate_limiter: class: Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter arguments: # globalFactory is the limiter for IP $globalFactory: '@limiter.ip_login' # localFactory is the limiter for username+IP $localFactory: '@limiter.username_ip_login' $secret: '%kernel.secret%' security: firewalls: main: # use a custom rate limiter via its service ID login_throttling: limiter: app.login_rate_limiter <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <framework:config> <framework:rate-limiter> <!-- define 2 rate limiters (one for username+IP, the other for IP) --> <framework:limiter name=\"username_ip_login\" policy=\"token_bucket\" limit=\"5\" > <framework:rate interval=\"5 minutes\"/> </framework:limiter> <framework:limiter name=\"ip_login\" policy=\"sliding_window\" limit=\"50\" interval=\"15 minutes\" /> </framework:rate-limiter> </framework:config> <srv:services> <!-- our custom login rate limiter --> <srv:service id=\"app.login_rate_limiter\" class=\"Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter\" > <!-- 1st argument is the limiter for IP --> <srv:argument type=\"service\" id=\"limiter.ip_login\"/> <!-- 2nd argument is the limiter for username+IP --> <srv:argument type=\"service\" id=\"limiter.username_ip_login\"/> <!-- 3rd argument is the app secret --> <srv:argument type=\"string\">%kernel.secret%</srv:argument> </srv:service> </srv:services> <config> <firewall name=\"main\"> <!-- use a custom rate limiter via its service ID --> <login-throttling limiter=\"app.login_rate_limiter\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Component\\DependencyInjection\\ContainerBuilder; use Symfony\\Component\\DependencyInjection\\Reference; use Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter; use Symfony\\Config\\FrameworkConfig; use Symfony\\Config\\SecurityConfig; return static function (ContainerBuilder $container, FrameworkConfig $framework, SecurityConfig $security): void { $framework->rateLimiter() ->limiter('username_ip_login') ->policy('token_bucket') ->limit(5) ->rate() ->interval('5 minutes') ; $framework->rateLimiter() ->limiter('ip_login') ->policy('sliding_window') ->limit(50) ->interval('15 minutes') ; $container->register('app.login_rate_limiter', DefaultLoginRateLimiter::class) ->setArguments([ // 1st argument is the limiter for IP new Reference('limiter.ip_login'), // 2nd argument is the limiter for username+IP new Reference('limiter.username_ip_login'), // 3rd argument is the app secret param('kernel.secret'), ]); $security->firewall('main') ->loginThrottling() ->limiter('app.login_rate_limiter') ; }; Customize Successful and Failed Authentication Behavior If you want to customize how the successful or failed authentication process is handled, you don't have to overwrite the respective listeners globally. Instead, you can set custom success failure handlers by implementing the Symfony\\\\Component\\\\Security\\\\Http\\\\Authentication\\\\AuthenticationSuccessHandlerInterface or the Symfony\\\\Component\\\\Security\\\\Http\\\\Authentication\\\\AuthenticationFailureHandlerInterface. Read how to customize your success handler for more information about this. Login Programmatically You can log in a user programmatically using the login() method of the Symfony\\\\Bundle\\\\SecurityBundle\\\\Security helper:: // src/Controller/SecurityController.php namespace App\\Controller; use App\\Security\\Authenticator\\ExampleAuthenticator; use Symfony\\Bundle\\SecurityBundle\\Security; use Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\RememberMeBadge; class SecurityController { public function someAction(Security $security): Response { // get the user to be authenticated $user = ...; // log the user in on the current firewall $security->login($user); // if the firewall has more than one authenticator, you must pass it explicitly // by using the name of built-in authenticators... $security->login($user, 'form_login'); // ...or the service id of custom authenticators $security->login($user, ExampleAuthenticator::class); // you can also log in on a different firewall... $security->login($user, 'form_login', 'other_firewall'); //", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_13", "source": "security.rst", "text": "log in a user programmatically using the login() method of the Symfony\\\\Bundle\\\\SecurityBundle\\\\Security helper:: // src/Controller/SecurityController.php namespace App\\Controller; use App\\Security\\Authenticator\\ExampleAuthenticator; use Symfony\\Bundle\\SecurityBundle\\Security; use Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\RememberMeBadge; class SecurityController { public function someAction(Security $security): Response { // get the user to be authenticated $user = ...; // log the user in on the current firewall $security->login($user); // if the firewall has more than one authenticator, you must pass it explicitly // by using the name of built-in authenticators... $security->login($user, 'form_login'); // ...or the service id of custom authenticators $security->login($user, ExampleAuthenticator::class); // you can also log in on a different firewall... $security->login($user, 'form_login', 'other_firewall'); // ... add badges... $security->login($user, 'form_login', 'other_firewall', [(new RememberMeBadge())->enable()]); // ... and also add passport attributes $security->login($user, 'form_login', 'other_firewall', [(new RememberMeBadge())->enable()], ['referer' => 'https://oauth.example.com']); // use the redirection logic applied to regular login $redirectResponse = $security->login($user); return $redirectResponse; // or use a custom redirection logic (e.g. redirect users to their account page) // return new RedirectResponse('...'); } } The support for passport attributes in the Symfony\\\\Bundle\\\\SecurityBundle\\\\Security::login method was introduced in Symfony 7.2. Logging Out To enable logging out, activate the logout config parameter under your firewall: # config/packages/security.yaml security: # ... firewalls: main: # ... logout: path: /logout # where to redirect after logout # target: app_any_route <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"main\"> <logout path=\"/logout\"/> <!-- use \"target\" to configure where to redirect after logout <logout path=\"/logout\" target=\"app_any_route\"/> --> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $mainFirewall = $security->firewall('main'); // ... $mainFirewall->logout() ->path('/logout') // where to redirect after logout // ->target('app_any_route') ; }; Symfony will then un-authenticate users navigating to the configured path, and redirect them to the configured target. If you need to reference the logout path, you can use the _logout_<firewallname> route name (e.g. _logout_main). If your project does not use Symfony Flex , make sure you have imported the logout route loader in your routes: # config/routes/security.yaml _symfony_logout: resource: security.route_loader.logout type: service <!-- config/routes/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <import resource=\"security.route_loader.logout\" type=\"service\"/> </routes> // config/routes/security.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return static function (RoutingConfigurator $routes): void { $routes->import('security.route_loader.logout', 'service'); }; Logout programmatically You can logout user programmatically using the logout() method of the Symfony\\\\Bundle\\\\SecurityBundle\\\\Security helper:: // src/Controller/SecurityController.php namespace App\\Controller; use Symfony\\Bundle\\SecurityBundle\\Security; class SecurityController { public function someAction(Security $security): Response { // logout the user in on the current firewall $response = $security->logout(); // you can also disable the csrf logout $response = $security->logout(false); // ... return $response (if set) or e.g. redirect to the homepage } } The user will be logged out from the firewall of the request. If the request is not behind a firewall a \\LogicException will be thrown. Customizing Logout In some cases you need to run extra logic upon logout (e.g. invalidate some tokens) or want to customize what happens after a logout. During logout, a Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LogoutEvent is dispatched. Register an event listener or subscriber to execute", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_14", "source": "security.rst", "text": "the user in on the current firewall $response = $security->logout(); // you can also disable the csrf logout $response = $security->logout(false); // ... return $response (if set) or e.g. redirect to the homepage } } The user will be logged out from the firewall of the request. If the request is not behind a firewall a \\LogicException will be thrown. Customizing Logout In some cases you need to run extra logic upon logout (e.g. invalidate some tokens) or want to customize what happens after a logout. During logout, a Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LogoutEvent is dispatched. Register an event listener or subscriber to execute custom logic:: // src/EventListener/LogoutSubscriber.php namespace App\\EventListener; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\HttpFoundation\\RedirectResponse; use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface; use Symfony\\Component\\Security\\Http\\Event\\LogoutEvent; class LogoutSubscriber implements EventSubscriberInterface { public function __construct( private UrlGeneratorInterface $urlGenerator ) { } public static function getSubscribedEvents(): array { return [LogoutEvent::class => 'onLogout']; } public function onLogout(LogoutEvent $event): void { // get the security token of the session that is about to be logged out $token = $event->getToken(); // get the current request $request = $event->getRequest(); // get the current response, if it is already set by another listener $response = $event->getResponse(); // configure a custom logout response to the homepage $response = new RedirectResponse( $this->urlGenerator->generate('homepage'), RedirectResponse::HTTP_SEE_OTHER ); $event->setResponse($response); } } Customizing Logout Path Another option is to configure path as a route name. This can be useful if you want logout URIs to be dynamic (e.g. translated according to the current locale). In that case, you have to create this route yourself: # config/routes.yaml app_logout: path: en: /logout fr: /deconnexion methods: GET <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"app_logout\" path=\"/logout\" methods=\"GET\"> <path locale=\"en\">/logout</path> <path locale=\"fr\">/deconnexion</path> </route> </routes> // config/routes.php use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void { $routes->add('app_logout', [ 'en' => '/logout', 'fr' => '/deconnexion', ]) ->methods(['GET']) ; }; Then, pass the route name to the path option: # config/packages/security.yaml security: # ... firewalls: main: # ... logout: path: app_logout <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"main\"> <logout path=\"app_logout\"/> </firewall> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $mainFirewall = $security->firewall('main'); // ... $mainFirewall->logout() ->path('app_logout') ; }; Fetching the User Object After authentication, the User object of the current user can be accessed via the getUser() shortcut in the base controller :: use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; class ProfileController extends AbstractController { public function index(): Response { // usually you'll want to make sure the user is authenticated first, // see \"Authorization\" below $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY'); // returns your User object, or null if the user is not authenticated // use inline documentation to tell your editor your exact User class /** @var \\App\\Entity\\User $user */ $user = $this->getUser(); // Call whatever methods you've added to your User class // For example, if you added a getFirstName() method, you can use that. return new Response('Well hi there '.$user->getFirstName()); } } Fetching the User from a Service If you need", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_15", "source": "security.rst", "text": "class ProfileController extends AbstractController { public function index(): Response { // usually you'll want to make sure the user is authenticated first, // see \"Authorization\" below $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY'); // returns your User object, or null if the user is not authenticated // use inline documentation to tell your editor your exact User class /** @var \\App\\Entity\\User $user */ $user = $this->getUser(); // Call whatever methods you've added to your User class // For example, if you added a getFirstName() method, you can use that. return new Response('Well hi there '.$user->getFirstName()); } } Fetching the User from a Service If you need to get the logged in user from a service, use the Symfony\\\\Bundle\\\\SecurityBundle\\\\Security service:: // src/Service/ExampleService.php // ... use Symfony\\Bundle\\SecurityBundle\\Security; class ExampleService { // Avoid calling getUser() in the constructor: auth may not // be complete yet. Instead, store the entire Security object. public function __construct( private Security $security, ){ } public function someMethod(): void { // returns User object or null if not authenticated $user = $this->security->getUser(); // ... } } Fetch the User in a Template In a Twig Template the user object is available via the app.user variable thanks to the Twig global app variable : {% if is_granted('IS_AUTHENTICATED_FULLY') %} <p>Email: {{ app.user.email }}</p> {% endif %} Access Control (Authorization) Users can now log in to your app using your login form. Great! Now, you need to learn how to deny access and work with the User object. This is called **authorization**, and its job is to decide if a user can access some resource (a URL, a model object, a method call, ...). The process of authorization has two different sides: #. The user receives a specific role when logging in (e.g. ROLE_ADMIN). #. You add code so that a resource (e.g. URL, controller) requires a specific \"attribute\" (e.g. a role like ROLE_ADMIN) in order to be accessed. Roles When a user logs in, Symfony calls the getRoles() method on your User object to determine which roles this user has. In the User class that was generated earlier, the roles are an array that's stored in the database and every user is *always* given at least one role: ROLE_USER:: // src/Entity/User.php // ... class User { #[ORM\\Column(type: 'json')] private array $roles = []; // ... public function getRoles(): array { $roles = $this->roles; // guarantee every user at least has ROLE_USER $roles[] = 'ROLE_USER'; return array_unique($roles); } } This is a nice default, but you can do *whatever* you want to determine which roles a user should have. The only rule is that every role **must start with** the ROLE_ prefix - otherwise, things won't work as expected. Other than that, a role is just a string and you can invent whatever you need (e.g. ROLE_PRODUCT_ADMIN). You'll use these roles next to grant access to specific sections of your site. Hierarchical Roles .................. Instead of giving many roles to each user, you can define role inheritance rules by creating a role hierarchy: # config/packages/security.yaml security: # ...", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_16", "source": "security.rst", "text": "} This is a nice default, but you can do *whatever* you want to determine which roles a user should have. The only rule is that every role **must start with** the ROLE_ prefix - otherwise, things won't work as expected. Other than that, a role is just a string and you can invent whatever you need (e.g. ROLE_PRODUCT_ADMIN). You'll use these roles next to grant access to specific sections of your site. Hierarchical Roles .................. Instead of giving many roles to each user, you can define role inheritance rules by creating a role hierarchy: # config/packages/security.yaml security: # ... role_hierarchy: ROLE_ADMIN: ROLE_USER ROLE_SUPER_ADMIN: [ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH] <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <role id=\"ROLE_ADMIN\">ROLE_USER</role> <role id=\"ROLE_SUPER_ADMIN\">ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH</role> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $security->roleHierarchy('ROLE_ADMIN', ['ROLE_USER']); $security->roleHierarchy('ROLE_SUPER_ADMIN', ['ROLE_ADMIN', 'ROLE_ALLOWED_TO_SWITCH']); }; Users with the ROLE_ADMIN role will also have the ROLE_USER role. Users with ROLE_SUPER_ADMIN, will automatically have ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH and ROLE_USER (inherited from ROLE_ADMIN). For role hierarchy to work, do not use $user->getRoles() manually. For example, in a controller extending from the base controller :: // BAD - $user->getRoles() will not know about the role hierarchy $hasAccess = in_array('ROLE_ADMIN', $user->getRoles()); // GOOD - use of the normal security methods $hasAccess = $this->isGranted('ROLE_ADMIN'); $this->denyAccessUnlessGranted('ROLE_ADMIN'); The role_hierarchy values are static - you can't, for example, store the role hierarchy in a database. If you need that, create a custom security voter that looks for the user roles in the database. Add Code to Deny Access There are **two** ways to deny access to something: #. access_control in security.yaml allows you to protect URL patterns (e.g. /admin/*). Simpler, but less flexible; #. in your controller (or other code) . Securing URL patterns (access_control) ...................................... The most basic way to secure part of your app is to secure an entire URL pattern in security.yaml. For example, to require ROLE_ADMIN for all URLs that start with /admin, you can: # config/packages/security.yaml security: # ... firewalls: # ... main: # ... access_control: # require ROLE_ADMIN for /admin* - { path: '^/admin', roles: ROLE_ADMIN } # or require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin* - { path: '^/admin', roles: [IS_AUTHENTICATED_FULLY, ROLE_ADMIN] } # the 'path' value can be any valid regular expression # (this one will match URLs like /api/post/7298 and /api/comment/528491) - { path: ^/api/(post|comment)/\\d+$, roles: ROLE_USER } <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"main\"> <!-- ... --> </firewall> <!-- require ROLE_ADMIN for /admin* --> <rule path=\"^/admin\" role=\"ROLE_ADMIN\"/> <!-- require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin* --> <rule path=\"^/admin\"> <role>ROLE_ADMIN</role> <role>IS_AUTHENTICATED_FULLY</role> </rule> <!-- the 'path' value can be any valid regular expression (this one will match URLs like /api/post/7298 and /api/comment/528491) --> <rule path=\"^/api/(post|comment)/\\d+$\" role=\"ROLE_USER\"/> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $security->enableAuthenticatorManager(true); // ... $security->firewall('main') // ... ; // require ROLE_ADMIN for /admin* $security->accessControl() ->path('^/admin') ->roles(['ROLE_ADMIN']);", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_17", "source": "security.rst", "text": "ROLE_USER } <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <firewall name=\"main\"> <!-- ... --> </firewall> <!-- require ROLE_ADMIN for /admin* --> <rule path=\"^/admin\" role=\"ROLE_ADMIN\"/> <!-- require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin* --> <rule path=\"^/admin\"> <role>ROLE_ADMIN</role> <role>IS_AUTHENTICATED_FULLY</role> </rule> <!-- the 'path' value can be any valid regular expression (this one will match URLs like /api/post/7298 and /api/comment/528491) --> <rule path=\"^/api/(post|comment)/\\d+$\" role=\"ROLE_USER\"/> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $security->enableAuthenticatorManager(true); // ... $security->firewall('main') // ... ; // require ROLE_ADMIN for /admin* $security->accessControl() ->path('^/admin') ->roles(['ROLE_ADMIN']); // require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin* $security->accessControl() ->path('^/admin') ->roles(['ROLE_ADMIN', 'IS_AUTHENTICATED_FULLY']); // the 'path' value can be any valid regular expression // (this one will match URLs like /api/post/7298 and /api/comment/528491) $security->accessControl() ->path('^/api/(post|comment)/\\d+$') ->roles(['ROLE_USER']); }; You can define as many URL patterns as you need - each is a regular expression. **BUT**, only **one** will be matched per request: Symfony starts at the top of the list and stops when it finds the first match: # config/packages/security.yaml security: # ... access_control: # matches /admin/users/* - { path: '^/admin/users', roles: ROLE_SUPER_ADMIN } # matches /admin/* except for anything matching the above rule - { path: '^/admin', roles: ROLE_ADMIN } <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config> <!-- ... --> <rule path=\"^/admin/users\" role=\"ROLE_SUPER_ADMIN\"/> <rule path=\"^/admin\" role=\"ROLE_ADMIN\"/> </config> </srv:container> // config/packages/security.php use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { // ... $security->accessControl() ->path('^/admin/users') ->roles(['ROLE_SUPER_ADMIN']); $security->accessControl() ->path('^/admin') ->roles(['ROLE_ADMIN']); }; Prepending the path with ^ means that only URLs *beginning* with the pattern are matched. For example, a path of /admin (without the ^) would match /admin/foo but would also match URLs like /foo/admin. Each access_control can also match on IP address, hostname and HTTP methods. It can also be used to redirect a user to the https version of a URL pattern. For more complex needs, you can also use a service implementing RequestMatcherInterface. See /security/access_control. Securing Controllers and other Code ................................... You can deny access from inside a controller:: // src/Controller/AdminController.php // ... public function adminDashboard(): Response { $this->denyAccessUnlessGranted('ROLE_ADMIN'); // or add an optional message - seen by developers $this->denyAccessUnlessGranted('ROLE_ADMIN', null, 'User tried to access a page without having ROLE_ADMIN'); } That's it! If access is not granted, a special Symfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AccessDeniedException is thrown and no more code in your controller is called. Then, one of two things will happen: 1) If the user isn't logged in yet, they will be asked to log in (e.g. redirected to the login page). 2) If the user *is* logged in, but does *not* have the ROLE_ADMIN role, they'll be shown the 403 access denied page (which you can customize ). Another way to secure one or more controller actions is to use the #[IsGranted] attribute. In the following example, all controller actions will require the ROLE_ADMIN permission, except for adminDashboard(), which will require the ROLE_SUPER_ADMIN permission: // src/Controller/AdminController.php // ... use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted; #[IsGranted('ROLE_ADMIN')] class AdminController extends", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_18", "source": "security.rst", "text": "one of two things will happen: 1) If the user isn't logged in yet, they will be asked to log in (e.g. redirected to the login page). 2) If the user *is* logged in, but does *not* have the ROLE_ADMIN role, they'll be shown the 403 access denied page (which you can customize ). Another way to secure one or more controller actions is to use the #[IsGranted] attribute. In the following example, all controller actions will require the ROLE_ADMIN permission, except for adminDashboard(), which will require the ROLE_SUPER_ADMIN permission: // src/Controller/AdminController.php // ... use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted; #[IsGranted('ROLE_ADMIN')] class AdminController extends AbstractController { // Optionally, you can set a custom message that will be displayed to the user #[IsGranted('ROLE_SUPER_ADMIN', message: 'You are not allowed to access the admin dashboard.')] public function adminDashboard(): Response { // ... } } If you want to use a custom status code instead of the default one (which is 403), this can be done by setting with the statusCode argument:: // src/Controller/AdminController.php // ... use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted; #[IsGranted('ROLE_ADMIN', statusCode: 423)] class AdminController extends AbstractController { // ... } You can also set the internal exception code of the Symfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AccessDeniedException that is thrown with the exceptionCode argument:: // src/Controller/AdminController.php // ... use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted; #[IsGranted('ROLE_ADMIN', statusCode: 403, exceptionCode: 10010)] class AdminController extends AbstractController { // ... } Access Control in Templates ........................... If you want to check if the current user has a certain role, you can use the built-in is_granted() helper function in any Twig template: {% if is_granted('ROLE_ADMIN') %} <a href=\"...\">Delete</a> {% endif %} Similarly, if you want to check if a specific user has a certain role, you can use the built-in is_granted_for_user() helper function: {% if is_granted_for_user(user, 'ROLE_ADMIN') %} <a href=\"...\">Delete</a> {% endif %} Securing other Services ....................... You can check access *anywhere* in your code by injecting the Security service. For example, suppose you have a SalesReportManager service and you want to include extra details only for users that have a ROLE_SALES_ADMIN role: // src/SalesReport/SalesReportManager.php // ... use Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException; + use Symfony\\Bundle\\SecurityBundle\\Security; class SalesReportManager { + public function __construct( + private Security $security, + ) { + } public function generateReport(): void { $salesData = []; + if ($this->security->isGranted('ROLE_SALES_ADMIN')) { + $salesData['top_secret_numbers'] = rand(); + } // ... } // ... } The isGranted() method checks authorization for the currently logged-in user. If you need to check authorization for a different user or when the user session is unavailable (e.g., in a CLI context such as a message queue or cron job), you can use the isGrantedForUser() method to explicitly set the target user. The Symfony\\\\Bundle\\\\SecurityBundle\\\\Security::isGrantedForUser method was introduced in Symfony 7.3. If you're using the default services.yaml configuration , Symfony will automatically pass the security.helper to your service thanks to autowiring and the Security type-hint. You can also use a lower-level Symfony\\\\Component\\\\Security\\\\Core\\\\Authorization\\\\AuthorizationCheckerInterface service. It does the same thing as Security, but allows you to type-hint a more-specific interface. Allowing Unsecured Access (i.e. Anonymous Users) When a visitor isn't yet logged in to your", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_19", "source": "security.rst", "text": "the user session is unavailable (e.g., in a CLI context such as a message queue or cron job), you can use the isGrantedForUser() method to explicitly set the target user. The Symfony\\\\Bundle\\\\SecurityBundle\\\\Security::isGrantedForUser method was introduced in Symfony 7.3. If you're using the default services.yaml configuration , Symfony will automatically pass the security.helper to your service thanks to autowiring and the Security type-hint. You can also use a lower-level Symfony\\\\Component\\\\Security\\\\Core\\\\Authorization\\\\AuthorizationCheckerInterface service. It does the same thing as Security, but allows you to type-hint a more-specific interface. Allowing Unsecured Access (i.e. Anonymous Users) When a visitor isn't yet logged in to your website, they are treated as \"unauthenticated\" and don't have any roles. This will block them from visiting your pages if you defined an access_control rule. In the access_control configuration, you can use the PUBLIC_ACCESS security attribute to exclude some routes for unauthenticated access (e.g. the login page): # config/packages/security.yaml security: # ... access_control: # allow unauthenticated users to access the login form - { path: ^/admin/login, roles: PUBLIC_ACCESS } # but require authentication for all other admin routes - { path: ^/admin, roles: ROLE_ADMIN } <!-- config/packages/security.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <srv:container xmlns=\"http://symfony.com/schema/dic/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:srv=\"http://symfony.com/schema/dic/services\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/security https://symfony.com/schema/dic/security/security-1.0.xsd\"> <config enable-authenticator-manager=\"true\"> <!-- ... --> <access-control> <!-- allow unauthenticated users to access the login form --> <rule path=\"^/admin/login\" role=\"PUBLIC_ACCESS\"/> <!-- but require authentication for all other admin routes --> <rule path=\"^/admin\" role=\"ROLE_ADMIN\"/> </access-control> </config> </srv:container> // config/packages/security.php use Symfony\\Component\\Security\\Core\\Authorization\\Voter\\AuthenticatedVoter; use Symfony\\Config\\SecurityConfig; return static function (SecurityConfig $security): void { $security->enableAuthenticatorManager(true); // .... // allow unauthenticated users to access the login form $security->accessControl() ->path('^/admin/login') ->roles([AuthenticatedVoter::PUBLIC_ACCESS]) ; // but require authentication for all other admin routes $security->accessControl() ->path('^/admin') ->roles(['ROLE_ADMIN']) ; }; Granting Anonymous Users Access in a Custom Voter If you're using a custom voter , you can allow anonymous users access by checking if there is no user set on the token:: // src/Security/PostVoter.php namespace App\\Security; // ... use Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface; use Symfony\\Component\\Security\\Core\\Authentication\\User\\UserInterface; use Symfony\\Component\\Security\\Core\\Authorization\\Voter\\Vote; use Symfony\\Component\\Security\\Core\\Authorization\\Voter\\Voter; class PostVoter extends Voter { // ... protected function voteOnAttribute(string $attribute, $subject, TokenInterface $token, ?Vote $vote = null): bool { // ... if (!$token->getUser() instanceof UserInterface) { // the user is not authenticated, e.g. only allow them to // see public posts return $subject->isPublic(); } } } The $vote argument of the voteOnAttribute() method was introduced in Symfony 7.3. Setting Individual User Permissions Most applications require more specific access rules. For instance, a user should be able to only edit their *own* comments on a blog. Voters allow you to write *whatever* business logic you need to determine access. Using these voters is similar to the role-based access checks implemented in the previous chapters. Read /security/voters to learn how to implement your own voter. Checking to see if a User is Logged In If you *only* want to check if a user is logged in (you don't care about roles), you have the following two options. Firstly, if you've given *every* user ROLE_USER, you can check for that role. Secondly, you can use the special \"attribute\" IS_AUTHENTICATED", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_20", "source": "security.rst", "text": "to only edit their *own* comments on a blog. Voters allow you to write *whatever* business logic you need to determine access. Using these voters is similar to the role-based access checks implemented in the previous chapters. Read /security/voters to learn how to implement your own voter. Checking to see if a User is Logged In If you *only* want to check if a user is logged in (you don't care about roles), you have the following two options. Firstly, if you've given *every* user ROLE_USER, you can check for that role. Secondly, you can use the special \"attribute\" IS_AUTHENTICATED in place of a role:: // ... public function adminDashboard(): Response { $this->denyAccessUnlessGranted('IS_AUTHENTICATED'); // ... } You can use IS_AUTHENTICATED anywhere roles are used: like access_control or in Twig. IS_AUTHENTICATED isn't a role, but it kind of acts like one, and every user that has logged in will have this. Actually, there are some special attributes like this: * IS_AUTHENTICATED_FULLY: This is similar to IS_AUTHENTICATED_REMEMBERED, but stronger. Users who are logged in only because of a \"remember me cookie\" will have IS_AUTHENTICATED_REMEMBERED but will not have IS_AUTHENTICATED_FULLY. * IS_REMEMBERED: *Only* users authenticated using the remember me functionality , (i.e. a remember-me cookie). * IS_IMPERSONATOR: When the current user is impersonating another user in this session, this attribute will match. Understanding how Users are Refreshed from the Session At the end of every request (unless your firewall is stateless), your User object is serialized to the session. At the beginning of the next request, it's deserialized and then passed to your user provider to \"refresh\" it (e.g. Doctrine queries for a fresh user). Then, the two User objects (the original from the session and the refreshed User object) are \"compared\" to see if they are \"equal\". By default, the core AbstractToken class compares the return values of the getPassword(), getSalt() and getUserIdentifier() methods. If any of these are different, your user will be logged out. This is a security measure to make sure that malicious users can be de-authenticated if core user data changes. Storing the (plain or hashed) password in the session can be a security risk. To mitigate this, implement the __serialize() magic method in your user class to exclude or transform the password before storing the serialized user object in the session. Two strategies are supported: #. Remove the password completely. After unserialization, getPassword() returns null and Symfony refreshes the user without checking the password. Use this only if you store plaintext passwords (not recommended). #. Hash the password using the crc32c algorithm. Symfony will hash the password of the refreshed user and compare it to the session value. This approach avoids storing the real hash and lets you invalidate sessions on password change. Example (assuming the password is stored in a private property called password):: public function __serialize(): array { $data = (array) $this; $data[\"\\0\".self::class.\"\\0password\"] = hash('crc32c', $this->password); return $data; } Support for hashing passwords with crc32c in session serialization was introduced in Symfony 7.3. If you're", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_21", "source": "security.rst", "text": "refreshes the user without checking the password. Use this only if you store plaintext passwords (not recommended). #. Hash the password using the crc32c algorithm. Symfony will hash the password of the refreshed user and compare it to the session value. This approach avoids storing the real hash and lets you invalidate sessions on password change. Example (assuming the password is stored in a private property called password):: public function __serialize(): array { $data = (array) $this; $data[\"\\0\".self::class.\"\\0password\"] = hash('crc32c', $this->password); return $data; } Support for hashing passwords with crc32c in session serialization was introduced in Symfony 7.3. If you're having problems authenticating, it could be that you *are* authenticating successfully, but you immediately lose authentication after the first redirect. In that case, review the serialization logic (e.g. the __serialize() or serialize() methods) on your user class (if you have any) to make sure that all the fields necessary are serialized and also exclude all the fields not necessary to be serialized (e.g. Doctrine relations). Comparing Users Manually with EquatableInterface Or, if you need more control over the \"compare users\" process, make your User class implement Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\EquatableInterface. Then, your isEqualTo() method will be called when comparing users instead of the core logic. Security Events During the authentication process, multiple events are dispatched that allow you to hook into the process or customize the response sent back to the user. You can do this by creating an event listener or subscriber for these events. Every Security firewall has its own event dispatcher (security.event_dispatcher.FIREWALLNAME). Events are dispatched on both the global and the firewall-specific dispatcher. You can register on the firewall dispatcher if you want your listener to only be called for a specific firewall. For instance, if you have an api and main firewall, use this configuration to register only on the logout event in the main firewall: # config/services.yaml services: # ... App\\EventListener\\LogoutSubscriber: tags: - name: kernel.event_subscriber dispatcher: security.event_dispatcher.main <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... --> <service id=\"App\\EventListener\\LogoutSubscriber\"> <tag name=\"kernel.event_subscriber\" dispatcher=\"security.event_dispatcher.main\" /> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\EventListener\\LogoutSubscriber; return function(ContainerConfigurator $container): void { $services = $container->services(); $services->set(LogoutSubscriber::class) ->tag('kernel.event_subscriber', [ 'dispatcher' => 'security.event_dispatcher.main', ]); }; Authentication Events <object data=\"_images/security/security_events.svg\" type=\"image/svg+xml\" alt=\"A flow diagram showing the authentication events that are described in this section in a request-response cycle.\" ></object> Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\CheckPassportEvent Dispatched after the authenticator created the security passport . Listeners of this event do the actual authentication checks (like checking the passport, validating the CSRF token, etc.) Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\AuthenticationTokenCreatedEvent Dispatched after the passport was validated and the authenticator created the security token (and user). This can be used in advanced use-cases where you need to modify the created token (e.g. for multi factor authentication). Symfony\\\\Component\\\\Security\\\\Core\\\\Event\\\\AuthenticationSuccessEvent Dispatched when authentication is nearing success. This is the last event that can make an authentication fail by throwing an AuthenticationException. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LoginSuccessEvent Dispatched after authentication was fully successful. Listeners to this event can modify the response sent back to the user. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LoginFailureEvent Dispatched after an AuthenticationException", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_22", "source": "security.rst", "text": "of this event do the actual authentication checks (like checking the passport, validating the CSRF token, etc.) Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\AuthenticationTokenCreatedEvent Dispatched after the passport was validated and the authenticator created the security token (and user). This can be used in advanced use-cases where you need to modify the created token (e.g. for multi factor authentication). Symfony\\\\Component\\\\Security\\\\Core\\\\Event\\\\AuthenticationSuccessEvent Dispatched when authentication is nearing success. This is the last event that can make an authentication fail by throwing an AuthenticationException. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LoginSuccessEvent Dispatched after authentication was fully successful. Listeners to this event can modify the response sent back to the user. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LoginFailureEvent Dispatched after an AuthenticationException was thrown during authentication. Listeners to this event can modify the error response sent back to the user. Other Events Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\InteractiveLoginEvent Dispatched after authentication was fully successful only when the authenticator implements Symfony\\\\Component\\\\Security\\\\Http\\\\Authenticator\\\\InteractiveAuthenticatorInterface, which indicates login requires explicit user action (e.g. a login form). Listeners to this event can modify the response sent back to the user. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LogoutEvent Dispatched just before a user logs out of your application. See security-logging-out. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\TokenDeauthenticatedEvent Dispatched when a user is deauthenticated, for instance because the password was changed. See user_session_refresh. Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\SwitchUserEvent Dispatched after impersonation is completed. See /security/impersonating_user. Frequently Asked Questions **Can I have Multiple Firewalls?** Yes! However, each firewall is like a separate security system: being authenticated in one firewall doesn't make you authenticated in another one. Each firewall can have multiple ways of allowing authentication (e.g. form login, and API key authentication). If you want to share authentication between firewalls, you have to explicitly specify the same reference-security-firewall-context for different firewalls. **Security doesn't seem to work on my Error Pages** As routing is done *before* security, 404 error pages are not covered by any firewall. This means you can't check for security or even access the user object on these pages. See /controller/error_pages for more details. **My Authentication Doesn't Seem to Work: No Errors, but I'm Never Logged In** Sometimes authentication may be successful, but after redirecting, you're logged out immediately due to a problem loading the User from the session. To see if this is an issue, check your log file (var/log/dev.log) for the log message. **Cannot refresh token because user has changed** If you see this, there are two possible causes. First, there may be a problem loading your User from the session. See user_session_refresh. Second, if certain user information was changed in the database since the last page refresh, Symfony will purposely log out the user for security reasons. Learn More Authentication (Identifying/Logging in the User) :maxdepth: 1 security/passwords security/ldap security/remember_me security/impersonating_user security/user_checkers security/firewall_restriction security/csrf security/form_login security/custom_authenticator security/entry_point Authorization (Denying Access) :maxdepth: 1 security/voters security/access_control security/expressions security/access_denied_handler security/force_https", "title": "Security", "category": "security"}
{"chunk_id": "security.rst_fixed_23", "source": "security.rst", "text": "Symfony will purposely log out the user for security reasons. Learn More Authentication (Identifying/Logging in the User) :maxdepth: 1 security/passwords security/ldap security/remember_me security/impersonating_user security/user_checkers security/firewall_restriction security/csrf security/form_login security/custom_authenticator security/entry_point Authorization (Denying Access) :maxdepth: 1 security/voters security/access_control security/expressions security/access_denied_handler security/force_https", "title": "Security", "category": "security"}
{"chunk_id": "serializer.rst_fixed_0", "source": "serializer.rst", "text": "How to Use the Serializer Symfony provides a serializer to transform data structures from one format to PHP objects and the other way around. This is most commonly used when building an API or communicating with third party APIs. The serializer can transform an incoming JSON request payload to a PHP object that is consumed by your application. Then, when generating the response, you can use the serializer to transform the PHP objects back to a JSON response. It can also be used to, for instance, load CSV configuration data as PHP objects, or even to transform between formats (e.g. YAML to XML). Installation In applications using Symfony Flex , run this command to install the serializer Symfony pack before using it: $ composer require symfony/serializer-pack The serializer pack also installs some commonly used optional dependencies of the Serializer component. When using this component outside the Symfony framework, you might want to start with the symfony/serializer package and install optional dependencies if you need them. A popular alternative to the Symfony Serializer component is the third-party library, `JMS serializer`_. Serializing an Object For this example, assume the following class exists in your project:: // src/Model/Person.php namespace App\\Model; class Person { public function __construct( private int $age, private string $name, private bool $sportsperson ) { } public function getAge(): int { return $this->age; } public function getName(): string { return $this->name; } public function isSportsperson(): bool { return $this->sportsperson; } } If you want to transform objects of this type into a JSON structure (e.g. to send them via an API response), get the serializer service by using the Symfony\\\\Component\\\\Serializer\\\\SerializerInterface parameter type: // src/Controller/PersonController.php namespace App\\Controller; use App\\Model\\Person; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\JsonResponse; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Serializer\\SerializerInterface; class PersonController extends AbstractController { public function index(SerializerInterface $serializer): Response { $person = new Person('Jane Doe', 39, false); $jsonContent = $serializer->serialize($person, 'json'); // $jsonContent contains {\"name\":\"Jane Doe\",\"age\":39,\"sportsperson\":false} return JsonResponse::fromJsonString($jsonContent); } } use App\\Model\\Person; use Symfony\\Component\\Serializer\\Encoder\\JsonEncoder; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; use Symfony\\Component\\Serializer\\Serializer; $encoders = [new JsonEncoder()]; $normalizers = [new ObjectNormalizer()]; $serializer = new Serializer($normalizers, $encoders); $person = new Person('Jane Done', 39, false); $jsonContent = $serializer->serialize($person, 'json'); // $jsonContent contains {\"name\":\"Jane Doe\",\"age\":39,\"sportsperson\":false} The first parameter of the Symfony\\\\Component\\\\Serializer\\\\Serializer::serialize is the object to be serialized and the second is used to choose the proper encoder (i.e. format), in this case the Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\JsonEncoder. When your controller class extends AbstractController (like in the example above), you can simplify your controller by using the Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::json method to create a JSON response from an object using the Serializer:: class PersonController extends AbstractController { public function index(): Response { $person = new Person('Jane Doe', 39, false); // when the Serializer is not available, this will use json_encode() return $this->json($person); } } Using the Serializer in Twig Templates You can also serialize objects in any Twig template using the serialize filter: {{ person|serialize(format = 'json') }} See the twig reference for more information. Deserializing an Object APIs often also need to convert a formatted request body (e.g. JSON) to a PHP object. This process is called", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_1", "source": "serializer.rst", "text": "the Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::json method to create a JSON response from an object using the Serializer:: class PersonController extends AbstractController { public function index(): Response { $person = new Person('Jane Doe', 39, false); // when the Serializer is not available, this will use json_encode() return $this->json($person); } } Using the Serializer in Twig Templates You can also serialize objects in any Twig template using the serialize filter: {{ person|serialize(format = 'json') }} See the twig reference for more information. Deserializing an Object APIs often also need to convert a formatted request body (e.g. JSON) to a PHP object. This process is called *deserialization* (also known as \"hydration\"): // src/Controller/PersonController.php namespace App\\Controller; // ... use Symfony\\Component\\HttpFoundation\\Exception\\BadRequestException; use Symfony\\Component\\HttpFoundation\\Request; class PersonController extends AbstractController { // ... public function create(Request $request, SerializerInterface $serializer): Response { if ('json' !== $request->getContentTypeFormat()) { throw new BadRequestException('Unsupported content format'); } $jsonData = $request->getContent(); $person = $serializer->deserialize($jsonData, Person::class, 'json'); // ... do something with $person and return a response } } use App\\Model\\Person; use Symfony\\Component\\Serializer\\Encoder\\JsonEncoder; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; use Symfony\\Component\\Serializer\\Serializer; // ... $jsonData = ...; // fetch JSON from the request $person = $serializer->deserialize($jsonData, Person::class, 'json'); In this case, Symfony\\\\Component\\\\Serializer\\\\Serializer::deserialize needs three parameters: #. The data to be decoded #. The name of the class this information will be decoded to #. The name of the encoder used to convert the data to an array (i.e. the input format) When sending a request to this controller (e.g. {\"first_name\":\"John Doe\",\"age\":54,\"sportsperson\":true}), the serializer will create a new instance of Person and sets the properties to the values from the given JSON. By default, additional attributes that are not mapped to the denormalized object will be ignored by the Serializer component. For instance, if a request to the above controller contains {..., \"city\": \"Paris\"}, the city field will be ignored. You can also throw an exception in these cases using the serializer context you'll learn about later. You can also deserialize data into an existing object instance (e.g. when updating data). See Deserializing in an Existing Object . The Serialization Process: Normalizers and Encoders The serializer uses a two-step process when (de)serializing objects: <object data=\"_images/serializer/serializer_workflow.svg\" type=\"image/svg+xml\" alt=\"A flow diagram showing how objects are serialized/deserialized. This is described in the subsequent paragraph.\" ></object> In both directions, data is always first converted to an array. This splits the process in two separate responsibilities: Normalizers These classes convert **objects** into **arrays** and vice versa. They do the heavy lifting of finding out which class properties to serialize, what value they hold and what name they should have. Encoders Encoders convert **arrays** into a specific **format** and the other way around. Each encoder knows exactly how to parse and generate a specific format, for instance JSON or XML. Internally, the Serializer class uses a sorted list of normalizers and one encoder for the specific format when (de)serializing an object. There are several normalizers configured in the default serializer service. The most important normalizer is the Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ObjectNormalizer. This normalizer uses reflection and the PropertyAccess component to transform between any", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_2", "source": "serializer.rst", "text": "heavy lifting of finding out which class properties to serialize, what value they hold and what name they should have. Encoders Encoders convert **arrays** into a specific **format** and the other way around. Each encoder knows exactly how to parse and generate a specific format, for instance JSON or XML. Internally, the Serializer class uses a sorted list of normalizers and one encoder for the specific format when (de)serializing an object. There are several normalizers configured in the default serializer service. The most important normalizer is the Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ObjectNormalizer. This normalizer uses reflection and the PropertyAccess component to transform between any object and an array. You'll learn more about this and other normalizers later. The default serializer is also configured with some encoders, covering the common formats used by HTTP applications: * Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\JsonEncoder * Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\XmlEncoder * Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\CsvEncoder * Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\YamlEncoder Read more about these encoders and their configuration in /serializer/encoders. The `API Platform`_ project provides encoders for more advanced formats: * `JSON-LD`_ along with the `Hydra Core Vocabulary`_ * `OpenAPI`_ v2 (formerly Swagger) and v3 * `GraphQL`_ * `JSON:API`_ * `HAL`_ Serializer Context The serializer, and its normalizers and encoders, are configured through the *serializer context*. This context can be configured in multiple places: * Globally through the framework configuration * While serializing/deserializing * For a specific property You can use all three options at the same time. When the same setting is configured in multiple places, the latter in the list above will override the previous one (e.g. the setting on a specific property overrides the one configured globally). Configure a Default Context ........................... You can configure a default context in the framework configuration, for instance to disallow extra fields while deserializing: # config/packages/serializer.yaml framework: serializer: default_context: allow_extra_attributes: false <!-- config/packages/serializer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:serializer> <framework:default-context> <framework:allow-extra-attributes>false</framework:allow-extra-attributes> </framework:default-context> </framework:serializer> </framework:config> </container> // config/packages/serializer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->serializer() ->defaultContext([ 'allow_extra_attributes' => false, ]) ; }; use Symfony\\Component\\Serializer\\NameConverter\\CamelCaseToSnakeCaseNameConverter; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; // ... $normalizers = [ new ObjectNormalizer(null, null, null, null, null, null, [ 'allow_extra_attributes' => false, ]), ]; $serializer = new Serializer($normalizers, $encoders); Pass Context while Serializing/Deserializing ............................................ You can also configure the context for a single call to serialize()/deserialize(). For instance, you can skip properties with a null value only for one serialize call:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer; // ... $serializer->serialize($person, 'json', [ AbstractObjectNormalizer::SKIP_NULL_VALUES => true ]); // next calls to serialize() will NOT skip null values Using Context Builders You can use \"context builders\" to help define the (de)serialization context. Context builders are PHP objects that provide autocompletion, validation, and documentation of context options:: use Symfony\\Component\\Serializer\\Context\\Normalizer\\DateTimeNormalizerContextBuilder; $contextBuilder = (new DateTimeNormalizerContextBuilder()) ->withFormat('Y-m-d H:i:s'); $serializer->serialize($something, 'json', $contextBuilder->toArray()); Each normalizer/encoder has its related context builder. To create a more complex (de)serialization context, you can chain them using the withContext() method:: use Symfony\\Component\\Serializer\\Context\\Encoder\\CsvEncoderContextBuilder; use Symfony\\Component\\Serializer\\Context\\Normalizer\\ObjectNormalizerContextBuilder; $initialContext = [ 'custom_key' => 'custom_value', ]; $contextBuilder = (new ObjectNormalizerContextBuilder()) ->withContext($initialContext) ->withGroups(['group1', 'group2']); $contextBuilder = (new CsvEncoderContextBuilder()) ->withContext($contextBuilder) ->withDelimiter(';'); $serializer->serialize($something, 'csv', $contextBuilder->toArray()); You can", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_3", "source": "serializer.rst", "text": "// next calls to serialize() will NOT skip null values Using Context Builders You can use \"context builders\" to help define the (de)serialization context. Context builders are PHP objects that provide autocompletion, validation, and documentation of context options:: use Symfony\\Component\\Serializer\\Context\\Normalizer\\DateTimeNormalizerContextBuilder; $contextBuilder = (new DateTimeNormalizerContextBuilder()) ->withFormat('Y-m-d H:i:s'); $serializer->serialize($something, 'json', $contextBuilder->toArray()); Each normalizer/encoder has its related context builder. To create a more complex (de)serialization context, you can chain them using the withContext() method:: use Symfony\\Component\\Serializer\\Context\\Encoder\\CsvEncoderContextBuilder; use Symfony\\Component\\Serializer\\Context\\Normalizer\\ObjectNormalizerContextBuilder; $initialContext = [ 'custom_key' => 'custom_value', ]; $contextBuilder = (new ObjectNormalizerContextBuilder()) ->withContext($initialContext) ->withGroups(['group1', 'group2']); $contextBuilder = (new CsvEncoderContextBuilder()) ->withContext($contextBuilder) ->withDelimiter(';'); $serializer->serialize($something, 'csv', $contextBuilder->toArray()); You can also create your context builders to have autocompletion, validation, and documentation for your custom context values. Configure Context on a Specific Property ........................................ At last, you can also configure context values on a specific object property. For instance, to configure the datetime format: // src/Model/Person.php // ... use Symfony\\Component\\Serializer\\Attribute\\Context; use Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer; class Person { #[Context([DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'])] public \\DateTimeImmutable $createdAt; // ... } # config/serializer/person.yaml App\\Model\\Person: attributes: createdAt: contexts: - context: { datetime_format: 'Y-m-d' } <!-- config/serializer/person.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\Person\"> <attribute name=\"createdAt\"> <context> <entry name=\"datetime_format\">Y-m-d</entry> </context> </attribute> </class> </serializer> When using YAML or XML, the mapping files must be placed in one of these locations: * All *.yaml and *.xml files in the config/serializer/ directory. * The serialization.yaml or serialization.xml file in the Resources/config/ directory of a bundle; * All *.yaml and *.xml files in the Resources/config/serialization/ directory of a bundle. You can also specify a context specific to normalization or denormalization: // src/Model/Person.php // ... use Symfony\\Component\\Serializer\\Attribute\\Context; use Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer; class Person { #[Context( normalizationContext: [DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'], denormalizationContext: [DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339], )] public \\DateTimeImmutable $createdAt; // ... } # config/serializer/person.yaml App\\Model\\Person: attributes: createdAt: contexts: - normalization_context: { datetime_format: 'Y-m-d' } denormalization_context: { datetime_format: !php/const \\DateTime::RFC3339 } <!-- config/serializer/person.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\Person\"> <attribute name=\"createdAt\"> <normalization-context> <entry name=\"datetime_format\">Y-m-d</entry> </normalization-context> <denormalization-context> <entry name=\"datetime_format\">Y-m-d\\TH:i:sP</entry> </denormalization-context> </attribute> </class> </serializer> You can also restrict the usage of a context to some groups : // src/Model/Person.php // ... use Symfony\\Component\\Serializer\\Attribute\\Context; use Symfony\\Component\\Serializer\\Attribute\\Groups; use Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer; class Person { #[Groups(['extended'])] #[Context([DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339])] #[Context( context: [DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339_EXTENDED], groups: ['extended'], )] public \\DateTimeImmutable $createdAt; // ... } # config/serializer/person.yaml App\\Model\\Person: attributes: createdAt: groups: [extended] contexts: - context: { datetime_format: !php/const \\DateTime::RFC3339 } - context: { datetime_format: !php/const \\DateTime::RFC3339_EXTENDED } groups: [extended] <!-- config/serializer/person.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\Person\"> <attribute name=\"createdAt\"> <group>extended</group> <context> <entry name=\"datetime_format\">Y-m-d\\TH:i:sP</entry> </context> <context> <entry name=\"datetime_format\">Y-m-d\\TH:i:s.vP</entry> <group>extended</group> </context> </attribute> </class> </serializer> The attribute can be repeated as much as needed on a single property. Context without group is always applied first. Then context for the matching groups are merged in the provided order. If you repeat the same context in multiple properties, consider using the #[Context] attribute on your class to apply that context configuration to all the properties of the class:: namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\Context; use Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer;", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_4", "source": "serializer.rst", "text": "} groups: [extended] <!-- config/serializer/person.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\Person\"> <attribute name=\"createdAt\"> <group>extended</group> <context> <entry name=\"datetime_format\">Y-m-d\\TH:i:sP</entry> </context> <context> <entry name=\"datetime_format\">Y-m-d\\TH:i:s.vP</entry> <group>extended</group> </context> </attribute> </class> </serializer> The attribute can be repeated as much as needed on a single property. Context without group is always applied first. Then context for the matching groups are merged in the provided order. If you repeat the same context in multiple properties, consider using the #[Context] attribute on your class to apply that context configuration to all the properties of the class:: namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\Context; use Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer; #[Context([DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339])] #[Context( context: [DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339_EXTENDED], groups: ['extended'], )] class Person { // ... } Serializing JSON Using Streams Symfony can encode PHP data structures to JSON streams and decode JSON streams back into PHP data structures. To do this, it relies on the JsonStreamer component , which is designed for high efficiency and can process large JSON data incrementally, without needing to load the entire content into memory. When deciding between the Serializer component and the JsonStreamer component, consider the following: * **Serializer Component**: Best suited for use cases that require flexibility, such as dynamically manipulating object structures using normalizers and denormalizers, or handling complex objects with multiple serialization formats. It also supports output formats beyond JSON (including your own custom ones). * **JsonStreamer Component**: Best suited for simple objects and scenarios that demand high performance and low memory usage. It's particularly effective for processing very large JSON datasets or when streaming JSON in real-time without loading the entire dataset into memory. The choice depends on your specific use case. The JsonStreamer component is tailored for performance and memory efficiency, whereas the Serializer component provides greater flexibility and broader format support. Read more about streaming JSON . Serializing to or from PHP Arrays The default Symfony\\\\Component\\\\Serializer\\\\Serializer can also be used to only perform one step of the two step serialization process by using the respective interface: use Symfony\\Component\\Serializer\\Encoder\\DecoderInterface; use Symfony\\Component\\Serializer\\Encoder\\EncoderInterface; use Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface; use Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface; // ... class PersonController extends AbstractController { public function index(DenormalizerInterface&NormalizerInterface $serializer): Response { $person = new Person('Jane Doe', 39, false); // use normalize() to convert a PHP object to an array $personArray = $serializer->normalize($person, 'json'); // ...and denormalize() to convert an array back to a PHP object $personCopy = $serializer->denormalize($personArray, Person::class); // ... } public function json(DecoderInterface&EncoderInterface $serializer): Response { $data = ['name' => 'Jane Doe']; // use encode() to transform PHP arrays into another format $json = $serializer->encode($data, 'json'); // ...and decode() to transform any format to just PHP arrays (instead of objects) $data = $serializer->decode('{\"name\":\"Charlie Doe\"}', 'json'); // $data contains ['name' => 'Charlie Doe'] } } use App\\Model\\Person; use Symfony\\Component\\Serializer\\Encoder\\JsonEncoder; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; use Symfony\\Component\\Serializer\\Serializer; $encoders = [new JsonEncoder()]; $normalizers = [new ObjectNormalizer()]; $serializer = new Serializer($normalizers, $encoders); // use normalize() to convert a PHP object to an array $personArray = $serializer->normalize($person, 'json'); // ...and denormalize() to convert an array back to a PHP object $personCopy = $serializer->denormalize($personArray, Person::class); $data = ['name'", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_5", "source": "serializer.rst", "text": "=> 'Jane Doe']; // use encode() to transform PHP arrays into another format $json = $serializer->encode($data, 'json'); // ...and decode() to transform any format to just PHP arrays (instead of objects) $data = $serializer->decode('{\"name\":\"Charlie Doe\"}', 'json'); // $data contains ['name' => 'Charlie Doe'] } } use App\\Model\\Person; use Symfony\\Component\\Serializer\\Encoder\\JsonEncoder; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; use Symfony\\Component\\Serializer\\Serializer; $encoders = [new JsonEncoder()]; $normalizers = [new ObjectNormalizer()]; $serializer = new Serializer($normalizers, $encoders); // use normalize() to convert a PHP object to an array $personArray = $serializer->normalize($person, 'json'); // ...and denormalize() to convert an array back to a PHP object $personCopy = $serializer->denormalize($personArray, Person::class); $data = ['name' => 'Jane Doe']; // use encode() to transform PHP arrays into another format $json = $serializer->encode($data, 'json'); // ...and decode() to transform any format to just PHP arrays (instead of objects) $data = $serializer->decode('{\"name\":\"Charlie Doe\"}', 'json'); // $data contains ['name' => 'Charlie Doe'] Ignoring Properties The ObjectNormalizer normalizes *all* properties of an object and all methods starting with get*(), has*(), is*() and can*(). Some properties or methods should never be serialized. You can exclude them using the #[Ignore] attribute: // src/Model/Person.php namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\Ignore; class Person { // ... #[Ignore] public function isPotentiallySpamUser(): bool { // ... } } App\\Model\\Person: attributes: potentiallySpamUser: ignore: true <?xml version=\"1.0\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\Person\"> <attribute name=\"potentiallySpamUser\" ignore=\"true\"/> </class> </serializer> The potentiallySpamUser property will now never be serialized: use App\\Model\\Person; // ... $person = new Person('Jane Doe', 32, false); $json = $serializer->serialize($person, 'json'); // $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false} $person1 = $serializer->deserialize( '{\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false\",\"potentiallySpamUser\":false}', Person::class, 'json' ); // the \"potentiallySpamUser\" value is ignored use App\\Model\\Person; use Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory; use Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; use Symfony\\Component\\Serializer\\Serializer; // ... // you need to pass a class metadata factory with a loader to the // ObjectNormalizer when reading mapping information like Ignore or Groups. // E.g. when using PHP attributes: $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader()); $normalizers = [new ObjectNormalizer($classMetadataFactory)]; $serializer = new Serializer($normalizers, $encoders); $person = new Person('Jane Doe', 32, false); $json = $serializer->serialize($person, 'json'); // $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false} $person1 = $serializer->deserialize( '{\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false\",\"potentiallySpamUser\":false}', Person::class, 'json' ); // the \"potentiallySpamUser\" value is ignored Ignoring Attributes Using the Context You can also pass an array of attribute names to ignore at runtime using the ignored_attributes context options:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer; // ... $person = new Person('Jane Doe', 32, false); $json = $serializer->serialize($person, 'json', [ AbstractNormalizer::IGNORED_ATTRIBUTES => ['age'], ]); // $json contains {\"name\":\"Jane Doe\",\"sportsperson\":false} However, this can quickly become unmaintainable if used excessively. See the next section about *serialization groups* for a better solution. Selecting Specific Properties Instead of excluding a property or method in all situations, you might need to exclude some properties in one place, but serialize them in another. Groups are a handy way to achieve this. You can add the #[Groups] attribute to your class: // src/Model/Person.php namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\Groups; class Person { #[Groups([\"admin-view\"])] private int $age; #[Groups([\"public-view\"])] private string $name; #[Groups([\"public-view\"])] private bool $sportsperson; // ... } # config/serializer/person.yaml App\\Model\\Person: attributes: age: groups: ['admin-view'] name: groups: ['public-view'] sportsperson: groups: ['public-view'] <!--", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_6", "source": "serializer.rst", "text": "quickly become unmaintainable if used excessively. See the next section about *serialization groups* for a better solution. Selecting Specific Properties Instead of excluding a property or method in all situations, you might need to exclude some properties in one place, but serialize them in another. Groups are a handy way to achieve this. You can add the #[Groups] attribute to your class: // src/Model/Person.php namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\Groups; class Person { #[Groups([\"admin-view\"])] private int $age; #[Groups([\"public-view\"])] private string $name; #[Groups([\"public-view\"])] private bool $sportsperson; // ... } # config/serializer/person.yaml App\\Model\\Person: attributes: age: groups: ['admin-view'] name: groups: ['public-view'] sportsperson: groups: ['public-view'] <!-- config/serializer/person.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\Person\"> <attribute name=\"age\"> <group>admin-view</group> </attribute> <attribute name=\"name\"> <group>public-view</group> </attribute> <attribute name=\"sportsperson\"> <group>public-view</group> </attribute> </class> </serializer> You can now choose which groups to use when serializing:: $json = $serializer->serialize( $person, 'json', ['groups' => 'public-view'] ); // $json contains {\"name\":\"Jane Doe\",\"sportsperson\":false} // you can also pass an array of groups $json = $serializer->serialize( $person, 'json', ['groups' => ['public-view', 'admin-view']] ); // $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false} // or use the special \"*\" value to select all groups $json = $serializer->serialize( $person, 'json', ['groups' => '*'] ); // $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false} Using the Serialization Context At last, you can also use the attributes context option to select properties at runtime:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer; // ... $json = $serializer->serialize($person, 'json', [ AbstractNormalizer::ATTRIBUTES => ['name', 'company' => ['name']] ]); // $json contains {\"name\":\"Dunglas\",\"company\":{\"name\":\"Les-Tilleuls.coop\"}} Only attributes that are not ignored are available. If serialization groups are set, only attributes allowed by those groups can be used. Handling Arrays The serializer is capable of handling arrays of objects. Serializing arrays works just like serializing a single object:: use App\\Model\\Person; // ... $person1 = new Person('Jane Doe', 39, false); $person2 = new Person('John Smith', 52, true); $persons = [$person1, $person2]; $jsonContent = $serializer->serialize($persons, 'json'); // $jsonContent contains [{\"name\":\"Jane Doe\",\"age\":39,\"sportsman\":false},{\"name\":\"John Smith\",\"age\":52,\"sportsman\":true}] To deserialize a list of objects, you have to append [] to the type parameter:: // ... $jsonData = ...; // the serialized JSON data from the previous example $persons = $serializer->deserialize($JsonData, Person::class.'[]', 'json'); For nested classes, you have to add a PHPDoc type to the property, constructor or setter:: // src/Model/UserGroup.php namespace App\\Model; class UserGroup { /** * @param Person[] $members */ public function __construct( private array $members, ) { } // or if you're using a setter /** * @param Person[] $members */ public function setMembers(array $members): void { $this->members = $members; } // ... } The Serializer also supports array types used in static analysis, like list<Person> and array<Person>. Make sure the phpstan/phpdoc-parser and phpdocumentor/reflection-docblock packages are installed (these are part of the symfony/serializer-pack). Deserializing Nested Structures Some APIs might provide verbose nested structures that you want to flatten in the PHP object. For instance, imagine a JSON response like this: { \"id\": \"123\", \"profile\": { \"username\": \"jdoe\", \"personal_information\": { \"full_name\": \"Jane Doe\" } } } You may wish to serialize this information to a single PHP object like:: class Person { private", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_7", "source": "serializer.rst", "text": "function setMembers(array $members): void { $this->members = $members; } // ... } The Serializer also supports array types used in static analysis, like list<Person> and array<Person>. Make sure the phpstan/phpdoc-parser and phpdocumentor/reflection-docblock packages are installed (these are part of the symfony/serializer-pack). Deserializing Nested Structures Some APIs might provide verbose nested structures that you want to flatten in the PHP object. For instance, imagine a JSON response like this: { \"id\": \"123\", \"profile\": { \"username\": \"jdoe\", \"personal_information\": { \"full_name\": \"Jane Doe\" } } } You may wish to serialize this information to a single PHP object like:: class Person { private int $id; private string $username; private string $fullName; } Use the #[SerializedPath] to specify the path of the nested property using valid PropertyAccess syntax : namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\SerializedPath; class Person { private int $id; #[SerializedPath('[profile][username]')] private string $username; #[SerializedPath('[profile][personal_information][full_name]')] private string $fullName; } App\\Model\\Person: attributes: username: serialized_path: '[profile][username]' fullName: serialized_path: '[profile][personal_information][full_name]' <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\Person\"> <attribute name=\"username\" serialized-path=\"[profile][username]\"/> <attribute name=\"fullName\" serialized-path=\"[profile][personal_information][full_name]\"/> </class> </serializer> The SerializedPath cannot be used in combination with a SerializedName for the same property. The #[SerializedPath] attribute also applies to the serialization of a PHP object:: use App\\Model\\Person; // ... $person = new Person(123, 'jdoe', 'Jane Doe'); $jsonContent = $serializer->serialize($person, 'json'); // $jsonContent contains {\"id\":123,\"profile\":{\"username\":\"jdoe\",\"personal_information\":{\"full_name\":\"Jane Doe\"}}} Converting Property Names when Serializing and Deserializing Sometimes serialized attributes must be named differently than properties or getter/setter methods of PHP classes. This can be achieved using name converters. The serializer service uses the Symfony\\\\Component\\\\Serializer\\\\NameConverter\\\\MetadataAwareNameConverter. With this name converter, you can change the name of an attribute using the #[SerializedName] attribute: // src/Model/Person.php namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\SerializedName; class Person { #[SerializedName('customer_name')] private string $name; // ... } # config/serializer/person.yaml App\\Entity\\Person: attributes: name: serialized_name: customer_name <!-- config/serializer/person.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Entity\\Person\"> <attribute name=\"name\" serialized-name=\"customer_name\"/> </class> </serializer> This custom mapping is used to convert property names when serializing and deserializing objects: // ... $json = $serializer->serialize($person, 'json'); // $json contains {\"customer_name\":\"Jane Doe\", ...} use App\\Model\\Person; use Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory; use Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader; use Symfony\\Component\\Serializer\\NameConverter\\MetadataAwareNameConverter; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; use Symfony\\Component\\Serializer\\Serializer; // ... // Configure a loader to retrieve mapping information like SerializedName. // E.g. when using PHP attributes: $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader()); $nameConverter = new MetadataAwareNameConverter($classMetadataFactory); $normalizers = [ new ObjectNormalizer($classMetadataFactory, $nameConverter), ]; $serializer = new Serializer($normalizers, $encoders); $person = new Person('Jane Doe', 32, false); $json = $serializer->serialize($person, 'json'); // $json contains {\"customer_name\":\"Jane Doe\", ...} You can also create a custom name converter class. Read more about this in /serializer/custom_name_converter. CamelCase to snake_case In many formats, it's common to use underscores to separate words (also known as snake_case). However, in Symfony applications is common to use camelCase to name properties. Symfony provides a built-in name converter designed to transform between snake_case and CamelCased styles during serialization and deserialization processes. You can use it instead of the metadata aware name converter by setting the name_converter setting to serializer.name_converter.camel_case_to_snake_case: # config/packages/serializer.yaml framework: serializer: name_converter: 'serializer.name_converter.camel_case_to_snake_case' <!-- config/packages/serializer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\"", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_8", "source": "serializer.rst", "text": "// $json contains {\"customer_name\":\"Jane Doe\", ...} You can also create a custom name converter class. Read more about this in /serializer/custom_name_converter. CamelCase to snake_case In many formats, it's common to use underscores to separate words (also known as snake_case). However, in Symfony applications is common to use camelCase to name properties. Symfony provides a built-in name converter designed to transform between snake_case and CamelCased styles during serialization and deserialization processes. You can use it instead of the metadata aware name converter by setting the name_converter setting to serializer.name_converter.camel_case_to_snake_case: # config/packages/serializer.yaml framework: serializer: name_converter: 'serializer.name_converter.camel_case_to_snake_case' <!-- config/packages/serializer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:serializer name-converter=\"serializer.name_converter.camel_case_to_snake_case\" /> </framework:config> </container> // config/packages/serializer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->serializer() ->nameConverter('serializer.name_converter.camel_case_to_snake_case') ; }; use Symfony\\Component\\Serializer\\NameConverter\\CamelCaseToSnakeCaseNameConverter; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; // ... $normalizers = [ new ObjectNormalizer(null, new CamelCaseToSnakeCaseNameConverter()), ]; $serializer = new Serializer($normalizers, $encoders); snake_case to CamelCase In Symfony applications, it is common to use camelCase for naming properties. However some packages may follow a snake_case convention. Symfony provides a built-in name converter designed to transform between CamelCase and snake_case styles during serialization and deserialization processes. You can use it instead of the metadata-aware name converter by setting the name_converter setting to serializer.name_converter.snake_case_to_camel_case: # config/packages/serializer.yaml framework: serializer: name_converter: 'serializer.name_converter.snake_case_to_camel_case' <!-- config/packages/serializer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:serializer name-converter=\"serializer.name_converter.snake_case_to_camel_case\" /> </framework:config> </container> // config/packages/serializer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->serializer() ->nameConverter('serializer.name_converter.snake_case_to_camel_case') ; }; use Symfony\\Component\\Serializer\\NameConverter\\SnakeCaseToCamelCaseNameConverter; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; // ... $normalizers = [ new ObjectNormalizer(null, new SnakeCaseToCamelCaseNameConverter()), ]; $serializer = new Serializer($normalizers, $encoders); The snake_case to CamelCase converter was introduced in Symfony 7.2. Serializer Normalizers By default, the serializer service is configured with the following normalizers (in order of priority): Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\UnwrappingDenormalizer Can be used to only denormalize a part of the input, read more about this later in this article . Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ProblemNormalizer Normalizes Symfony\\\\Component\\\\ErrorHandler\\\\Exception\\\\FlattenException errors according to the API Problem spec `RFC 7807`_. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\UidNormalizer Normalizes objects that extend Symfony\\\\Component\\\\Uid\\\\AbstractUid. The default normalization format for objects that implement Symfony\\\\Component\\\\Uid\\\\Uuid is the `RFC 4122`_ format (example: d9e7a184-5d5b-11ea-a62a-3499710062d0). The default normalization format for objects that implement Symfony\\\\Component\\\\Uid\\\\Ulid is the Base 32 format (example: 01E439TP9XJZ9RPFH3T1PYBCR8). You can change the string format by setting the serializer context option UidNormalizer::NORMALIZATION_FORMAT_KEY to UidNormalizer::NORMALIZATION_FORMAT_BASE58, UidNormalizer::NORMALIZATION_FORMAT_BASE32 or UidNormalizer::NORMALIZATION_FORMAT_RFC4122. Also it can denormalize uuid or ulid strings to Symfony\\\\Component\\\\Uid\\\\Uuid or Symfony\\\\Component\\\\Uid\\\\Ulid. The format does not matter. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateTimeNormalizer This normalizes between DateTimeInterface objects (e.g. DateTime and DateTimeImmutable) and strings, integers or floats. DateTime and DateTimeImmutable) into strings, integers or floats. By default, it converts them to strings using the `RFC 3339`_ format. Use DateTimeNormalizer::FORMAT_KEY and DateTimeNormalizer::TIMEZONE_KEY to change the format. To convert the objects to integers or floats, set the serializer context option DateTimeNormalizer::CAST_KEY to int or float. The DateTimeNormalizer::CAST_KEY context option was introduced in Symfony 7.1. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ConstraintViolationListNormalizer This normalizer converts objects that implement Symfony\\\\Component\\\\Validator\\\\ConstraintViolationListInterface into a list of errors according to the `RFC 7807`_ standard. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateTimeZoneNormalizer This normalizer converts between DateTimeZone objects and strings", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_9", "source": "serializer.rst", "text": "not matter. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateTimeNormalizer This normalizes between DateTimeInterface objects (e.g. DateTime and DateTimeImmutable) and strings, integers or floats. DateTime and DateTimeImmutable) into strings, integers or floats. By default, it converts them to strings using the `RFC 3339`_ format. Use DateTimeNormalizer::FORMAT_KEY and DateTimeNormalizer::TIMEZONE_KEY to change the format. To convert the objects to integers or floats, set the serializer context option DateTimeNormalizer::CAST_KEY to int or float. The DateTimeNormalizer::CAST_KEY context option was introduced in Symfony 7.1. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ConstraintViolationListNormalizer This normalizer converts objects that implement Symfony\\\\Component\\\\Validator\\\\ConstraintViolationListInterface into a list of errors according to the `RFC 7807`_ standard. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateTimeZoneNormalizer This normalizer converts between DateTimeZone objects and strings that represent the name of the timezone according to the `list of PHP timezones`_. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateIntervalNormalizer This normalizes between DateInterval objects and strings. By default, the P%yY%mM%dDT%hH%iM%sS format is used. Use the DateIntervalNormalizer::FORMAT_KEY option to change this. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\FormErrorNormalizer This normalizer works with classes that implement Symfony\\\\Component\\\\Form\\\\FormInterface. It will get errors from the form and normalize them according to the API Problem spec `RFC 7807`_. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\TranslatableNormalizer This normalizer converts objects implementing Symfony\\\\Contracts\\\\Translation\\\\TranslatableInterface to a translated string using the translator . You can define the locale to use to translate the object by setting the TranslatableNormalizer::NORMALIZATION_LOCALE_KEY context option. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\BackedEnumNormalizer This normalizer converts between BackedEnum enums and strings or integers. By default, an exception is thrown when data is not a valid backed enumeration. If you want null instead, you can set the BackedEnumNormalizer::ALLOW_INVALID_VALUES option. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\NumberNormalizer This normalizer converts between BcMath\\\\Number or GMP objects and strings or integers. The NumberNormalizer was introduced in Symfony 7.3. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DataUriNormalizer This normalizer converts between SplFileInfo objects and a `data URI`_ string (data:...) such that files can be embedded into serialized data. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\JsonSerializableNormalizer This normalizer works with classes that implement JsonSerializable. It will call the JsonSerializable::jsonSerialize method and then further normalize the result. This means that nested JsonSerializable classes will also be normalized. This normalizer is particularly helpful when you want to gradually migrate from an existing codebase using simple json_encode to the Symfony Serializer by allowing you to mix which normalizers are used for which classes. Unlike with json_encode circular references can be handled. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ArrayDenormalizer This denormalizer converts an array of arrays to an array of objects (with the given type). See Handling Arrays . Use Symfony\\\\Component\\\\PropertyInfo\\\\PropertyInfoExtractor to provide hints with annotations like @var Person[]: use Symfony\\Component\\PropertyInfo\\Extractor\\PhpDocExtractor; use Symfony\\Component\\PropertyInfo\\Extractor\\ReflectionExtractor; use Symfony\\Component\\PropertyInfo\\PropertyInfoExtractor; use Symfony\\Component\\Serializer\\Encoder\\JsonEncoder; use Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory; use Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader; use Symfony\\Component\\Serializer\\Normalizer\\ArrayDenormalizer; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; use Symfony\\Component\\Serializer\\Serializer; $propertyInfo = new PropertyInfoExtractor([], [new PhpDocExtractor(), new ReflectionExtractor()]); $normalizers = [new ObjectNormalizer(new ClassMetadataFactory(new AttributeLoader()), null, null, $propertyInfo), new ArrayDenormalizer()]; $this->serializer = new Serializer($normalizers, [new JsonEncoder()]); Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ObjectNormalizer This is the most powerful default normalizer and used for any object that could not be normalized by the other normalizers. It leverages the PropertyAccess Component to read and write in the object. This allows it to access properties directly or using getters, setters, hassers, issers, canners, adders and removers. Names are generated by removing the get, set, has, is, add or remove prefix from the method name and transforming the first letter to lowercase (e.g. getFirstName() -> firstName).", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_10", "source": "serializer.rst", "text": "PhpDocExtractor(), new ReflectionExtractor()]); $normalizers = [new ObjectNormalizer(new ClassMetadataFactory(new AttributeLoader()), null, null, $propertyInfo), new ArrayDenormalizer()]; $this->serializer = new Serializer($normalizers, [new JsonEncoder()]); Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ObjectNormalizer This is the most powerful default normalizer and used for any object that could not be normalized by the other normalizers. It leverages the PropertyAccess Component to read and write in the object. This allows it to access properties directly or using getters, setters, hassers, issers, canners, adders and removers. Names are generated by removing the get, set, has, is, add or remove prefix from the method name and transforming the first letter to lowercase (e.g. getFirstName() -> firstName). During denormalization, it supports using the constructor as well as the discovered methods. Always make sure the DateTimeNormalizer is registered when serializing the DateTime or DateTimeImmutable classes to avoid excessive memory usage and exposing internal details. Built-in Normalizers Besides the normalizers registered by default (see previous section), the serializer component also provides some extra normalizers. You can register these by defining a service and tag it with serializer.normalizer . For instance, to use the CustomNormalizer you have to define a service like: # config/services.yaml services: # ... # if you're using autoconfigure, the tag will be automatically applied Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer: tags: # register the normalizer with a high priority (called earlier) - { name: 'serializer.normalizer', priority: 500 } <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... --> <!-- if you're using autoconfigure, the tag will be automatically applied --> <service id=\"Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer\"> <!-- register the normalizer with a high priority (called earlier) --> <tag name=\"serializer.normalizer\" priority=\"500\" /> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer; return function(ContainerConfigurator $container) { // ... // if you're using autoconfigure, the tag will be automatically applied $services->set(CustomNormalizer::class) // register the normalizer with a high priority (called earlier) ->tag('serializer.normalizer', [ 'priority' => 500, ]) ; }; Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\CustomNormalizer This normalizer calls a method on the PHP object when normalizing. The PHP object must implement Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\NormalizableInterface and/or Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DenormalizableInterface. Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\GetSetMethodNormalizer This normalizer is an alternative to the default ObjectNormalizer. It reads the content of the class by calling the \"getters\" (public methods starting with get, has, is or can). It will denormalize data by calling the constructor and the \"setters\" (public methods starting with set). Objects are normalized to a map of property names and values (names are generated by removing the get prefix from the method name and transforming the first letter to lowercase; e.g. getFirstName() -> firstName). Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\PropertyNormalizer This is yet another alternative to the ObjectNormalizer. This normalizer directly reads and writes public properties as well as **private and protected** properties (from both the class and all of its parent classes) by using `PHP reflection`_. It supports calling the constructor during the denormalization process. Objects are normalized to a map of property names to property values. You can also limit the normalizer to only use properties with a specific visibility (e.g. only public properties) using the PropertyNormalizer::NORMALIZE_VISIBILITY context option. You can set it to any combination of the PropertyNormalizer::NORMALIZE_PUBLIC, PropertyNormalizer::NORMALIZE_PROTECTED", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_11", "source": "serializer.rst", "text": "letter to lowercase; e.g. getFirstName() -> firstName). Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\PropertyNormalizer This is yet another alternative to the ObjectNormalizer. This normalizer directly reads and writes public properties as well as **private and protected** properties (from both the class and all of its parent classes) by using `PHP reflection`_. It supports calling the constructor during the denormalization process. Objects are normalized to a map of property names to property values. You can also limit the normalizer to only use properties with a specific visibility (e.g. only public properties) using the PropertyNormalizer::NORMALIZE_VISIBILITY context option. You can set it to any combination of the PropertyNormalizer::NORMALIZE_PUBLIC, PropertyNormalizer::NORMALIZE_PROTECTED and PropertyNormalizer::NORMALIZE_PRIVATE constants:: use Symfony\\Component\\Serializer\\Normalizer\\PropertyNormalizer; // ... $json = $serializer->serialize($person, 'json', [ // only serialize public properties PropertyNormalizer::NORMALIZE_VISIBILITY => PropertyNormalizer::NORMALIZE_PUBLIC, // serialize public and protected properties PropertyNormalizer::NORMALIZE_VISIBILITY => PropertyNormalizer::NORMALIZE_PUBLIC | PropertyNormalizer::NORMALIZE_PROTECTED, ]); Named Serializers Named serializers were introduced in Symfony 7.2. Sometimes, you may need multiple configurations for the serializer, such as different default contexts, name converters, or sets of normalizers and encoders, depending on the use case. For example, when your application communicates with multiple APIs, each of which follows its own set of serialization rules. You can achieve this by configuring multiple serializer instances using the named_serializers option: # config/packages/serializer.yaml framework: serializer: named_serializers: api_client1: name_converter: 'serializer.name_converter.camel_case_to_snake_case' default_context: enable_max_depth: true api_client2: default_context: enable_max_depth: false <!-- config/packages/serializer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:serializer> <framework:named-serializer name=\"api_client1\" name-converter=\"serializer.name_converter.camel_case_to_snake_case\" > <framework:default-context> <framework:enable_max_depth>true</framework:enable_max_depth> </framework:default-context> </framework:named-serializer> <framework:named-serializer name=\"api_client2\"> <framework:default-context> <framework:enable_max_depth>false</framework:enable_max_depth> </framework:default-context> </framework:named-serializer> </framework:serializer> </framework:config> </container> // config/packages/serializer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->serializer() ->namedSerializer('api_client1') ->nameConverter('serializer.name_converter.camel_case_to_snake_case') ->defaultContext([ 'enable_max_depth' => true, ]) ; $framework->serializer() ->namedSerializer('api_client2') ->defaultContext([ 'enable_max_depth' => false, ]) ; }; You can inject these different serializer instances using named aliases :: namespace App\\Controller; // ... use Symfony\\Component\\DependencyInjection\\Attribute\\Target; class PersonController extends AbstractController { public function index( SerializerInterface $serializer, // default serializer SerializerInterface $apiClient1Serializer, // api_client1 serializer #[Target('apiClient2.serializer')] // api_client2 serializer SerializerInterface $customName, ) { // ... } } By default, named serializers use the built-in set of normalizers and encoders, just like the main serializer service. However, you can customize them by registering additional normalizers or encoders for a specific named serializer. To do that, add a serializer attribute to the serializer.normalizer or serializer.encoder tags: # config/services.yaml services: # ... Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer: tags: # add this normalizer only to a specific named serializer - serializer.normalizer: { serializer: 'api_client1' } # add this normalizer to several named serializers - serializer.normalizer: { serializer: [ 'api_client1', 'api_client2' ] } # add this normalizer to all serializers, including the default one - serializer.normalizer: { serializer: '*' } <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... --> <service id=\"Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer\"> <!-- add this normalizer only to a specific named serializer --> <tag name=\"serializer.normalizer\" serializer=\"api_client1\"/> <!-- add this normalizer to several named serializers --> <tag name=\"serializer.normalizer\" serializer=\"api_client1\"/> <tag name=\"serializer.normalizer\" serializer=\"api_client2\"/> <!-- add this normalizer to all serializers, including the default one --> <tag name=\"serializer.normalizer\" serializer=\"*\"/> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer;", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_12", "source": "serializer.rst", "text": "several named serializers - serializer.normalizer: { serializer: [ 'api_client1', 'api_client2' ] } # add this normalizer to all serializers, including the default one - serializer.normalizer: { serializer: '*' } <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... --> <service id=\"Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer\"> <!-- add this normalizer only to a specific named serializer --> <tag name=\"serializer.normalizer\" serializer=\"api_client1\"/> <!-- add this normalizer to several named serializers --> <tag name=\"serializer.normalizer\" serializer=\"api_client1\"/> <tag name=\"serializer.normalizer\" serializer=\"api_client2\"/> <!-- add this normalizer to all serializers, including the default one --> <tag name=\"serializer.normalizer\" serializer=\"*\"/> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer; return function(ContainerConfigurator $container) { // ... $services->set(CustomNormalizer::class) // add this normalizer only to a specific named serializer ->tag('serializer.normalizer', ['serializer' => 'api_client1']) // add this normalizer to several named serializers ->tag('serializer.normalizer', ['serializer' => ['api_client1', 'api_client2']]) // add this normalizer to all serializers, including the default one ->tag('serializer.normalizer', ['serializer' => '*']) ; }; Before Symfony 7.3, named serializer normalizers were added automatically to the default serializer, so you had to set their autoconfigure option to false to disable them. As of Symfony 7.3, they are no longer registered by default. When the serializer attribute is not set, the service is registered only with the default serializer. Each normalizer or encoder used in a named serializer is tagged with a serializer.normalizer.<name> or serializer.encoder.<name> tag. You can inspect their priorities using the following command: $ php bin/console debug:container --tag serializer.<normalizer|encoder>.<name> Additionally, you can exclude the default set of normalizers and encoders from a named serializer by setting the include_built_in_normalizers and include_built_in_encoders options to false: # config/packages/serializer.yaml framework: serializer: named_serializers: api_client1: include_built_in_normalizers: false include_built_in_encoders: true <!-- config/packages/serializer.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:serializer> <framework:named-serializer name=\"api_client1\" include-built-in-normalizers=\"false\" include-built-in-encoders=\"true\" /> </framework:serializer> </framework:config> </container> // config/packages/serializer.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->serializer() ->namedSerializer('api_client1') ->includeBuiltInNormalizers(false) ->includeBuiltInEncoders(true) ; }; Debugging the Serializer Use the debug:serializer command to dump the serializer metadata of a given class: $ php bin/console debug:serializer 'App\\Entity\\Book' App\\Entity\\Book | Property | Options | | name | [ | | | \"groups\" => [ | | | \"book:read\", | | | \"book:write\", | | | ], | | | \"maxDepth\" => 1, | | | \"serializedName\" => \"book_name\", | | | \"serializedPath\" => null, | | | \"ignore\" => false, | | | \"normalizationContexts\" => [], | | | \"denormalizationContexts\" => [] | | | ] | | isbn | [ | | | \"groups\" => [ | | | \"book:read\", | | | ], | | | \"maxDepth\" => null, | | | \"serializedName\" => null, | | | \"serializedPath\" => \"[data][isbn]\", | | | \"ignore\" => false, | | | \"normalizationContexts\" => [], | | | \"denormalizationContexts\" => [] | | | ] | Advanced Serialization Skipping null Values By default, the Serializer will preserve properties containing a null value. You can change this behavior by setting the AbstractObjectNormalizer::SKIP_NULL_VALUES context option to true:: class Person { public string $name = 'Jane Doe'; public", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_13", "source": "serializer.rst", "text": "] | | isbn | [ | | | \"groups\" => [ | | | \"book:read\", | | | ], | | | \"maxDepth\" => null, | | | \"serializedName\" => null, | | | \"serializedPath\" => \"[data][isbn]\", | | | \"ignore\" => false, | | | \"normalizationContexts\" => [], | | | \"denormalizationContexts\" => [] | | | ] | Advanced Serialization Skipping null Values By default, the Serializer will preserve properties containing a null value. You can change this behavior by setting the AbstractObjectNormalizer::SKIP_NULL_VALUES context option to true:: class Person { public string $name = 'Jane Doe'; public ?string $gender = null; } $jsonContent = $serializer->serialize(new Person(), 'json', [ AbstractObjectNormalizer::SKIP_NULL_VALUES => true, ]); // $jsonContent contains {\"name\":\"Jane Doe\"} Preserving Empty Objects By default, the Serializer transforms an empty array to []. You can change this behavior by setting the AbstractObjectNormalizer::PRESERVE_EMPTY_OBJECTS context option to true. When the value is an instance of \\ArrayObject(), the serialized data will be {}. Handling Uninitialized Properties In PHP, typed properties have an uninitialized state which is different from the default null of untyped properties. When you try to access a typed property before giving it an explicit value, you get an error. To avoid the serializer throwing an error when serializing or normalizing an object with uninitialized properties, by default the ObjectNormalizer catches these errors and ignores such properties. You can disable this behavior by setting the AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES context option to false:: class Person { public string $name = 'Jane Doe'; public string $phoneNumber; // uninitialized } $jsonContent = $normalizer->serialize(new Dummy(), 'json', [ AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES => false, ]); // throws Symfony\\Component\\PropertyAccess\\Exception\\UninitializedPropertyException // as the ObjectNormalizer cannot read uninitialized properties Using Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\PropertyNormalizer or Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\GetSetMethodNormalizer with AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES context option set to false will throw an \\Error instance if the given object has uninitialized properties as the normalizers cannot read them (directly or via getter/isser methods). Handling Circular References Circular references are common when dealing with associated objects:: class Organization { public function __construct( private string $name, private array $members = [] ) { } public function getName(): string { return $this->name; } public function addMember(Member $member): void { $this->members[] = $member; } public function getMembers(): array { return $this->members; } } class Member { private Organization $organization; public function __construct( private string $name ) { } public function getName(): string { return $this->name; } public function setOrganization(Organization $organization): void { $this->organization = $organization; } public function getOrganization(): Organization { return $this->organization; } } To avoid infinite loops, the normalizers throw a Symfony\\\\Component\\\\Serializer\\\\Exception\\\\CircularReferenceException when such a case is encountered:: $organization = new Organization('Les-Tilleuls.coop'); $member = new Member('Kévin'); $organization->addMember($member); $member->setOrganization($organization); $jsonContent = $serializer->serialize($organization, 'json'); // throws a CircularReferenceException The key circular_reference_limit in the context sets the number of times it will serialize the same object before considering it a circular reference. The default value is 1. Instead of throwing an exception, circular references can also be handled by custom callables. This is especially useful when serializing entities having unique identifiers:: use Symfony\\Component\\Serializer\\Exception\\CircularReferenceException; $context = [ AbstractNormalizer::CIRCULAR_REFERENCE_HANDLER => function", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_14", "source": "serializer.rst", "text": "getOrganization(): Organization { return $this->organization; } } To avoid infinite loops, the normalizers throw a Symfony\\\\Component\\\\Serializer\\\\Exception\\\\CircularReferenceException when such a case is encountered:: $organization = new Organization('Les-Tilleuls.coop'); $member = new Member('Kévin'); $organization->addMember($member); $member->setOrganization($organization); $jsonContent = $serializer->serialize($organization, 'json'); // throws a CircularReferenceException The key circular_reference_limit in the context sets the number of times it will serialize the same object before considering it a circular reference. The default value is 1. Instead of throwing an exception, circular references can also be handled by custom callables. This is especially useful when serializing entities having unique identifiers:: use Symfony\\Component\\Serializer\\Exception\\CircularReferenceException; $context = [ AbstractNormalizer::CIRCULAR_REFERENCE_HANDLER => function (object $object, ?string $format, array $context): string { if (!$object instanceof Organization) { throw new CircularReferenceException('A circular reference has been detected when serializing the object of class \"'.get_debug_type($object).'\".'); } // serialize the nested Organization with only the name (and not the members) return $object->getName(); }, ]; $jsonContent = $serializer->serialize($organization, 'json', $context); // $jsonContent contains {\"name\":\"Les-Tilleuls.coop\",\"members\":[{\"name\":\"K\\u00e9vin\", organization: \"Les-Tilleuls.coop\"}]} Handling Serialization Depth The serializer can also detect nested objects of the same class and limit the serialization depth. This is useful for tree structures, where the same object is nested multiple times. For instance, assume a data structure of a family tree:: // ... class Person { // ... public function __construct( private string $name, private ?self $mother ) { } public function getName(): string { return $this->name; } public function getMother(): ?self { return $this->mother; } // ... } // ... $greatGrandmother = new Person('Elizabeth', null); $grandmother = new Person('Jane', $greatGrandmother); $mother = new Person('Sophie', $grandmother); $child = new Person('Joe', $mother); You can specify the maximum depth for a given property. For instance, you can set the max depth to 1 to always only serialize someone's mother (and not their grandmother, etc.): // src/Model/Person.php namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\MaxDepth; class Person { #[MaxDepth(1)] private ?self $mother; // ... } # config/serializer/person.yaml App\\Model\\Person: attributes: mother: max_depth: 1 <!-- config/serializer/person.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\Person\"> <attribute name=\"mother\" max-depth=\"1\"/> </class> </serializer> To limit the serialization depth, you must set the AbstractObjectNormalizer::ENABLE_MAX_DEPTH key to true in the context (or the default context specified in framework.yaml):: // ... $greatGrandmother = new Person('Elizabeth', null); $grandmother = new Person('Jane', $greatGrandmother); $mother = new Person('Sophie', $grandmother); $child = new Person('Joe', $mother); $jsonContent = $serializer->serialize($child, null, [ AbstractObjectNormalizer::ENABLE_MAX_DEPTH => true ]); // $jsonContent contains {\"name\":\"Joe\",\"mother\":{\"name\":\"Sophie\"}} You can also configure a custom callable that is used when the maximum depth is reached. This can be used to for instance return the unique identifier of the next nested object, instead of omitting the property:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer; // ... $greatGrandmother = new Person('Elizabeth', null); $grandmother = new Person('Jane', $greatGrandmother); $mother = new Person('Sophie', $grandmother); $child = new Person('Joe', $mother); // all callback parameters are optional (you can omit the ones you don't use) $maxDepthHandler = function (object $innerObject, object $outerObject, string $attributeName, ?string $format = null, array $context = []): ?string { // return only the name of the next person in the tree return $innerObject", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_15", "source": "serializer.rst", "text": "is used when the maximum depth is reached. This can be used to for instance return the unique identifier of the next nested object, instead of omitting the property:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer; // ... $greatGrandmother = new Person('Elizabeth', null); $grandmother = new Person('Jane', $greatGrandmother); $mother = new Person('Sophie', $grandmother); $child = new Person('Joe', $mother); // all callback parameters are optional (you can omit the ones you don't use) $maxDepthHandler = function (object $innerObject, object $outerObject, string $attributeName, ?string $format = null, array $context = []): ?string { // return only the name of the next person in the tree return $innerObject instanceof Person ? $innerObject->getName() : null; }; $jsonContent = $serializer->serialize($child, null, [ AbstractObjectNormalizer::ENABLE_MAX_DEPTH => true, AbstractObjectNormalizer::MAX_DEPTH_HANDLER => $maxDepthHandler, ]); // $jsonContent contains {\"name\":\"Joe\",\"mother\":{\"name\":\"Sophie\",\"mother\":\"Jane\"}} Using Callbacks to Serialize Properties with Object Instances When serializing, you can set a callback to format a specific object property. This can be used instead of defining the context for a group :: $person = new Person('cordoval', 34); $person->setCreatedAt(new \\DateTime('now')); $context = [ AbstractNormalizer::CALLBACKS => [ // all callback parameters are optional (you can omit the ones you don't use) 'createdAt' => function (object $attributeValue, object $object, string $attributeName, ?string $format = null, array $context = []) { return $attributeValue instanceof \\DateTime ? $attributeValue->format(\\DateTime::ATOM) : ''; }, ], ]; $jsonContent = $serializer->serialize($person, 'json', $context); // $jsonContent contains {\"name\":\"cordoval\",\"age\":34,\"createdAt\":\"2014-03-22T09:43:12-0500\"} Advanced Deserialization Require all Properties By default, the Serializer will add null to nullable properties when the parameters for those are not provided. You can change this behavior by setting the AbstractNormalizer::REQUIRE_ALL_PROPERTIES context option to true:: class Person { public function __construct( public string $firstName, public ?string $lastName, ) { } } // ... $data = ['firstName' => 'John']; $person = $serializer->deserialize($data, Person::class, 'json', [ AbstractNormalizer::REQUIRE_ALL_PROPERTIES => true, ]); // throws Symfony\\Component\\Serializer\\Exception\\MissingConstructorArgumentException Collecting Type Errors While Denormalizing When denormalizing a payload to an object with typed properties, you'll get an exception if the payload contains properties that don't have the same type as the object. Use the COLLECT_DENORMALIZATION_ERRORS option to collect all exceptions at once, and to get the object partially denormalized:: try { $person = $serializer->deserialize($jsonString, Person::class, 'json', [ DenormalizerInterface::COLLECT_DENORMALIZATION_ERRORS => true, ]); } catch (PartialDenormalizationException $e) { $violations = new ConstraintViolationList(); /** @var NotNormalizableValueException $exception */ foreach ($e->getErrors() as $exception) { $message = sprintf('The type must be one of \"%s\" (\"%s\" given).', implode(', ', $exception->getExpectedTypes()), $exception->getCurrentType()); $parameters = []; if ($exception->canUseMessageForUser()) { $parameters['hint'] = $exception->getMessage(); } $violations->add(new ConstraintViolation($message, '', $parameters, null, $exception->getPath(), null)); } // ... return violation list to the user } Deserializing in an Existing Object The serializer can also be used to update an existing object. You can do this by configuring the object_to_populate serializer context option:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer; // ... $person = new Person('Jane Doe', 59); $serializer->deserialize($jsonData, Person::class, 'json', [ AbstractNormalizer::OBJECT_TO_POPULATE => $person, ]); // instead of returning a new object, $person is updated instead The AbstractNormalizer::OBJECT_TO_POPULATE option is only used for the top level object. If that object is the root of a tree structure, all child elements that exist in", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_16", "source": "serializer.rst", "text": "$violations->add(new ConstraintViolation($message, '', $parameters, null, $exception->getPath(), null)); } // ... return violation list to the user } Deserializing in an Existing Object The serializer can also be used to update an existing object. You can do this by configuring the object_to_populate serializer context option:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer; // ... $person = new Person('Jane Doe', 59); $serializer->deserialize($jsonData, Person::class, 'json', [ AbstractNormalizer::OBJECT_TO_POPULATE => $person, ]); // instead of returning a new object, $person is updated instead The AbstractNormalizer::OBJECT_TO_POPULATE option is only used for the top level object. If that object is the root of a tree structure, all child elements that exist in the normalized data will be re-created with new instances. When the AbstractObjectNormalizer::DEEP_OBJECT_TO_POPULATE context option is set to true, existing children of the root OBJECT_TO_POPULATE are updated from the normalized data, instead of the denormalizer re-creating them. This only works for single child objects, not for arrays of objects. Those will still be replaced when present in the normalized data. Deserializing Interfaces and Abstract Classes When working with associated objects, a property sometimes reference an interface or abstract class. When deserializing these properties, the Serializer has to know which concrete class to initialize. This is done using a *discriminator class mapping*. Imagine there is an InvoiceItemInterface that is implemented by the Product and Shipping objects. When serializing an object, the serializer will add an extra \"discriminator attribute\". This contains either product or shipping. The discriminator class map maps these type names to the real PHP class name when deserializing: namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\DiscriminatorMap; #[DiscriminatorMap( typeProperty: 'type', mapping: [ 'product' => Product::class, 'shipping' => Shipping::class, ] )] interface InvoiceItemInterface { // ... } App\\Model\\InvoiceItemInterface: discriminator_map: type_property: type mapping: product: 'App\\Model\\Product' shipping: 'App\\Model\\Shipping' <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\InvoiceItemInterface\"> <discriminator-map type-property=\"type\"> <mapping type=\"product\" class=\"App\\Model\\Product\"/> <mapping type=\"shipping\" class=\"App\\Model\\Shipping\"/> </discriminator-map> </class> </serializer> With the discriminator map configured, the serializer can now pick the correct class for properties typed as InvoiceItemInterface:: class InvoiceLine { public function __construct( private InvoiceItemInterface $invoiceItem ) { $this->invoiceItem = $invoiceItem; } public function getInvoiceItem(): InvoiceItemInterface { return $this->invoiceItem; } // ... } // ... $invoiceLine = new InvoiceLine(new Product()); $jsonString = $serializer->serialize($invoiceLine, 'json'); // $jsonString contains {\"type\":\"product\",...} $invoiceLine = $serializer->deserialize($jsonString, InvoiceLine::class, 'json'); // $invoiceLine contains new InvoiceLine(new Product(...)) // ... use Symfony\\Component\\Serializer\\Mapping\\ClassDiscriminatorFromClassMetadata; use Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory; use Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader; use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer; use Symfony\\Component\\Serializer\\Serializer; class InvoiceLine { public function __construct( private InvoiceItemInterface $invoiceItem ) { $this->invoiceItem = $invoiceItem; } public function getInvoiceItem(): InvoiceItemInterface { return $this->invoiceItem; } // ... } // ... // Configure a loader to retrieve mapping information like DiscriminatorMap. // E.g. when using PHP attributes: $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader()); $discriminator = new ClassDiscriminatorFromClassMetadata($classMetadataFactory); $normalizers = [ new ObjectNormalizer($classMetadataFactory, null, null, null, $discriminator), ]; $serializer = new Serializer($normalizers, $encoders); $invoiceLine = new InvoiceLine(new Product()); $jsonString = $serializer->serialize($invoiceLine, 'json'); // $jsonString contains {\"type\":\"product\",...} $invoiceLine = $serializer->deserialize($jsonString, InvoiceLine::class, 'json'); // $invoiceLine contains new InvoiceLine(new Product(...)) You can add a default type to avoid the need to add the type property when deserializing: namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\DiscriminatorMap; #[DiscriminatorMap( typeProperty:", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_17", "source": "serializer.rst", "text": "public function getInvoiceItem(): InvoiceItemInterface { return $this->invoiceItem; } // ... } // ... // Configure a loader to retrieve mapping information like DiscriminatorMap. // E.g. when using PHP attributes: $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader()); $discriminator = new ClassDiscriminatorFromClassMetadata($classMetadataFactory); $normalizers = [ new ObjectNormalizer($classMetadataFactory, null, null, null, $discriminator), ]; $serializer = new Serializer($normalizers, $encoders); $invoiceLine = new InvoiceLine(new Product()); $jsonString = $serializer->serialize($invoiceLine, 'json'); // $jsonString contains {\"type\":\"product\",...} $invoiceLine = $serializer->deserialize($jsonString, InvoiceLine::class, 'json'); // $invoiceLine contains new InvoiceLine(new Product(...)) You can add a default type to avoid the need to add the type property when deserializing: namespace App\\Model; use Symfony\\Component\\Serializer\\Attribute\\DiscriminatorMap; #[DiscriminatorMap( typeProperty: 'type', mapping: [ 'product' => Product::class, 'shipping' => Shipping::class, ], defaultType: 'product', )] interface InvoiceItemInterface { // ... } App\\Model\\InvoiceItemInterface: discriminator_map: type_property: type mapping: product: 'App\\Model\\Product' shipping: 'App\\Model\\Shipping' default_type: product <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\" > <class name=\"App\\Model\\InvoiceItemInterface\"> <discriminator-map type-property=\"type\" default-type=\"product\"> <mapping type=\"product\" class=\"App\\Model\\Product\"/> <mapping type=\"shipping\" class=\"App\\Model\\Shipping\"/> </discriminator-map> </class> </serializer> Now it deserializes like this: // $jsonString does NOT contain \"type\" in \"invoiceItem\" $invoiceLine = $serializer->deserialize('{\"invoiceItem\":{...},...}', InvoiceLine::class, 'json'); // $invoiceLine contains new InvoiceLine(new Product(...)) The defaultType parameter was added in Symfony 7.3. Deserializing Input Partially (Unwrapping) The serializer will always deserialize the complete input string into PHP values. When connecting with third party APIs, you often only need a specific part of the returned response. To avoid deserializing the whole response, you can use the Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\UnwrappingDenormalizer and \"unwrap\" the input data:: $jsonData = '{\"result\":\"success\",\"data\":{\"person\":{\"name\": \"Jane Doe\",\"age\":57}}}'; $data = $serialiser->deserialize($jsonData, Object::class, 'json', [ UnwrappingDenormalizer::UNWRAP_PATH => '[data][person]', ]); // $data is Person(name: 'Jane Doe', age: 57) The unwrap_path is a property path of the PropertyAccess component, applied on the denormalized array. Handling Constructor Arguments If the class constructor defines arguments, as usually happens with `Value Objects`_, the serializer will match the parameter names with the deserialized attributes. If some parameters are missing, a Symfony\\\\Component\\\\Serializer\\\\Exception\\\\MissingConstructorArgumentsException is thrown. In these cases, use the default_constructor_arguments context option to define default values for the missing parameters:: use App\\Model\\Person; use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer; // ... $jsonData = '{\"age\":39,\"name\":\"Jane Doe\"}'; $person = $serializer->deserialize($jsonData, Person::class, 'json', [ AbstractNormalizer::DEFAULT_CONSTRUCTOR_ARGUMENTS => [ Person::class => ['sportsperson' => true], ], ]); // $person is Person(name: 'Jane Doe', age: 39, sportsperson: true); Recursive Denormalization and Type Safety When a PropertyTypeExtractor is available, the normalizer will also check that the data to denormalize matches the type of the property (even for primitive types). For instance, if a string is provided, but the type of the property is int, an Symfony\\\\Component\\\\Serializer\\\\Exception\\\\UnexpectedValueException will be thrown. The type enforcement of the properties can be disabled by setting the serializer context option ObjectNormalizer::DISABLE_TYPE_ENFORCEMENT to true. Handling Boolean Values The AbstractNormalizer::FILTER_BOOL context option was introduced in Symfony 7.1. PHP considers many different values as true or false. For example, the strings true, 1, and yes are considered true, while false, 0, and no are considered false. When deserializing, the Serializer component can take care of this automatically. This can be done by using the AbstractNormalizer::FILTER_BOOL context option:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer; // ... $person = $serializer->denormalize(['sportsperson' => 'yes'], Person::class, context:", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "serializer.rst_fixed_18", "source": "serializer.rst", "text": "of the property is int, an Symfony\\\\Component\\\\Serializer\\\\Exception\\\\UnexpectedValueException will be thrown. The type enforcement of the properties can be disabled by setting the serializer context option ObjectNormalizer::DISABLE_TYPE_ENFORCEMENT to true. Handling Boolean Values The AbstractNormalizer::FILTER_BOOL context option was introduced in Symfony 7.1. PHP considers many different values as true or false. For example, the strings true, 1, and yes are considered true, while false, 0, and no are considered false. When deserializing, the Serializer component can take care of this automatically. This can be done by using the AbstractNormalizer::FILTER_BOOL context option:: use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer; // ... $person = $serializer->denormalize(['sportsperson' => 'yes'], Person::class, context: [ AbstractNormalizer::FILTER_BOOL => true ]); // $person contains a Person instance with sportsperson set to true This context makes the deserialization process behave like the filter_var function with the FILTER_VALIDATE_BOOL flag. Configuring the Metadata Cache The metadata for the serializer is automatically cached to enhance application performance. By default, the serializer uses the cache.system cache pool which is configured using the cache.system option. Going Further with the Serializer :glob: :maxdepth: 1 serializer/*", "title": "How to Use the Serializer", "category": "serializer"}
{"chunk_id": "service_container.rst_fixed_0", "source": "service_container.rst", "text": "Service Container :class: screencast Do you prefer video tutorials? Check out the `Symfony Fundamentals screencast series`_. Your application is *full* of useful objects: a \"Mailer\" object might help you send emails while another object might help you save things to the database. Almost *everything* that your app \"does\" is actually done by one of these objects. And each time you install a new bundle, you get access to even more! In Symfony, these useful objects are called **services** and each service lives inside a very special object called the **service container**. The container allows you to centralize the way objects are constructed. It makes your life easier, promotes a strong architecture and is super fast! Fetching and using Services The moment you start a Symfony app, your container *already* contains many services. These are like *tools*: waiting for you to take advantage of them. In your controller, you can \"ask\" for a service from the container by type-hinting an argument with the service's class or interface name. Want to log something? No problem:: // src/Controller/ProductController.php namespace App\\Controller; use Psr\\Log\\LoggerInterface; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class ProductController extends AbstractController { #[Route('/products')] public function list(LoggerInterface $logger): Response { $logger->info('Look, I just used a service!'); // ... } } What other services are available? Find out by running: $ php bin/console debug:autowiring # this is just a *small* sample of the output... Autowirable Types The following classes & interfaces can be used as type-hints when autowiring: Describes a logger instance. Psr\\Log\\LoggerInterface - alias:logger Request stack that controls the lifecycle of requests. Symfony\\Component\\HttpFoundation\\RequestStack - alias:request_stack RouterInterface is the interface that all Router classes must implement. Symfony\\Component\\Routing\\RouterInterface - alias:router.default [...] When you use these type-hints in your controller methods or inside your own services , Symfony will automatically pass you the service object matching that type. Throughout the docs, you'll see how to use the many different services that live in the container. There are actually *many* more services in the container, and each service has a unique id in the container, like request_stack or router.default. For a full list, you can run php bin/console debug:container. But most of the time, you won't need to worry about this. See how to choose a specific service . See /service_container/debug. Creating/Configuring Services in the Container You can also organize your *own* code into services. For example, suppose you need to show your users a random, happy message. If you put this code in your controller, it can't be re-used. Instead, you decide to create a new class:: // src/Service/MessageGenerator.php namespace App\\Service; class MessageGenerator { public function getHappyMessage(): string { $messages = [ 'You did it! You updated the system! Amazing!', 'That was one of the coolest updates I\\'ve seen all day!', 'Great work! Keep going!', ]; $index = array_rand($messages); return $messages[$index]; } } Congratulations! You've created your first service class! You can use it immediately inside your controller:: // src/Controller/ProductController.php use App\\Service\\MessageGenerator; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class ProductController extends AbstractController { #[Route('/products/new')] public function", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_1", "source": "service_container.rst", "text": "message. If you put this code in your controller, it can't be re-used. Instead, you decide to create a new class:: // src/Service/MessageGenerator.php namespace App\\Service; class MessageGenerator { public function getHappyMessage(): string { $messages = [ 'You did it! You updated the system! Amazing!', 'That was one of the coolest updates I\\'ve seen all day!', 'Great work! Keep going!', ]; $index = array_rand($messages); return $messages[$index]; } } Congratulations! You've created your first service class! You can use it immediately inside your controller:: // src/Controller/ProductController.php use App\\Service\\MessageGenerator; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Attribute\\Route; class ProductController extends AbstractController { #[Route('/products/new')] public function new(MessageGenerator $messageGenerator): Response { // thanks to the type-hint, the container will instantiate a // new MessageGenerator and pass it to you! // ... $message = $messageGenerator->getHappyMessage(); $this->addFlash('success', $message); // ... } } When you ask for the MessageGenerator service, the container constructs a new MessageGenerator object and returns it (see sidebar below). But if you never ask for the service, it's *never* constructed: saving memory and speed. As a bonus, the MessageGenerator service is only created *once*: the same instance is returned each time you ask for it. The documentation assumes you're using the following service configuration, which is the default config for a new project: # config/services.yaml services: # default configuration for services in *this* file _defaults: autowire: true # Automatically injects dependencies in your services. autoconfigure: true # Automatically registers your services as commands, event subscribers, etc. # makes classes in src/ available to be used as services # this creates a service per class whose id is the fully-qualified class name App\\: resource: '../src/' # order is important in this file because service definitions # always *replace* previous ones; add your own service configuration below # ... <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- Default configuration for services in *this* file --> <defaults autowire=\"true\" autoconfigure=\"true\"/> <!-- makes classes in src/ available to be used as services --> <!-- this creates a service per class whose id is the fully-qualified class name --> <prototype namespace=\"App\\\" resource=\"../src/\"/> <!-- order is important in this file because service definitions always *replace* previous ones; add your own service configuration below --> <!-- ... --> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void { // default configuration for services in *this* file $services = $container->services() ->defaults() ->autowire() // Automatically injects dependencies in your services. ->autoconfigure() // Automatically registers your services as commands, event subscribers, etc. ; // makes classes in src/ available to be used as services // this creates a service per class whose id is the fully-qualified class name $services->load('App\\\\', '../src/'); // order is important in this file because service definitions // always *replace* previous ones; add your own service configuration below }; The value of the resource option can be any valid `glob pattern`_. Thanks to this configuration, you can automatically use any classes from the src/ directory as a service, without needing to manually configure it. Later, you'll learn", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_2", "source": "service_container.rst", "text": "services. ->autoconfigure() // Automatically registers your services as commands, event subscribers, etc. ; // makes classes in src/ available to be used as services // this creates a service per class whose id is the fully-qualified class name $services->load('App\\\\', '../src/'); // order is important in this file because service definitions // always *replace* previous ones; add your own service configuration below }; The value of the resource option can be any valid `glob pattern`_. Thanks to this configuration, you can automatically use any classes from the src/ directory as a service, without needing to manually configure it. Later, you'll learn how to import many services at once with resource. If some files or directories in your project should not become services, you can exclude them using the exclude option: # config/services.yaml services: # ... App\\: resource: '../src/' exclude: - '../src/SomeDirectory/' - '../src/AnotherDirectory/' - '../src/SomeFile.php' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <prototype namespace=\"App\\\" resource=\"../src/\" exclude=\"../src/{SomeDirectory,AnotherDirectory,Kernel.php}\"/> <!-- ... --> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void { // ... $services->load('App\\\\', '../src/') ->exclude('../src/{SomeDirectory,AnotherDirectory,Kernel.php}'); }; If you'd prefer to manually wire your service, you can use explicit configuration . Limiting Services to a specific Symfony Environment You can use the #[When] attribute to only register the class as a service in some environments:: use Symfony\\Component\\DependencyInjection\\Attribute\\When; // SomeClass is only registered in the \"dev\" environment #[When(env: 'dev')] class SomeClass { // ... } // you can also apply more than one When attribute to the same class #[When(env: 'dev')] #[When(env: 'test')] class AnotherClass { // ... } If you want to exclude a service from being registered in a specific environment, you can use the #[WhenNot] attribute:: use Symfony\\Component\\DependencyInjection\\Attribute\\WhenNot; // SomeClass is registered in all environments except \"dev\" #[WhenNot(env: 'dev')] class SomeClass { // ... } // you can apply more than one WhenNot attribute to the same class #[WhenNot(env: 'dev')] #[WhenNot(env: 'test')] class AnotherClass { // ... } The #[WhenNot] attribute was introduced in Symfony 7.2. Injecting Services/Config into a Service What if you need to access the logger service from within MessageGenerator? No problem! Create a __construct() method with a $logger argument that has the LoggerInterface type-hint. Set this on a new $logger property and use it later:: // src/Service/MessageGenerator.php namespace App\\Service; use Psr\\Log\\LoggerInterface; class MessageGenerator { public function __construct( private LoggerInterface $logger, ) { } public function getHappyMessage(): string { $this->logger->info('About to find a happy message!'); // ... } } That's it! The container will *automatically* know to pass the logger service when instantiating the MessageGenerator. How does it know to do this? Autowiring . The key is the LoggerInterface type-hint in your __construct() method and the autowire: true config in services.yaml. When you type-hint an argument, the container will automatically find the matching service. If it can't, you'll see a clear exception with a helpful suggestion. By the way, this method of adding dependencies to your __construct() method is called *dependency injection*. How should you know to use LoggerInterface for the", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_3", "source": "service_container.rst", "text": "find a happy message!'); // ... } } That's it! The container will *automatically* know to pass the logger service when instantiating the MessageGenerator. How does it know to do this? Autowiring . The key is the LoggerInterface type-hint in your __construct() method and the autowire: true config in services.yaml. When you type-hint an argument, the container will automatically find the matching service. If it can't, you'll see a clear exception with a helpful suggestion. By the way, this method of adding dependencies to your __construct() method is called *dependency injection*. How should you know to use LoggerInterface for the type-hint? You can either read the docs for whatever feature you're using, or get a list of autowireable type-hints by running: $ php bin/console debug:autowiring # this is just a *small* sample of the output... Describes a logger instance. Psr\\Log\\LoggerInterface - alias:monolog.logger Request stack that controls the lifecycle of requests. Symfony\\Component\\HttpFoundation\\RequestStack - alias:request_stack RouterInterface is the interface that all Router classes must implement. Symfony\\Component\\Routing\\RouterInterface - alias:router.default [...] In addition to injecting services, you can also pass scalar values and collections as arguments of other services: # config/services.yaml services: App\\Service\\SomeService: arguments: # string, numeric and boolean arguments can be passed \"as is\" - 'Foo' - true - 7 - 3.14 # constants can be built-in, user-defined, or Enums - !php/const E_ALL - !php/const PDO::FETCH_NUM - !php/const Symfony\\Component\\HttpKernel\\Kernel::VERSION - !php/const App\\Config\\SomeEnum::SomeCase # when not using autowiring, you can pass service arguments explicitly - '@some-service-id' # the leading '@' tells this is a service ID, not a string - '@?some-service-id' # using '?' means to pass null if service doesn't exist # binary contents are passed encoded as base64 strings - !!binary VGhpcyBpcyBhIEJlbGwgY2hhciAH # collections (arrays) can include any type of argument - first: !php/const true second: 'Foo' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <services> <service id=\"App\\Service\\SomeService\"> <!-- arguments without a type can be strings or numbers --> <argument>Foo</argument> <argument>7</argument> <argument>3.14</argument> <!-- explicitly declare a string argument --> <argument type=\"string\">Foo</argument> <!-- booleans are passed as constants --> <argument type=\"constant\">true</argument> <!-- constants can be built-in, user-defined, or Enums --> <argument type=\"constant\">E_ALL</argument> <argument type=\"constant\">PDO::FETCH_NUM</argument> <argument type=\"constant\">Symfony\\Component\\HttpKernel\\Kernel::VERSION</argument> <argument type=\"constant\">App\\Config\\SomeEnum::SomeCase</argument> <!-- when not using autowiring, you can pass service arguments explicitly --> <argument type=\"service\" id=\"some-service-id\" on-invalid=\"dependency_injection-ignore\"/> <!-- binary contents are passed encoded as base64 strings --> <argument type=\"binary\">VGhpcyBpcyBhIEJlbGwgY2hhciAH</argument> <!-- collections (arrays) can include any type of argument --> <argument type=\"collection\"> <argument key=\"first\" type=\"constant\">true</argument> <argument key=\"second\" type=\"string\">Foo</argument> </argument> </service> <!-- ... --> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\DependencyInjection\\ContainerInterface; use Symfony\\Component\\DependencyInjection\\Reference; return static function (ContainerConfigurator $container) { $services = $container->services(); $services->set(App\\Service\\SomeService::class) // string, numeric and boolean arguments can be passed \"as is\" ->arg(0, 'Foo') ->arg(1, true) ->arg(2, 7) ->arg(3, 3.14) // constants: built-in, user-defined, or Enums ->arg(4, E_ALL) ->arg(5, \\PDO::FETCH_NUM) ->arg(6, Symfony\\Component\\HttpKernel\\Kernel::VERSION) ->arg(7, App\\Config\\SomeEnum::SomeCase) // when not using autowiring, you can pass service arguments explicitly ->arg(8, service('some-service-id')) # fails if service doesn't exist # passes null if service doesn't exist ->arg(9, new Reference('some-service-id', Reference::IGNORE_ON_INVALID_REFERENCE)) // collection with mixed", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_4", "source": "service_container.rst", "text": "<argument type=\"collection\"> <argument key=\"first\" type=\"constant\">true</argument> <argument key=\"second\" type=\"string\">Foo</argument> </argument> </service> <!-- ... --> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Symfony\\Component\\DependencyInjection\\ContainerInterface; use Symfony\\Component\\DependencyInjection\\Reference; return static function (ContainerConfigurator $container) { $services = $container->services(); $services->set(App\\Service\\SomeService::class) // string, numeric and boolean arguments can be passed \"as is\" ->arg(0, 'Foo') ->arg(1, true) ->arg(2, 7) ->arg(3, 3.14) // constants: built-in, user-defined, or Enums ->arg(4, E_ALL) ->arg(5, \\PDO::FETCH_NUM) ->arg(6, Symfony\\Component\\HttpKernel\\Kernel::VERSION) ->arg(7, App\\Config\\SomeEnum::SomeCase) // when not using autowiring, you can pass service arguments explicitly ->arg(8, service('some-service-id')) # fails if service doesn't exist # passes null if service doesn't exist ->arg(9, new Reference('some-service-id', Reference::IGNORE_ON_INVALID_REFERENCE)) // collection with mixed argument types ->arg(10, [ 'first' => true, 'second' => 'Foo', ]); // ... }; Handling Multiple Services Suppose you also want to email a site administrator each time a site update is made. To do that, you create a new class:: // src/Service/SiteUpdateManager.php namespace App\\Service; use App\\Service\\MessageGenerator; use Symfony\\Component\\Mailer\\MailerInterface; use Symfony\\Component\\Mime\\Email; class SiteUpdateManager { public function __construct( private MessageGenerator $messageGenerator, private MailerInterface $mailer, ) { } public function notifyOfSiteUpdate(): bool { $happyMessage = $this->messageGenerator->getHappyMessage(); $email = (new Email()) ->from('admin@example.com') ->to('manager@example.com') ->subject('Site update just happened!') ->text('Someone just updated the site. We told them: '.$happyMessage); $this->mailer->send($email); // ... return true; } } This needs the MessageGenerator *and* the Mailer service. That's no problem, we ask them by type hinting their class and interface names! Now, this new service is ready to be used. In a controller, for example, you can type-hint the new SiteUpdateManager class and use it:: // src/Controller/SiteController.php namespace App\\Controller; use App\\Service\\SiteUpdateManager; // ... class SiteController extends AbstractController { public function new(SiteUpdateManager $siteUpdateManager): Response { // ... if ($siteUpdateManager->notifyOfSiteUpdate()) { $this->addFlash('success', 'Notification mail was sent successfully.'); } // ... } } Thanks to autowiring and your type-hints in __construct(), the container creates the SiteUpdateManager object and passes it the correct argument. In most cases, this works perfectly. Manually Wiring Arguments But there are a few cases when an argument to a service cannot be autowired. For example, suppose you want to make the admin email configurable: // src/Service/SiteUpdateManager.php // ... class SiteUpdateManager { // ... public function __construct( private MessageGenerator $messageGenerator, private MailerInterface $mailer, + private string $adminEmail ) { } public function notifyOfSiteUpdate(): bool { // ... $email = (new Email()) // ... - ->to('manager@example.com') + ->to($this->adminEmail) // ... ; // ... } } If you make this change and refresh, you'll see an error: Cannot autowire service \"App\\\\Service\\\\SiteUpdateManager\": argument \"$adminEmail\" of method \"__construct()\" must have a type-hint or be given a value explicitly. That makes sense! There is no way that the container knows what value you want to pass here. No problem! In your configuration, you can explicitly set this argument: # config/services.yaml services: # ... same as before # same as before App\\: resource: '../src/' exclude: '../src/{DependencyInjection,Entity,Kernel.php}' # explicitly configure the service App\\Service\\SiteUpdateManager: arguments: $adminEmail: 'manager@example.com' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... same as before --> <!-- Same as before --> <prototype namespace=\"App\\\" resource=\"../src/\" exclude=\"../src/{DependencyInjection,Entity,Kernel.php}\" /> <!--", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_5", "source": "service_container.rst", "text": "argument \"$adminEmail\" of method \"__construct()\" must have a type-hint or be given a value explicitly. That makes sense! There is no way that the container knows what value you want to pass here. No problem! In your configuration, you can explicitly set this argument: # config/services.yaml services: # ... same as before # same as before App\\: resource: '../src/' exclude: '../src/{DependencyInjection,Entity,Kernel.php}' # explicitly configure the service App\\Service\\SiteUpdateManager: arguments: $adminEmail: 'manager@example.com' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... same as before --> <!-- Same as before --> <prototype namespace=\"App\\\" resource=\"../src/\" exclude=\"../src/{DependencyInjection,Entity,Kernel.php}\" /> <!-- Explicitly configure the service --> <service id=\"App\\Service\\SiteUpdateManager\"> <argument key=\"$adminEmail\">manager@example.com</argument> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\SiteUpdateManager; return function(ContainerConfigurator $container): void { // ... // same as before $services->load('App\\\\', '../src/') ->exclude('../src/{DependencyInjection,Entity,Kernel.php}'); $services->set(SiteUpdateManager::class) ->arg('$adminEmail', 'manager@example.com') ; }; Thanks to this, the container will pass manager@example.com to the $adminEmail argument of __construct when creating the SiteUpdateManager service. The other arguments will still be autowired. But, isn't this fragile? Fortunately, no! If you rename the $adminEmail argument to something else - e.g. $mainEmail - you will get a clear exception when you reload the next page (even if that page doesn't use this service). Service Parameters In addition to holding service objects, the container also holds configuration, called **parameters**. The main article about Symfony configuration explains the configuration parameters in detail and shows all their types (string, boolean, array, binary and PHP constant parameters). However, there is another type of parameter related to services. In YAML config, any string which starts with @ is considered as the ID of a service, instead of a regular string. In XML config, use the type=\"service\" type for the parameter and in PHP config use the service() function: # config/services.yaml services: App\\Service\\MessageGenerator: arguments: # this is not a string, but a reference to a service called 'logger' - '@logger' # if the value of a string argument starts with '@', you need to escape # it by adding another '@' so Symfony doesn't consider it a service # the following example would be parsed as the string '@securepassword' # - '@@securepassword' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <service id=\"App\\Service\\MessageGenerator\"> <argument type=\"service\" id=\"logger\"/> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator; return function(ContainerConfigurator $container): void { $services = $container->services(); $services->set(MessageGenerator::class) ->args([service('logger')]) ; }; Working with container parameters is straightforward using the container's accessor methods for parameters:: // checks if a parameter is defined (parameter names are case-sensitive) $container->hasParameter('mailer.transport'); // gets value of a parameter $container->getParameter('mailer.transport'); // adds a new parameter $container->setParameter('mailer.transport', 'sendmail'); The used . notation is a Symfony convention to make parameters easier to read. Parameters are flat key-value elements, they can't be organized into a nested array You can only set a parameter before the container is compiled, not at run-time. To learn more about compiling the container see /components/dependency_injection/compilation. Choose a Specific Service The MessageGenerator service created earlier requires a LoggerInterface argument:: // src/Service/MessageGenerator.php namespace App\\Service;", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_6", "source": "service_container.rst", "text": "using the container's accessor methods for parameters:: // checks if a parameter is defined (parameter names are case-sensitive) $container->hasParameter('mailer.transport'); // gets value of a parameter $container->getParameter('mailer.transport'); // adds a new parameter $container->setParameter('mailer.transport', 'sendmail'); The used . notation is a Symfony convention to make parameters easier to read. Parameters are flat key-value elements, they can't be organized into a nested array You can only set a parameter before the container is compiled, not at run-time. To learn more about compiling the container see /components/dependency_injection/compilation. Choose a Specific Service The MessageGenerator service created earlier requires a LoggerInterface argument:: // src/Service/MessageGenerator.php namespace App\\Service; use Psr\\Log\\LoggerInterface; class MessageGenerator { public function __construct( private LoggerInterface $logger, ) { } // ... } However, there are *multiple* services in the container that implement LoggerInterface, such as logger, monolog.logger.request, monolog.logger.php, etc. How does the container know which one to use? In these situations, the container is usually configured to automatically choose one of the services - logger in this case (read more about why in service-autowiring-alias). But, you can control this and pass in a different logger: # config/services.yaml services: # ... same code as before # explicitly configure the service App\\Service\\MessageGenerator: arguments: # the '@' symbol is important: that's what tells the container # you want to pass the *service* whose id is 'monolog.logger.request', # and not just the *string* 'monolog.logger.request' $logger: '@monolog.logger.request' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... same code as before --> <!-- Explicitly configure the service --> <service id=\"App\\Service\\MessageGenerator\"> <argument key=\"$logger\" type=\"service\" id=\"monolog.logger.request\"/> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator; return function(ContainerConfigurator $container): void { // ... same code as before // explicitly configure the service $services->set(MessageGenerator::class) ->arg('$logger', service('monolog.logger.request')) ; }; This tells the container that the $logger argument to __construct should use service whose id is monolog.logger.request. For a list of possible logger services that can be used with autowiring, run: $ php bin/console debug:autowiring logger For a full list of *all* possible services in the container, run: $ php bin/console debug:container Remove Services A service can be removed from the service container if needed. This is useful for example to make a service unavailable in some configuration environment (e.g. in the test environment): // config/services_test.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\RemovedService; return function(ContainerConfigurator $containerConfigurator) { $services = $containerConfigurator->services(); $services->remove(RemovedService::class); }; Now, the container will not contain the App\\RemovedService in the test environment. Injecting a Closure as an Argument It is possible to inject a callable as an argument of a service. Let's add an argument to our MessageGenerator constructor:: // src/Service/MessageGenerator.php namespace App\\Service; use Psr\\Log\\LoggerInterface; class MessageGenerator { private string $messageHash; public function __construct( private LoggerInterface $logger, callable $generateMessageHash, ) { $this->messageHash = $generateMessageHash(); } // ... } Now, we would add a new invokable service to generate the message hash:: // src/Hash/MessageHashGenerator.php namespace App\\Hash; class MessageHashGenerator { public function __invoke(): string { // Compute and return a message hash } } Our configuration looks like this: # config/services.yaml services: # ...", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_7", "source": "service_container.rst", "text": "Injecting a Closure as an Argument It is possible to inject a callable as an argument of a service. Let's add an argument to our MessageGenerator constructor:: // src/Service/MessageGenerator.php namespace App\\Service; use Psr\\Log\\LoggerInterface; class MessageGenerator { private string $messageHash; public function __construct( private LoggerInterface $logger, callable $generateMessageHash, ) { $this->messageHash = $generateMessageHash(); } // ... } Now, we would add a new invokable service to generate the message hash:: // src/Hash/MessageHashGenerator.php namespace App\\Hash; class MessageHashGenerator { public function __invoke(): string { // Compute and return a message hash } } Our configuration looks like this: # config/services.yaml services: # ... same code as before # explicitly configure the service App\\Service\\MessageGenerator: arguments: $logger: '@monolog.logger.request' $generateMessageHash: !closure '@App\\Hash\\MessageHashGenerator' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... same code as before --> <!-- Explicitly configure the service --> <service id=\"App\\Service\\MessageGenerator\"> <argument key=\"$logger\" type=\"service\" id=\"monolog.logger.request\"/> <argument key=\"$generateMessageHash\" type=\"closure\" id=\"App\\Hash\\MessageHashGenerator\"/> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator; return function(ContainerConfigurator $containerConfigurator): void { // ... same code as before // explicitly configure the service $services->set(MessageGenerator::class) ->arg('$logger', service('monolog.logger.request')) ->arg('$generateMessageHash', closure('App\\Hash\\MessageHashGenerator')) ; }; Closures can be injected by using autowiring and its dedicated attributes. Binding Arguments by Name or Type You can also use the bind keyword to bind specific arguments by name or type: # config/services.yaml services: _defaults: bind: # pass this value to any $adminEmail argument for any service # that's defined in this file (including controller arguments) $adminEmail: 'manager@example.com' # pass this service to any $requestLogger argument for any # service that's defined in this file $requestLogger: '@monolog.logger.request' # pass this service for any LoggerInterface type-hint for any # service that's defined in this file Psr\\Log\\LoggerInterface: '@monolog.logger.request' # optionally you can define both the name and type of the argument to match string $adminEmail: 'manager@example.com' Psr\\Log\\LoggerInterface $requestLogger: '@monolog.logger.request' iterable $rules: !tagged_iterator app.foo.rule # ... <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <defaults autowire=\"true\" autoconfigure=\"true\" public=\"false\"> <bind key=\"$adminEmail\">manager@example.com</bind> <bind key=\"$requestLogger\" type=\"service\" id=\"monolog.logger.request\" /> <bind key=\"Psr\\Log\\LoggerInterface\" type=\"service\" id=\"monolog.logger.request\" /> <!-- optionally you can define both the name and type of the argument to match --> <bind key=\"string $adminEmail\">manager@example.com</bind> <bind key=\"Psr\\Log\\LoggerInterface $requestLogger\" type=\"service\" id=\"monolog.logger.request\" /> <bind key=\"iterable $rules\" type=\"tagged_iterator\" tag=\"app.foo.rule\" /> </defaults> <!-- ... --> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use Psr\\Log\\LoggerInterface; return function(ContainerConfigurator $container): void { $services = $container->services() ->defaults() // pass this value to any $adminEmail argument for any service // that's defined in this file (including controller arguments) ->bind('$adminEmail', 'manager@example.com') // pass this service to any $requestLogger argument for any // service that's defined in this file ->bind('$requestLogger', service('monolog.logger.request')) // pass this service for any LoggerInterface type-hint for any // service that's defined in this file ->bind(LoggerInterface::class, service('monolog.logger.request')) // optionally you can define both the name and type of the argument to match ->bind('string $adminEmail', 'manager@example.com') ->bind(LoggerInterface::class.' $requestLogger', service('monolog.logger.request')) ->bind('iterable $rules', tagged_iterator('app.foo.rule')) ; // ... }; By putting the bind key under _defaults, you can specify the value of *any* argument for *any* service defined in this file! You", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_8", "source": "service_container.rst", "text": "// that's defined in this file (including controller arguments) ->bind('$adminEmail', 'manager@example.com') // pass this service to any $requestLogger argument for any // service that's defined in this file ->bind('$requestLogger', service('monolog.logger.request')) // pass this service for any LoggerInterface type-hint for any // service that's defined in this file ->bind(LoggerInterface::class, service('monolog.logger.request')) // optionally you can define both the name and type of the argument to match ->bind('string $adminEmail', 'manager@example.com') ->bind(LoggerInterface::class.' $requestLogger', service('monolog.logger.request')) ->bind('iterable $rules', tagged_iterator('app.foo.rule')) ; // ... }; By putting the bind key under _defaults, you can specify the value of *any* argument for *any* service defined in this file! You can bind arguments by name (e.g. $adminEmail), by type (e.g. Psr\\Log\\LoggerInterface) or both (e.g. Psr\\Log\\LoggerInterface $requestLogger). The bind config can also be applied to specific services or when loading many services at once ). Abstract Service Arguments Sometimes, the values of some service arguments can't be defined in the configuration files because they are calculated at runtime using a compiler pass or bundle extension . In those cases, you can use the abstract argument type to define at least the name of the argument and some short description about its purpose: # config/services.yaml services: # ... App\\Service\\MyService: arguments: $rootNamespace: !abstract 'should be defined by Pass' # ... <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <service id=\"App\\Service\\MyService\" class=\"App\\Service\\MyService\"> <argument key=\"$rootNamespace\" type=\"abstract\">should be defined by Pass</argument> </service> <!-- ... --> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MyService; use Psr\\Log\\LoggerInterface; use Symfony\\Component\\DependencyInjection\\Definition; use Symfony\\Component\\DependencyInjection\\Reference; return function(ContainerConfigurator $container) { $services = $container->services(); $services->set(MyService::class) ->arg('$rootNamespace', abstract_arg('should be defined by Pass')) ; // ... }; If you don't replace the value of an abstract argument during runtime, a RuntimeException will be thrown with a message like Argument \"$rootNamespace\" of service \"App\\Service\\MyService\" is abstract: should be defined by Pass. The autowire Option Above, the services.yaml file has autowire: true in the _defaults section so that it applies to all services defined in that file. With this setting, you're able to type-hint arguments in the __construct() method of your services and the container will automatically pass you the correct arguments. This entire entry has been written around autowiring. For more details about autowiring, check out /service_container/autowiring. The autoconfigure Option Above, the services.yaml file has autoconfigure: true in the _defaults section so that it applies to all services defined in that file. With this setting, the container will automatically apply certain configuration to your services, based on your service's *class*. This is mostly used to *auto-tag* your services. For example, to create a Twig extension, you need to create a class, register it as a service, and tag it with twig.extension. But, with autoconfigure: true, you don't need the tag. In fact, if you're using the default services.yaml config , you don't need to do *anything*: the service will be automatically loaded. Then, autoconfigure will add the twig.extension tag *for* you, because your class implements Twig\\Extension\\ExtensionInterface. And thanks to autowire, you can even add constructor arguments without any configuration. Autoconfiguration also works", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_9", "source": "service_container.rst", "text": "to your services, based on your service's *class*. This is mostly used to *auto-tag* your services. For example, to create a Twig extension, you need to create a class, register it as a service, and tag it with twig.extension. But, with autoconfigure: true, you don't need the tag. In fact, if you're using the default services.yaml config , you don't need to do *anything*: the service will be automatically loaded. Then, autoconfigure will add the twig.extension tag *for* you, because your class implements Twig\\Extension\\ExtensionInterface. And thanks to autowire, you can even add constructor arguments without any configuration. Autoconfiguration also works with attributes. Some attributes like Symfony\\\\Component\\\\Messenger\\\\Attribute\\\\AsMessageHandler, Symfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener and Symfony\\\\Component\\\\Console\\\\Attribute\\\\AsCommand are registered for autoconfiguration. Any class using these attributes will have tags applied to them. Linting Service Definitions The lint:container command performs additional checks to ensure the container is properly configured. It is useful to run this command before deploying your application to production (e.g. in your continuous integration server): $ php bin/console lint:container # optionally, you can force the resolution of environment variables; # the command will fail if any of those environment variables are missing $ php bin/console lint:container --resolve-env-vars The --resolve-env-vars option was introduced in Symfony 7.2. Performing those checks whenever the container is compiled can hurt performance. That's why they are implemented in compiler passes called CheckTypeDeclarationsPass and CheckAliasValidityPass, which are disabled by default and enabled only when executing the lint:container command. If you don't mind the performance loss, you can enable these compiler passes in your application. The CheckAliasValidityPass compiler pass was introduced in Symfony 7.1. Public Versus Private Services Every service defined is private by default. When a service is private, you cannot access it directly from the container using $container->get(). As a best practice, you should only create *private* services and you should fetch services using dependency injection instead of using $container->get(). If you need to fetch services lazily, instead of using public services you should consider using a service locator . But, if you *do* need to make a service public, override the public setting: # config/services.yaml services: # ... same code as before # explicitly configure the service App\\Service\\PublicService: public: true <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... same code as before --> <!-- Explicitly configure the service --> <service id=\"App\\Service\\PublicService\" public=\"true\"></service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\PublicService; return function(ContainerConfigurator $container): void { // ... same as code before // explicitly configure the service $services->set(Service\\PublicService::class) ->public() ; }; It is also possible to define a service as public thanks to the #[Autoconfigure] attribute. This attribute must be used directly on the class of the service you want to configure:: // src/Service/PublicService.php namespace App\\Service; use Symfony\\Component\\DependencyInjection\\Attribute\\Autoconfigure; #[Autoconfigure(public: true)] class PublicService { // ... } Importing Many Services at once with resource You've already seen that you can import many services at once by using the resource key. For example, the default Symfony configuration contains this: # config/services.yaml services: # ... same as before", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_10", "source": "service_container.rst", "text": "{ // ... same as code before // explicitly configure the service $services->set(Service\\PublicService::class) ->public() ; }; It is also possible to define a service as public thanks to the #[Autoconfigure] attribute. This attribute must be used directly on the class of the service you want to configure:: // src/Service/PublicService.php namespace App\\Service; use Symfony\\Component\\DependencyInjection\\Attribute\\Autoconfigure; #[Autoconfigure(public: true)] class PublicService { // ... } Importing Many Services at once with resource You've already seen that you can import many services at once by using the resource key. For example, the default Symfony configuration contains this: # config/services.yaml services: # ... same as before # makes classes in src/ available to be used as services # this creates a service per class whose id is the fully-qualified class name App\\: resource: '../src/' exclude: '../src/{DependencyInjection,Entity,Kernel.php}' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... same as before --> <prototype namespace=\"App\\\" resource=\"../src/\" exclude=\"../src/{DependencyInjection,Entity,Kernel.php}\"/> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $container): void { // ... // makes classes in src/ available to be used as services // this creates a service per class whose id is the fully-qualified class name $services->load('App\\\\', '../src/') ->exclude('../src/{DependencyInjection,Entity,Kernel.php}'); }; The value of the resource and exclude options can be any valid `glob pattern`_. If you want to exclude only a few services, you may use the Symfony\\\\Component\\\\DependencyInjection\\\\Attribute\\\\Exclude attribute directly on your class to exclude it. This can be used to quickly make many classes available as services and apply some default configuration. The id of each service is its fully-qualified class name. You can override any service that's imported by using its id (class name) below (e.g. see how to manually wire arguments ). If you override a service, none of the options (e.g. public) are inherited from the import (but the overridden service *does* still inherit from _defaults). You can also exclude certain paths. This is optional, but will slightly increase performance in the dev environment: excluded paths are not tracked and so modifying them will not cause the container to be rebuilt. Wait, does this mean that *every* class in src/ is registered as a service? Even model classes? Actually, no. As long as you keep your imported services as private , all classes in src/ that are *not* explicitly used as services are automatically removed from the final container. In reality, the import means that all classes are \"available to be *used* as services\" without needing to be manually configured. Multiple Service Definitions Using the Same Namespace If you define services using the YAML config format, the PHP namespace is used as the key of each configuration, so you can't define different service configs for classes under the same namespace: # config/services.yaml services: App\\Domain\\: resource: '../src/Domain/*' # ... <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <prototype namespace=\"App\\Domain\" resource=\"../src/App/Domain/*\"/> <!-- ... --> </services> </container> // config/services.php use Symfony\\Component\\DependencyInjection\\Definition; $defaults = new Definition(); // $this is a reference to the current loader $this->registerClasses( $defaults, 'App\\\\Domain\\\\', '../src/App/Domain/*' );", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_11", "source": "service_container.rst", "text": "*used* as services\" without needing to be manually configured. Multiple Service Definitions Using the Same Namespace If you define services using the YAML config format, the PHP namespace is used as the key of each configuration, so you can't define different service configs for classes under the same namespace: # config/services.yaml services: App\\Domain\\: resource: '../src/Domain/*' # ... <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <prototype namespace=\"App\\Domain\" resource=\"../src/App/Domain/*\"/> <!-- ... --> </services> </container> // config/services.php use Symfony\\Component\\DependencyInjection\\Definition; $defaults = new Definition(); // $this is a reference to the current loader $this->registerClasses( $defaults, 'App\\\\Domain\\\\', '../src/App/Domain/*' ); // ... In order to have multiple definitions, add the namespace option and use any unique string as the key of each service config: # config/services.yaml services: command_handlers: namespace: App\\Domain\\ resource: '../src/Domain/*/CommandHandler' tags: [command_handler] event_subscribers: namespace: App\\Domain\\ resource: '../src/Domain/*/EventSubscriber' tags: [event_subscriber] Explicitly Configuring Services and Arguments Loading services automatically and autowiring are optional. And even if you use them, there may be some cases where you want to manually wire a service. For example, suppose that you want to register *2* services for the SiteUpdateManager class - each with a different admin email. In this case, each needs to have a unique service id: # config/services.yaml services: # ... # this is the service's id site_update_manager.superadmin: class: App\\Service\\SiteUpdateManager # you CAN still use autowiring: we just want to show what it looks like without autowire: false # manually wire all arguments arguments: - '@App\\Service\\MessageGenerator' - '@mailer' - 'superadmin@example.com' site_update_manager.normal_users: class: App\\Service\\SiteUpdateManager autowire: false arguments: - '@App\\Service\\MessageGenerator' - '@mailer' - 'contact@example.com' # Create an alias, so that - by default - if you type-hint SiteUpdateManager, # the site_update_manager.superadmin will be used App\\Service\\SiteUpdateManager: '@site_update_manager.superadmin' <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... --> <service id=\"site_update_manager.superadmin\" class=\"App\\Service\\SiteUpdateManager\" autowire=\"false\"> <argument type=\"service\" id=\"App\\Service\\MessageGenerator\"/> <argument type=\"service\" id=\"mailer\"/> <argument>superadmin@example.com</argument> </service> <service id=\"site_update_manager.normal_users\" class=\"App\\Service\\SiteUpdateManager\" autowire=\"false\"> <argument type=\"service\" id=\"App\\Service\\MessageGenerator\"/> <argument type=\"service\" id=\"mailer\"/> <argument>contact@example.com</argument> </service> <service id=\"App\\Service\\SiteUpdateManager\" alias=\"site_update_manager.superadmin\"/> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageGenerator; use App\\Service\\SiteUpdateManager; return function(ContainerConfigurator $container): void { // ... // site_update_manager.superadmin is the service's id $services->set('site_update_manager.superadmin', SiteUpdateManager::class) // you CAN still use autowiring: we just want to show what it looks like without ->autowire(false) // manually wire all arguments ->args([ service(MessageGenerator::class), service('mailer'), 'superadmin@example.com', ]); $services->set('site_update_manager.normal_users', SiteUpdateManager::class) ->autowire(false) ->args([ service(MessageGenerator::class), service('mailer'), 'contact@example.com', ]); // Create an alias, so that - by default - if you type-hint SiteUpdateManager, // the site_update_manager.superadmin will be used $services->alias(SiteUpdateManager::class, 'site_update_manager.superadmin'); }; In this case, *two* services are registered: site_update_manager.superadmin and site_update_manager.normal_users. Thanks to the alias, if you type-hint SiteUpdateManager the first (site_update_manager.superadmin) will be passed. If you want to pass the second, you'll need to manually wire the service or to create a named autowiring alias . If you do *not* create the alias and are loading all services from src/ , then *three* services have been created (the automatic service + your two services) and the automatically loaded service will be passed - by default - when you type-hint SiteUpdateManager. That's why", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_12", "source": "service_container.rst", "text": "the site_update_manager.superadmin will be used $services->alias(SiteUpdateManager::class, 'site_update_manager.superadmin'); }; In this case, *two* services are registered: site_update_manager.superadmin and site_update_manager.normal_users. Thanks to the alias, if you type-hint SiteUpdateManager the first (site_update_manager.superadmin) will be passed. If you want to pass the second, you'll need to manually wire the service or to create a named autowiring alias . If you do *not* create the alias and are loading all services from src/ , then *three* services have been created (the automatic service + your two services) and the automatically loaded service will be passed - by default - when you type-hint SiteUpdateManager. That's why creating the alias is a good idea. When using PHP closures to configure your services, it is possible to automatically inject the current environment value by adding a string argument named $env to the closure:: // config/packages/my_config.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; return function(ContainerConfigurator $containerConfigurator, string $env): void { // `$env` is automatically filled in, so you can configure your // services depending on which environment you're on }; Generating Adapters for Functional Interfaces Functional interfaces are interfaces with a single method. They are conceptually very similar to a closure except that their only method has a name. Moreover, they can be used as type-hints across your code. The Symfony\\\\Component\\\\DependencyInjection\\\\Attribute\\\\AutowireCallable attribute can be used to generate an adapter for a functional interface. Let's say you have the following functional interface:: // src/Service/MessageFormatterInterface.php namespace App\\Service; interface MessageFormatterInterface { public function format(string $message, array $parameters): string; } You also have a service that defines many methods and one of them is the same format() method of the previous interface:: // src/Service/MessageUtils.php namespace App\\Service; class MessageUtils { // other methods... public function format(string $message, array $parameters): string { // ... } } Thanks to the #[AutowireCallable] attribute, you can now inject this MessageUtils service as a functional interface implementation:: namespace App\\Service\\Mail; use App\\Service\\MessageFormatterInterface; use App\\Service\\MessageUtils; use Symfony\\Component\\DependencyInjection\\Attribute\\AutowireCallable; class Mailer { public function __construct( #[AutowireCallable(service: MessageUtils::class, method: 'format')] private MessageFormatterInterface $formatter ) { } public function sendMail(string $message, array $parameters): string { $formattedMessage = $this->formatter->format($message, $parameters); // ... } } Instead of using the #[AutowireCallable] attribute, you can also generate an adapter for a functional interface through configuration: # config/services.yaml services: # ... app.message_formatter: class: App\\Service\\MessageFormatterInterface from_callable: [!service {class: 'App\\Service\\MessageUtils'}, 'format'] <!-- config/services.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\"> <services> <!-- ... --> <service id=\"app.message_formatter\" class=\"App\\Service\\MessageFormatterInterface\"> <from-callable method=\"format\"> <service class=\"App\\Service\\MessageUtils\"/> </from-callable> </service> </services> </container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageFormatterInterface; use App\\Service\\MessageUtils; return function(ContainerConfigurator $container) { // ... $container ->set('app.message_formatter', MessageFormatterInterface::class) ->fromCallable([inline_service(MessageUtils::class), 'format']) ->alias(MessageFormatterInterface::class, 'app.message_formatter') ; }; By doing so, Symfony will generate a class (also called an *adapter*) implementing MessageFormatterInterface that will forward calls of MessageFormatterInterface::format() to your underlying service's method MessageUtils::format(), with all its arguments. Learn more :maxdepth: 1 :glob: /service_container/*", "title": "Service Container", "category": "service_container"}
{"chunk_id": "service_container.rst_fixed_13", "source": "service_container.rst", "text": "</container> // config/services.php namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator; use App\\Service\\MessageFormatterInterface; use App\\Service\\MessageUtils; return function(ContainerConfigurator $container) { // ... $container ->set('app.message_formatter', MessageFormatterInterface::class) ->fromCallable([inline_service(MessageUtils::class), 'format']) ->alias(MessageFormatterInterface::class, 'app.message_formatter') ; }; By doing so, Symfony will generate a class (also called an *adapter*) implementing MessageFormatterInterface that will forward calls of MessageFormatterInterface::format() to your underlying service's method MessageUtils::format(), with all its arguments. Learn more :maxdepth: 1 :glob: /service_container/*", "title": "Service Container", "category": "service_container"}
{"chunk_id": "translation.rst_fixed_0", "source": "translation.rst", "text": "Translations The term \"internationalization\" (often abbreviated `i18n`_) refers to the process of abstracting strings and other locale-specific pieces out of your application into a layer where they can be translated and converted based on the user's locale (i.e. language and country). For text, this means wrapping each with a function capable of translating the text (or \"message\") into the language of the user:: // text will *always* print out in English echo 'Hello World'; // text can be translated into the end-user's language or // default to English echo $translator->trans('Hello World'); The term *locale* refers roughly to the user's language and country. It can be any string that your application uses to manage translations and other format differences (e.g. currency format). The `ISO 639-1`_ *language* code, an underscore (_), then the `ISO 3166-1 alpha-2`_ *country* code (e.g. fr_FR for French/France) is recommended. Translations can be organized into groups, called **domains**. By default, all messages use the default messages domain:: echo $translator->trans('Hello World', domain: 'messages'); The translation process has several steps: #. Enable and configure Symfony's translation service; #. Abstract strings (i.e. \"messages\") by wrapping them in calls to the Translator; #. Create translation resources/files for each supported locale that translate each message in the application; #. Determine, set and manage the user's locale for the request and optionally on the user's entire session . Installation First, run this command to install the translator before using it: $ composer require symfony/translation Symfony includes several internationalization polyfills (symfony/polyfill-intl-icu, symfony/polyfill-intl-messageformatter, etc.) that allow you to use translation features even without the `PHP intl extension`_. However, these polyfills only support English translations, so you must install the PHP intl extension when translating into other languages. Configuration The previous command creates an initial config file where you can define the default locale of the application and the directory where the translation files are located: # config/packages/translation.yaml framework: default_locale: 'en' translator: default_path: '%kernel.project_dir%/translations' <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config default-locale=\"en\"> <framework:translator default-path=\"%kernel.project_dir%/translations\" /> </framework:config> </container> // config/packages/translation.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { // ... $framework ->defaultLocale('en') ->translator() ->defaultPath('%kernel.project_dir%/translations') ; }; You can also define the enabled_locales option to restrict the locales that your application is available in. Basic Translation Translation of text is done through the translator service (Symfony\\\\Component\\\\Translation\\\\Translator). To translate a block of text (called a *message*), use the Symfony\\\\Component\\\\Translation\\\\Translator::trans method. Suppose, for example, that you're translating a static message from inside a controller:: // ... use Symfony\\Contracts\\Translation\\TranslatorInterface; public function index(TranslatorInterface $translator): Response { $translated = $translator->trans('Symfony is great'); // ... } When this code is run, Symfony will attempt to translate the message \"Symfony is great\" based on the locale of the user. For this to work, you need to tell Symfony how to translate the message via a \"translation resource\", which is usually a file that contains a collection of translations for a given locale. This \"dictionary\" of translations can be created in several different formats: # translations/messages.fr.yaml Symfony", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_1", "source": "translation.rst", "text": "Suppose, for example, that you're translating a static message from inside a controller:: // ... use Symfony\\Contracts\\Translation\\TranslatorInterface; public function index(TranslatorInterface $translator): Response { $translated = $translator->trans('Symfony is great'); // ... } When this code is run, Symfony will attempt to translate the message \"Symfony is great\" based on the locale of the user. For this to work, you need to tell Symfony how to translate the message via a \"translation resource\", which is usually a file that contains a collection of translations for a given locale. This \"dictionary\" of translations can be created in several different formats: # translations/messages.fr.yaml Symfony is great: Symfony est génial <!-- translations/messages.fr.xlf --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\"> <file source-language=\"en\" datatype=\"plaintext\" original=\"file.ext\"> <body> <trans-unit id=\"symfony_is_great\"> <source>Symfony is great</source> <target>Symfony est génial</target> </trans-unit> </body> </file> </xliff> // translations/messages.fr.php return [ 'Symfony is great' => 'Symfony est génial', ]; You can find more information on where these files should be located . Now, if the language of the user's locale is French (e.g. fr_FR or fr_BE), the message will be translated into Symfony est génial. You can also translate the message inside your templates . Using Real or Keyword Messages This example illustrates the two different philosophies when creating messages to be translated:: $translator->trans('Symfony is great'); $translator->trans('symfony.great'); In the first method, messages are written in the language of the default locale (English in this case). That message is then used as the \"id\" when creating translations. In the second method, messages are actually \"keywords\" that convey the idea of the message. The keyword message is then used as the \"id\" for any translations. In this case, translations must be made for the default locale (i.e. to translate symfony.great to Symfony is great). The second method is handy because the message key won't need to be changed in every translation file if you decide that the message should actually read \"Symfony is really great\" in the default locale. The choice of which method to use is entirely up to you, but the \"keyword\" format is often recommended for multi-language applications, whereas for shared bundles that contain translation resources we recommend the real message, so your application can choose to disable the translator layer and you will see a readable message. Additionally, the php and yaml file formats support nested ids to avoid repeating yourself if you use keywords instead of real text for your ids: symfony: is: # id is symfony.is.great great: Symfony is great # id is symfony.is.amazing amazing: Symfony is amazing has: # id is symfony.has.bundles bundles: Symfony has bundles user: # id is user.login login: Login [ 'symfony' => [ 'is' => [ // id is symfony.is.great 'great' => 'Symfony is great', // id is symfony.is.amazing 'amazing' => 'Symfony is amazing', ], 'has' => [ // id is symfony.has.bundles 'bundles' => 'Symfony has bundles', ], ], 'user' => [ // id is user.login 'login' => 'Login', ], ]; The Translation Process To actually translate the message, Symfony uses the following process when using", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_2", "source": "translation.rst", "text": "is: # id is symfony.is.great great: Symfony is great # id is symfony.is.amazing amazing: Symfony is amazing has: # id is symfony.has.bundles bundles: Symfony has bundles user: # id is user.login login: Login [ 'symfony' => [ 'is' => [ // id is symfony.is.great 'great' => 'Symfony is great', // id is symfony.is.amazing 'amazing' => 'Symfony is amazing', ], 'has' => [ // id is symfony.has.bundles 'bundles' => 'Symfony has bundles', ], ], 'user' => [ // id is user.login 'login' => 'Login', ], ]; The Translation Process To actually translate the message, Symfony uses the following process when using the trans() method: #. The locale of the current user, which is stored on the request is determined; this is typically set via a _locale attribute on your routes ; #. A catalog of translated messages is loaded from translation resources defined for the locale (e.g. fr_FR). Messages from the fallback locale and the enabled locales are also loaded and added to the catalog if they don't already exist. The end result is a large \"dictionary\" of translations. #. If the message is located in the catalog, the translation is returned. If not, the translator returns the original message. Message Format Sometimes, a message containing a variable needs to be translated:: // ... $translated = $translator->trans('Hello '.$name); However, creating a translation for this string is impossible since the translator will try to look up the message including the variable portions (e.g. *\"Hello Ryan\"* or *\"Hello Fabien\"*). Another complication is when you have translations that may or may not be plural, based on some variable: There is one apple. There are 5 apples. To manage these situations, Symfony follows the `ICU MessageFormat`_ syntax by using PHP's MessageFormatter class. Read more about this in /reference/formats/message_format. Translatable Objects Sometimes translating contents in templates is cumbersome because you need the original message, the translation parameters and the translation domain for each content. Making the translation in the controller or services simplifies your templates, but requires injecting the translator service in different parts of your application and mocking it in your tests. Instead of translating a string at the time of creation, you can use a \"translatable object\", which is an instance of the Symfony\\\\Component\\\\Translation\\\\TranslatableMessage class. This object stores all the information needed to fully translate its contents when needed:: use Symfony\\Component\\Translation\\TranslatableMessage; // the first argument is required and it's the original message $message = new TranslatableMessage('Symfony is great!'); // the optional second argument defines the translation parameters and // the optional third argument is the translation domain $status = new TranslatableMessage('order.status', ['%status%' => $order->getStatus()], 'store'); Templates are now much simpler because you can pass translatable objects to the trans filter: <h1>{{ message|trans }}</h1> <p>{{ status|trans }}</p> The translation parameters can also be a Symfony\\\\Component\\\\Translation\\\\TranslatableMessage. There's also a function called t() , available both in Twig and PHP, as a shortcut to create translatable objects. Translations in Templates Most of the time, translation occurs in templates. Symfony provides native support for both Twig and PHP", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_3", "source": "translation.rst", "text": "new TranslatableMessage('Symfony is great!'); // the optional second argument defines the translation parameters and // the optional third argument is the translation domain $status = new TranslatableMessage('order.status', ['%status%' => $order->getStatus()], 'store'); Templates are now much simpler because you can pass translatable objects to the trans filter: <h1>{{ message|trans }}</h1> <p>{{ status|trans }}</p> The translation parameters can also be a Symfony\\\\Component\\\\Translation\\\\TranslatableMessage. There's also a function called t() , available both in Twig and PHP, as a shortcut to create translatable objects. Translations in Templates Most of the time, translation occurs in templates. Symfony provides native support for both Twig and PHP templates. Using Twig Filters The trans filter can be used to translate *variable texts* and complex expressions: {{ message|trans }} {{ message|trans({'%name%': 'Fabien'}, 'app') }} You can set the translation domain for an entire Twig template with a single tag: {% trans_default_domain 'app' %} Note that this only influences the current template, not any \"included\" template (in order to avoid side effects). By default, the translated messages are output escaped; apply the raw filter after the translation filter to avoid the automatic escaping: {% set message = '<h3>foo</h3>' %} {# strings and variables translated via a filter are escaped by default #} {{ message|trans|raw }} {{ '<h3>bar</h3>'|trans|raw }} Using Twig Tags Symfony provides a specialized Twig tag trans to help with message translation of *static blocks of text*: {% trans %}Hello %name%{% endtrans %} The %var% notation of placeholders is required when translating in Twig templates using the tag. If you need to use the percent character (%) in a string, escape it by doubling it: {% trans %}Percent: %percent%%%{% endtrans %} You can also specify the message domain and pass some additional variables: {% trans with {'%name%': 'Fabien'} from 'app' %}Hello %name%{% endtrans %} {% trans with {'%name%': 'Fabien'} from 'app' into 'fr' %}Hello %name%{% endtrans %} Using the translation tag has the same effect as the filter, but with one major difference: automatic output escaping is **not** applied to translations using a tag. Global Translation Parameters The global translation parameters feature was introduced in Symfony 7.3. If the content of a translation parameter is repeated across multiple translation messages (e.g. a company name, or a version number), you can define it as a global translation parameter. This helps you avoid repeating the same values manually in each message. You can configure these global parameters in the translations.globals option of your main configuration file using either %...% or {...} syntax: # config/packages/translator.yaml translator: # ... globals: # when using the '%' wrapping characters, you must escape them '%%app_name%%': 'My application' '{app_version}': '1.2.3' '{url}': { message: 'url', parameters: { scheme: 'https://' }, domain: 'global' } <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:translator> <!-- ... --> <!-- when using the '%' wrapping characters, you must escape them --> <framework:global name=\"%%app_name%%\">My application</framework:global> <framework:global name=\"{app_version}\" value=\"1.2.3\"/> <framework:global name=\"{url}\" message=\"url\" domain=\"global\"> <framework:parameter name=\"scheme\">https://</framework:parameter> </framework:global> </framework:translator> </framework:config> </container> // config/packages/translator.php use Symfony\\Config\\TwigConfig; return static function", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_4", "source": "translation.rst", "text": "of your main configuration file using either %...% or {...} syntax: # config/packages/translator.yaml translator: # ... globals: # when using the '%' wrapping characters, you must escape them '%%app_name%%': 'My application' '{app_version}': '1.2.3' '{url}': { message: 'url', parameters: { scheme: 'https://' }, domain: 'global' } <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:translator> <!-- ... --> <!-- when using the '%' wrapping characters, you must escape them --> <framework:global name=\"%%app_name%%\">My application</framework:global> <framework:global name=\"{app_version}\" value=\"1.2.3\"/> <framework:global name=\"{url}\" message=\"url\" domain=\"global\"> <framework:parameter name=\"scheme\">https://</framework:parameter> </framework:global> </framework:translator> </framework:config> </container> // config/packages/translator.php use Symfony\\Config\\TwigConfig; return static function (TwigConfig $translator): void { // ... // when using the '%' wrapping characters, you must escape them $translator->globals('%%app_name%%')->value('My application'); $translator->globals('{app_version}')->value('1.2.3'); $translator->globals('{url}')->value(['message' => 'url', 'parameters' => ['scheme' => 'https://']]); }; Once defined, you can use these parameters in translation messages anywhere in your application: {{ 'Application version: {app_version}'|trans }} {# output: \"Application version: 1.2.3\" #} {# parameters passed to the message override global parameters #} {{ 'Package version: {app_version}'|trans({'{app_version}': '2.3.4'}) }} # Displays \"Package version: 2.3.4\" Forcing the Translator Locale When translating a message, the translator uses the specified locale or the fallback locale if necessary. You can also manually specify the locale to use for translation:: $translator->trans('Symfony is great', locale: 'fr_FR'); Extracting Translation Contents and Updating Catalogs Automatically The most time-consuming task when translating an application is to extract all the template contents to be translated and to keep all the translation files in sync. Symfony includes a command called translation:extract that helps you with these tasks: # shows all the messages that should be translated for the French language $ php bin/console translation:extract --dump-messages fr # updates the French translation files with the missing strings for that locale $ php bin/console translation:extract --force fr # check out the command help to see its options (prefix, output format, domain, sorting, etc.) $ php bin/console translation:extract --help The translation:extract command looks for missing translations in: * Templates stored in the templates/ directory (or any other directory defined in the twig.default_path and twig.paths config options); * Any PHP file/class that injects or autowires the translator service and makes calls to the trans() method; * Any PHP file/class stored in the src/ directory that creates translatable objects using the constructor or the t() method or calls the trans() method; * Any PHP file/class stored in the src/ directory that uses Constraints Attributes with *message named argument(s). Install the nikic/php-parser package in your project to improve the results of the translation:extract command. This package enables an `AST`_ parser that can find many more translatable items: $ composer require nikic/php-parser By default, when the translation:extract command creates new entries in the translation file, it uses the same content as both the source and the pending translation. The only difference is that the pending translation is prefixed by __. You can customize this prefix using the --prefix option: $ php bin/console translation:extract --force --prefix=\"NEW_\" fr Alternatively, you can use the --no-fill option to leave the pending", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_5", "source": "translation.rst", "text": "*message named argument(s). Install the nikic/php-parser package in your project to improve the results of the translation:extract command. This package enables an `AST`_ parser that can find many more translatable items: $ composer require nikic/php-parser By default, when the translation:extract command creates new entries in the translation file, it uses the same content as both the source and the pending translation. The only difference is that the pending translation is prefixed by __. You can customize this prefix using the --prefix option: $ php bin/console translation:extract --force --prefix=\"NEW_\" fr Alternatively, you can use the --no-fill option to leave the pending translation completely empty when creating new entries in the translation catalog. This is particularly useful when using external translation tools, as it makes it easier to spot untranslated strings: # when using the --no-fill option, the --prefix option is ignored $ php bin/console translation:extract --force --no-fill fr The --no-fill option was introduced in Symfony 7.2. Translation Resource/File Names and Locations Symfony looks for message files (i.e. translations) in the following default locations: * the translations/ directory (at the root of the project); * the translations/ directory inside of any bundle (and also their Resources/translations/ directory, which is no longer recommended for bundles). The locations are listed here with the highest priority first. That is, you can override the translation messages of a bundle in the first directory. Bundles are processed in the order in which they are listed in the config/bundles.php file, so bundles appearing earlier have higher priority. The override mechanism works at a key level: only the overridden keys need to be listed in a higher priority message file. When a key is not found in a message file, the translator will automatically fall back to the lower priority message files. The filename of the translation files is also important: each message file must be named according to the following path: domain.locale.loader: * **domain**: The translation domain; * **locale**: The locale that the translations are for (e.g. en_GB, en, etc); * **loader**: How Symfony should load and parse the file (e.g. xlf, php, yaml, etc). The loader can be the name of any registered loader. By default, Symfony provides many loaders which are selected based on the following file extensions: * .yaml: YAML file (you can also use the .yml file extension); * .xlf: XLIFF file (you can also use the .xliff file extension); * .php: a PHP file that returns an array with the translations; * .csv: CSV file; * .json: JSON file; * .ini: INI file; * .dat, .res: `ICU resource bundle`_; * .mo: `Machine object format`_; * .po: `Portable object format`_; * .qt: `QT Translations TS XML`_ file; The choice of which loader to use is entirely up to you and is a matter of taste. The recommended option is to use YAML for simple projects and use XLIFF if you're generating translations with specialized programs or teams. Each time you create a *new* message catalog (or install a bundle that includes a translation catalog),", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_6", "source": "translation.rst", "text": "file that returns an array with the translations; * .csv: CSV file; * .json: JSON file; * .ini: INI file; * .dat, .res: `ICU resource bundle`_; * .mo: `Machine object format`_; * .po: `Portable object format`_; * .qt: `QT Translations TS XML`_ file; The choice of which loader to use is entirely up to you and is a matter of taste. The recommended option is to use YAML for simple projects and use XLIFF if you're generating translations with specialized programs or teams. Each time you create a *new* message catalog (or install a bundle that includes a translation catalog), be sure to clear your cache so that Symfony can discover the new translation resources: $ php bin/console cache:clear You can add other directories with the paths option in the configuration: # config/packages/translation.yaml framework: translator: paths: - '%kernel.project_dir%/custom/path/to/translations' <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-Instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:translator> <framework:path>%kernel.project_dir%/custom/path/to/translations</framework:path> </framework:translator> </framework:config> </container> // config/packages/translation.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->translator() ->paths(['%kernel.project_dir%/custom/path/to/translations']) ; }; Translations of Doctrine Entities Unlike the contents of templates, it's not practical to translate the contents stored in Doctrine Entities using translation catalogs. Instead, use the Doctrine `Translatable Extension`_. Custom Translation Resources If your translations use a format not supported by Symfony or you store them in a special way (e.g. not using files or Doctrine entities), you need to provide a custom class implementing the Symfony\\\\Component\\\\Translation\\\\Loader\\\\LoaderInterface interface. See the dic-tags-translation-loader tag for more information. Translation Providers When using external translators to translate your application, you must send them the new contents to translate frequently and merge the results back in the application. Instead of doing this manually, Symfony provides integration with several third-party translation services. You can upload and download (called \"push\" and \"pull\") translations to/from these services and merge the results automatically in the application. Installing and Configuring a Third Party Provider Before pushing/pulling translations to a third-party provider, you must install the package that provides integration with that provider: ====================== =========================================================== Provider Install with ====================== =========================================================== `Crowdin`_ composer require symfony/crowdin-translation-provider `Loco (localise.biz)`_ composer require symfony/loco-translation-provider `Lokalise`_ composer require symfony/lokalise-translation-provider `Phrase`_ composer require symfony/phrase-translation-provider ====================== =========================================================== Each library includes a Symfony Flex recipe that will add a configuration example to your .env file. For example, suppose you want to use Loco. First, install it: $ composer require symfony/loco-translation-provider You'll now have a new line in your .env file that you can uncomment: # .env LOCO_DSN=loco://API_KEY@default The LOCO_DSN isn't a *real* address: it's a convenient format that offloads most of the configuration work to Symfony. The loco scheme activates the Loco provider that you installed, which knows all about how to push and pull translations via Loco. The *only* part you need to change is the API_KEY placeholder. This table shows the full list of available DSN formats for each provider: ====================== ============================================================== Provider DSN ====================== ============================================================== `Crowdin`_ crowdin://PROJECT_ID:API_TOKEN@ORGANIZATION_DOMAIN.default `Loco (localise.biz)`_ loco://API_KEY@default `Lokalise`_ lokalise://PROJECT_ID:API_KEY@default `Phrase`_ phrase://PROJECT_ID:API_TOKEN@default?userAgent=myProject ====================== ============================================================== To enable a translation provider, customize the", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_7", "source": "translation.rst", "text": "in your .env file that you can uncomment: # .env LOCO_DSN=loco://API_KEY@default The LOCO_DSN isn't a *real* address: it's a convenient format that offloads most of the configuration work to Symfony. The loco scheme activates the Loco provider that you installed, which knows all about how to push and pull translations via Loco. The *only* part you need to change is the API_KEY placeholder. This table shows the full list of available DSN formats for each provider: ====================== ============================================================== Provider DSN ====================== ============================================================== `Crowdin`_ crowdin://PROJECT_ID:API_TOKEN@ORGANIZATION_DOMAIN.default `Loco (localise.biz)`_ loco://API_KEY@default `Lokalise`_ lokalise://PROJECT_ID:API_KEY@default `Phrase`_ phrase://PROJECT_ID:API_TOKEN@default?userAgent=myProject ====================== ============================================================== To enable a translation provider, customize the DSN in your .env file and configure the providers option: # config/packages/translation.yaml framework: translator: providers: loco: dsn: '%env(LOCO_DSN)%' domains: ['messages'] locales: ['en', 'fr'] <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:translator> <framework:provider name=\"loco\" dsn=\"%env(LOCO_DSN)%\"> <framework:domain>messages</framework:domain> <!-- ... --> <framework:locale>en</framework:locale> <framework:locale>fr</framework:locale> <!-- ... --> </framework:provider> </framework:translator> </framework:config> </container> # config/packages/translation.php $container->loadFromExtension('framework', [ 'translator' => [ 'providers' => [ 'loco' => [ 'dsn' => env('LOCO_DSN'), 'domains' => ['messages'], 'locales' => ['en', 'fr'], ], ], ], ]); If you use Phrase as a provider you must configure a user agent in your dsn. See `Identification via User-Agent`_ for reasoning and some examples. Also make the locale _names_ in Phrase should be as defined in RFC4646 (e.g. pt-BR rather than pt_BR). Not doing so will result in Phrase creating a new locale for the imported keys. If you use Crowdin as a provider and some of your locales are different from the `Crowdin Language Codes`_, you have to set the `Custom Language Codes`_ in the Crowdin project for each of your locales, in order to override the default value. You need to select the \"locale\" placeholder and specify the custom code in the \"Custom Code\" field. If you use Lokalise as a provider and a locale format following the `ISO 639-1`_ (e.g. \"en\" or \"fr\"), you have to set the `Custom Language Name setting`_ in Lokalise for each of your locales, in order to override the default value (which follow the `ISO 639-1`_ succeeded by a sub-code in capital letters that specifies the national variety (e.g. \"GB\" or \"US\" according to `ISO 3166-1 alpha-2`_)). The Phrase provider uses Phrase's tag feature to map translations to Symfony's translation domains. If you need some assistance with organising your tags in Phrase, you might want to consider the `Phrase Tag Bundle`_ which provides some commands helping you with that. Pushing and Pulling Translations After configuring the credentials to access the translation provider, you can now use the following commands to push (upload) and pull (download) translations: # push all local translations to the Loco provider for the locales and domains # configured in config/packages/translation.yaml file. # it will update existing translations already on the provider. $ php bin/console translation:push loco --force # push new local translations to the Loco provider for the French locale # and the validators domain. # it will **not** update existing translations already on", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_8", "source": "translation.rst", "text": "`Phrase Tag Bundle`_ which provides some commands helping you with that. Pushing and Pulling Translations After configuring the credentials to access the translation provider, you can now use the following commands to push (upload) and pull (download) translations: # push all local translations to the Loco provider for the locales and domains # configured in config/packages/translation.yaml file. # it will update existing translations already on the provider. $ php bin/console translation:push loco --force # push new local translations to the Loco provider for the French locale # and the validators domain. # it will **not** update existing translations already on the provider. $ php bin/console translation:push loco --locales fr --domains validators # push new local translations and delete provider's translations that not # exists anymore in local files for the French locale and the validators domain. # it will **not** update existing translations already on the provider. $ php bin/console translation:push loco --delete-missing --locales fr --domains validators # check out the command help to see its options (format, domains, locales, etc.) $ php bin/console translation:push --help # pull all provider's translations to local files for the locales and domains # configured in config/packages/translation.yaml file. # it will overwrite completely your local files. $ php bin/console translation:pull loco --force # pull new translations from the Loco provider to local files for the French # locale and the validators domain. # it will **not** overwrite your local files, only add new translations. $ php bin/console translation:pull loco --locales fr --domains validators # check out the command help to see its options (format, domains, locales, intl-icu, etc.) $ php bin/console translation:pull --help # the \"--as-tree\" option will write YAML messages as a tree-like structure instead # of flat keys $ php bin/console translation:pull loco --force --as-tree Creating Custom Providers In addition to using Symfony's built-in translation providers, you can create your own providers. To do so, you need to create two classes: #. The first class must implement Symfony\\\\Component\\\\Translation\\\\Provider\\\\ProviderInterface; #. The second class needs to be a factory which will create instances of the first class. It must implement Symfony\\\\Component\\\\Translation\\\\Provider\\\\ProviderFactoryInterface (you can extend Symfony\\\\Component\\\\Translation\\\\Provider\\\\AbstractProviderFactory to simplify its creation). After creating these two classes, you need to register your factory as a service and tag it with translation.provider_factory . Handling the User's Locale Translating happens based on the user's locale. The locale of the current user is stored in the request and is accessible via the Request object:: use Symfony\\Component\\HttpFoundation\\Request; public function index(Request $request): void { $locale = $request->getLocale(); } To set the user's locale, you may want to create a custom event listener so that it's set before any other parts of the system (i.e. the translator) need it:: public function onKernelRequest(RequestEvent $event): void { $request = $event->getRequest(); // some logic to determine the $locale $request->setLocale($locale); } The custom listener must be called **before** LocaleListener, which initializes the locale based on the current request. To do so, set your listener priority to a higher value than LocaleListener priority (which you can obtain by", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_9", "source": "translation.rst", "text": "via the Request object:: use Symfony\\Component\\HttpFoundation\\Request; public function index(Request $request): void { $locale = $request->getLocale(); } To set the user's locale, you may want to create a custom event listener so that it's set before any other parts of the system (i.e. the translator) need it:: public function onKernelRequest(RequestEvent $event): void { $request = $event->getRequest(); // some logic to determine the $locale $request->setLocale($locale); } The custom listener must be called **before** LocaleListener, which initializes the locale based on the current request. To do so, set your listener priority to a higher value than LocaleListener priority (which you can obtain by running the debug:event kernel.request command). Read locale-sticky-session for more information on making the user's locale \"sticky\" to their session. Setting the locale using $request->setLocale() in the controller is too late to affect the translator. Either set the locale via a listener (like above), the URL (see next) or call setLocale() directly on the translator service. See the translation-locale-url section below about setting the locale via routing. The Locale and the URL Since you can store the locale of the user in the session, it may be tempting to use the same URL to display a resource in different languages based on the user's locale. For example, http://www.example.com/contact could show content in English for one user and French for another user. Unfortunately, this violates a fundamental rule of the Web: that a particular URL returns the same resource regardless of the user. To further muddy the problem, which version of the content would be indexed by search engines? A better policy is to include the locale in the URL using the special _locale parameter : // src/Controller/ContactController.php namespace App\\Controller; // ... class ContactController extends AbstractController { #[Route( path: '/{_locale}/contact', name: 'contact', requirements: [ '_locale' => 'en|fr|de', ], )] public function contact(): Response { // ... } } # config/routes.yaml contact: path: /{_locale}/contact controller: App\\Controller\\ContactController::index requirements: _locale: en|fr|de <!-- config/routes.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <routes xmlns=\"http://symfony.com/schema/routing\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\"> <route id=\"contact\" path=\"/{_locale}/contact\"> controller=\"App\\Controller\\ContactController::index\"> <requirement key=\"_locale\">en|fr|de</requirement> </route> </routes> // config/routes.php use App\\Controller\\ContactController; use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator; return function (RoutingConfigurator $routes): void { $routes->add('contact', '/{_locale}/contact') ->controller([ContactController::class, 'index']) ->requirements([ '_locale' => 'en|fr|de', ]) ; }; When using the special _locale parameter in a route, the matched locale is *automatically set on the Request* and can be retrieved via the Symfony\\\\Component\\\\HttpFoundation\\\\Request::getLocale method. In other words, if a user visits the URI /fr/contact, the locale fr will automatically be set as the locale for the current request. You can now use the locale to create routes to other translated pages in your application. Define the locale requirement as a container parameter to avoid hardcoding its value in all your routes. Setting a Default Locale What if the user's locale hasn't been determined? You can guarantee that a locale is set on each user's request by defining a default_locale for the framework: # config/packages/translation.yaml framework: default_locale: en <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config default-locale=\"en\"/> </container> // config/packages/translation.php use Symfony\\Config\\FrameworkConfig;", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_10", "source": "translation.rst", "text": "be set as the locale for the current request. You can now use the locale to create routes to other translated pages in your application. Define the locale requirement as a container parameter to avoid hardcoding its value in all your routes. Setting a Default Locale What if the user's locale hasn't been determined? You can guarantee that a locale is set on each user's request by defining a default_locale for the framework: # config/packages/translation.yaml framework: default_locale: en <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config default-locale=\"en\"/> </container> // config/packages/translation.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { $framework->defaultLocale('en'); }; This default_locale is also relevant for the translator, as shown in the next section. Selecting the Language Preferred by the User If your application supports multiple languages, the first time a user visits your site it's common to redirect them to the best possible language according to their preferences. This is achieved with the getPreferredLanguage() method of the Request object :: // get the Request object somehow (e.g. as a controller argument) $request = ... // pass an array of the locales (their script and region parts are optional) supported // by your application and the method returns the best locale for the current user $locale = $request->getPreferredLanguage(['pt', 'fr_Latn_CH', 'en_US'] ); Symfony finds the best possible language based on the locales passed as argument and the value of the Accept-Language HTTP header. If it can't find a perfect match between them, Symfony will try to find a partial match based on the language (e.g. fr_CA would match fr_Latn_CH because their language is the same). If there's no perfect or partial match, this method returns the first locale passed as argument (that's why the order of the passed locales is important). The feature to match locales partially was introduced in Symfony 7.1. Fallback Translation Locales Imagine that the user's locale is es_AR and that you're translating the key Symfony is great. To find the Spanish translation, Symfony actually checks translation resources for several locales: #. First, Symfony looks for the translation in a es_AR (Argentinean Spanish) translation resource (e.g. messages.es_AR.yaml); #. If it wasn't found, Symfony looks for the translation in the parent locale, which is automatically defined only for some locales. In this example, the parent locale is es_419 (Latin American Spanish); #. If it wasn't found, Symfony looks for the translation in a es (Spanish) translation resource (e.g. messages.es.yaml); #. If the translation still isn't found, Symfony uses the fallbacks option, which can be configured as follows. When this option is not defined, it defaults to the default_locale setting mentioned in the previous section. # config/packages/translation.yaml framework: translator: fallbacks: ['en'] # ... <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:translator> <framework:fallback>en</framework:fallback> <!-- ... --> </framework:translator> </framework:config> </container> // config/packages/translation.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { // ... $framework->translator() ->fallbacks(['en']) ; }; When Symfony can't find a translation in", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_11", "source": "translation.rst", "text": "translation in a es (Spanish) translation resource (e.g. messages.es.yaml); #. If the translation still isn't found, Symfony uses the fallbacks option, which can be configured as follows. When this option is not defined, it defaults to the default_locale setting mentioned in the previous section. # config/packages/translation.yaml framework: translator: fallbacks: ['en'] # ... <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:translator> <framework:fallback>en</framework:fallback> <!-- ... --> </framework:translator> </framework:config> </container> // config/packages/translation.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework): void { // ... $framework->translator() ->fallbacks(['en']) ; }; When Symfony can't find a translation in the given locale, it will add the missing translation to the log file. For details, see reference-framework-translator-logging. Switch Locale Programmatically Sometimes you need to change the application's locale dynamically while running some code. For example, a console command that renders email templates in different languages. In such cases, you only need to switch the locale temporarily. The LocaleSwitcher class allows you to do that:: use Symfony\\Component\\Translation\\LocaleSwitcher; class SomeService { public function __construct( private LocaleSwitcher $localeSwitcher, ) { } public function someMethod(): void { $currentLocale = $this->localeSwitcher->getLocale(); // set the application locale programmatically to 'fr' (French): // this affects translation, URL generation, etc. $this->localeSwitcher->setLocale('fr'); // reset the locale to the default one configured via the // 'default_locale' option in config/packages/translation.yaml $this->localeSwitcher->reset(); // run some code with a specific locale, temporarily, without // changing the locale for the rest of the application $this->localeSwitcher->runWithLocale('es', function() { // e.g. render templates, send emails, etc. using the 'es' (Spanish) locale }); // optionally, receive the current locale as an argument: $this->localeSwitcher->runWithLocale('es', function(string $locale) { // here, the $locale argument will be set to 'es' }); // ... } } The LocaleSwitcher class changes the locale of: * All services tagged with kernel.locale_aware; * The default locale set via \\Locale::setDefault(); * The _locale parameter of the RequestContext service (if available), so generated URLs reflect the new locale. The LocaleSwitcher applies the new locale only for the current request, and its effect is lost on subsequent requests, such as after a redirect. See how to make the locale persist across requests . When using autowiring , type-hint any controller or service argument with the Symfony\\\\Component\\\\Translation\\\\LocaleSwitcher class to inject the locale switcher service. Otherwise, configure your services manually and inject the translation.locale_switcher service. How to Find Missing or Unused Translation Messages When you work with many translation messages in different languages, it can be hard to keep track which translations are missing and which are not used anymore. The debug:translation command helps you to find these missing or unused translation messages templates: {# messages can be found when using the trans filter and tag #} {% trans %}Symfony is great{% endtrans %} {{ 'Symfony is great'|trans }} The extractors can't find messages translated outside templates (like form labels or controllers) unless using translatable objects or calling the trans() method on a translator (since Symfony 5.3). Dynamic translations using variables or expressions in templates are not detected either: {#", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_12", "source": "translation.rst", "text": "in different languages, it can be hard to keep track which translations are missing and which are not used anymore. The debug:translation command helps you to find these missing or unused translation messages templates: {# messages can be found when using the trans filter and tag #} {% trans %}Symfony is great{% endtrans %} {{ 'Symfony is great'|trans }} The extractors can't find messages translated outside templates (like form labels or controllers) unless using translatable objects or calling the trans() method on a translator (since Symfony 5.3). Dynamic translations using variables or expressions in templates are not detected either: {# this translation uses a Twig variable, so it won't be detected #} {% set message = 'Symfony is great' %} {{ message|trans }} Suppose your application's default_locale is fr and you have configured en as the fallback locale (see configuration and fallback for how to configure these). And suppose you've already set up some translations for the fr locale: <!-- translations/messages.fr.xlf --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\"> <file source-language=\"en\" datatype=\"plaintext\" original=\"file.ext\"> <body> <trans-unit id=\"1\"> <source>Symfony is great</source> <target>Symfony est génial</target> </trans-unit> </body> </file> </xliff> # translations/messages.fr.yaml Symfony is great: Symfony est génial // translations/messages.fr.php return [ 'Symfony is great' => 'Symfony est génial', ]; and for the en locale: <!-- translations/messages.en.xlf --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\"> <file source-language=\"en\" datatype=\"plaintext\" original=\"file.ext\"> <body> <trans-unit id=\"1\"> <source>Symfony is great</source> <target>Symfony is great</target> </trans-unit> </body> </file> </xliff> # translations/messages.en.yaml Symfony is great: Symfony is great // translations/messages.en.php return [ 'Symfony is great' => 'Symfony is great', ]; To inspect all messages in the fr locale for the application, run: $ php bin/console debug:translation fr --------- ------------------ ---------------------- ------------------------------- State Id Message Preview (fr) Fallback Message Preview (en) --------- ------------------ ---------------------- ------------------------------- unused Symfony is great Symfony est génial Symfony is great --------- ------------------ ---------------------- ------------------------------- It shows you a table with the result when translating the message in the fr locale and the result when the fallback locale en would be used. On top of that, it will also show you when the translation is the same as the fallback translation (this could indicate that the message was not correctly translated). Furthermore, it indicates that the message Symfony is great is unused because it is translated, but you haven't used it anywhere yet. Now, if you translate the message in one of your templates, you will get this output: $ php bin/console debug:translation fr --------- ------------------ ---------------------- ------------------------------- State Id Message Preview (fr) Fallback Message Preview (en) --------- ------------------ ---------------------- ------------------------------- Symfony is great Symfony est génial Symfony is great --------- ------------------ ---------------------- ------------------------------- The state is empty which means the message is translated in the fr locale and used in one or more templates. If you delete the message Symfony is great from your translation file for the fr locale and run the command, you will get: $ php bin/console debug:translation fr --------- ------------------ ---------------------- ------------------------------- State Id Message Preview (fr) Fallback Message Preview (en) --------- ------------------ ----------------------", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_13", "source": "translation.rst", "text": "$ php bin/console debug:translation fr --------- ------------------ ---------------------- ------------------------------- State Id Message Preview (fr) Fallback Message Preview (en) --------- ------------------ ---------------------- ------------------------------- Symfony is great Symfony est génial Symfony is great --------- ------------------ ---------------------- ------------------------------- The state is empty which means the message is translated in the fr locale and used in one or more templates. If you delete the message Symfony is great from your translation file for the fr locale and run the command, you will get: $ php bin/console debug:translation fr --------- ------------------ ---------------------- ------------------------------- State Id Message Preview (fr) Fallback Message Preview (en) --------- ------------------ ---------------------- ------------------------------- missing Symfony is great Symfony is great Symfony is great --------- ------------------ ---------------------- ------------------------------- The state indicates the message is missing because it is not translated in the fr locale but it is still used in the template. Moreover, the message in the fr locale equals to the message in the en locale. This is a special case because the untranslated message id equals its translation in the en locale. If you copy the content of the translation file in the en locale to the translation file in the fr locale and run the command, you will get: $ php bin/console debug:translation fr ---------- ------------------ ---------------------- ------------------------------- State Id Message Preview (fr) Fallback Message Preview (en) ---------- ------------------ ---------------------- ------------------------------- fallback Symfony is great Symfony is great Symfony is great ---------- ------------------ ---------------------- ------------------------------- You can see that the translations of the message are identical in the fr and en locales which means this message was probably copied from English to French and maybe you forgot to translate it. By default, all domains are inspected, but it is possible to specify a single domain: $ php bin/console debug:translation en --domain=messages When the application has a lot of messages, it is useful to display only the unused or only the missing messages, by using the --only-unused or --only-missing options: $ php bin/console debug:translation en --only-unused $ php bin/console debug:translation en --only-missing Debug Command Exit Codes The exit code of the debug:translation command changes depending on the status of the translations. Use the following public constants to check it:: use Symfony\\Bundle\\FrameworkBundle\\Command\\TranslationDebugCommand; // generic failure (e.g. there are no translations) TranslationDebugCommand::EXIT_CODE_GENERAL_ERROR; // there are missing translations TranslationDebugCommand::EXIT_CODE_MISSING; // there are unused translations TranslationDebugCommand::EXIT_CODE_UNUSED; // some translations are using the fallback translation TranslationDebugCommand::EXIT_CODE_FALLBACK; These constants are defined as \"bit masks\", so you can combine them as follows:: if (TranslationDebugCommand::EXIT_CODE_MISSING | TranslationDebugCommand::EXIT_CODE_UNUSED) { // ... there are missing and/or unused translations } How to Find Errors in Translation Files Symfony processes all the application translation files as part of the process that compiles the application code before executing it. If there's an error in any translation file, you'll see an error message explaining the problem. If you prefer, you can also validate the syntax of any YAML and XLIFF translation file using the lint:yaml and lint:xliff commands: # lint a single file $ php bin/console lint:yaml translations/messages.en.yaml $ php bin/console lint:xliff translations/messages.en.xlf # lint", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_14", "source": "translation.rst", "text": "combine them as follows:: if (TranslationDebugCommand::EXIT_CODE_MISSING | TranslationDebugCommand::EXIT_CODE_UNUSED) { // ... there are missing and/or unused translations } How to Find Errors in Translation Files Symfony processes all the application translation files as part of the process that compiles the application code before executing it. If there's an error in any translation file, you'll see an error message explaining the problem. If you prefer, you can also validate the syntax of any YAML and XLIFF translation file using the lint:yaml and lint:xliff commands: # lint a single file $ php bin/console lint:yaml translations/messages.en.yaml $ php bin/console lint:xliff translations/messages.en.xlf # lint a whole directory $ php bin/console lint:yaml translations $ php bin/console lint:xliff translations # lint multiple files or directories $ php bin/console lint:yaml translations path/to/trans $ php bin/console lint:xliff translations/messages.en.xlf translations/messages.es.xlf The linter results can be exported to JSON using the --format option: $ php bin/console lint:yaml translations/ --format=json $ php bin/console lint:xliff translations/ --format=json When running these linters inside `GitHub Actions`_, the output is automatically adapted to the format required by GitHub, but you can force that format too: $ php bin/console lint:yaml translations/ --format=github $ php bin/console lint:xliff translations/ --format=github The Yaml component provides a stand-alone yaml-lint binary allowing you to lint YAML files without having to create a console application: $ php vendor/bin/yaml-lint translations/ The lint:yaml and lint:xliff commands validate the YAML and XML syntax of the translation files, but not their contents. Use the following command to check that the translation contents are also correct: # checks the contents of all the translation catalogues in all locales $ php bin/console lint:translations # checks the contents of the translation catalogues for Italian (it) and Japanese (ja) locales $ php bin/console lint:translations --locale=it --locale=ja The lint:translations command was introduced in Symfony 7.2. Pseudo-localization translator The pseudolocalization translator is meant to be used for development only. The following image shows a typical menu on a webpage: :alt: A menu showing multiple items nicely aligned next to eachother. This other image shows the same menu when the user switches the language to Spanish. Unexpectedly, some text is cut and other contents are so long that they overflow and you can't see them: :alt: In Spanish, some menu items contain more letters which result in them being cut. These kind of errors are very common, because different languages can be longer or shorter than the original application language. Another common issue is to only check if the application works when using basic accented letters, instead of checking for more complex characters such as the ones found in Polish, Czech, etc. These problems can be solved with `pseudolocalization`_, a software testing method used for testing internationalization. In this method, instead of translating the text of the software into a foreign language, the textual elements of an application are replaced with an altered version of the original language. For example, Account Settings is *translated* as [!!! Àççôûñţ Šéţţîñĝš !!!]. First, the original text is expanded in length with characters like [!!! !!!] to", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_15", "source": "translation.rst", "text": "is to only check if the application works when using basic accented letters, instead of checking for more complex characters such as the ones found in Polish, Czech, etc. These problems can be solved with `pseudolocalization`_, a software testing method used for testing internationalization. In this method, instead of translating the text of the software into a foreign language, the textual elements of an application are replaced with an altered version of the original language. For example, Account Settings is *translated* as [!!! Àççôûñţ Šéţţîñĝš !!!]. First, the original text is expanded in length with characters like [!!! !!!] to test the application when using languages more verbose than the original one. This solves the first problem. In addition, the original characters are replaced by similar but accented characters. This makes the text highly readable, while allowing to test the application with all kinds of accented and special characters. This solves the second problem. Full support for pseudolocalization was added to help you debug internationalization issues in your applications. You can enable and configure it in the translator configuration: # config/packages/translation.yaml framework: translator: pseudo_localization: # replace characters by their accented version accents: true # wrap strings with brackets brackets: true # controls how many extra characters are added to make text longer expansion_factor: 1.4 # maintain the original HTML tags of the translated contents parse_html: true # also translate the contents of these HTML attributes localizable_html_attributes: ['title'] <!-- config/packages/translation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"> <framework:config> <framework:translator> <!-- accents: replace characters by their accented version --> <!-- brackets: wrap strings with brackets --> <!-- expansion_factor: controls how many extra characters are added to make text longer --> <!-- parse_html: maintain the original HTML tags of the translated contents --> <framework:pseudo-localization accents=\"true\" brackets=\"true\" expansion_factor=\"1.4\" parse_html=\"true\" > <!-- also translate the contents of these HTML attributes --> <framework:localizable-html-attribute>title</framework:localizable-html-attribute> </framework:pseudo-localization> </framework:translator> </framework:config> </container> // config/packages/translation.php use Symfony\\Config\\FrameworkConfig; return static function (FrameworkConfig $framework) { // ... $framework ->translator() ->pseudoLocalization() // replace characters by their accented version ->accents(true) // wrap strings with brackets ->brackets(true) // controls how many extra characters are added to make text longer ->expansionFactor(1.4) // maintain the original HTML tags of the translated contents ->parseHtml(true) // also translate the contents of these HTML attributes ->localizableHtmlAttributes(['title']) ; }; That's all. The application will now start displaying those strange, but readable, contents to help you internationalize it. See for example the difference in the `Symfony Demo`_ application. This is the original page: :alt: The Symfony demo login page. :class: with-browser And this is the same page with pseudolocalization enabled: :alt: The Symfony demo login page with pseudolocalization. :class: with-browser Summary With the Symfony Translation component, creating an internationalized application no longer needs to be a painful process and boils down to these steps: * Abstract messages in your application by wrapping each in the Symfony\\\\Component\\\\Translation\\\\Translator::trans method; * Translate each message into multiple locales by creating translation message files. Symfony discovers and processes each file because its name", "title": "Translations", "category": "translation"}
{"chunk_id": "translation.rst_fixed_16", "source": "translation.rst", "text": "See for example the difference in the `Symfony Demo`_ application. This is the original page: :alt: The Symfony demo login page. :class: with-browser And this is the same page with pseudolocalization enabled: :alt: The Symfony demo login page with pseudolocalization. :class: with-browser Summary With the Symfony Translation component, creating an internationalized application no longer needs to be a painful process and boils down to these steps: * Abstract messages in your application by wrapping each in the Symfony\\\\Component\\\\Translation\\\\Translator::trans method; * Translate each message into multiple locales by creating translation message files. Symfony discovers and processes each file because its name follows a specific convention; * Manage the user's locale, which is stored on the request, but can also be set on the user's session. Learn more :maxdepth: 1 reference/formats/message_format reference/formats/xliff", "title": "Translations", "category": "translation"}
{"chunk_id": "validation.rst_fixed_0", "source": "validation.rst", "text": "Validation Validation is a very common task in web applications. Data entered in forms needs to be validated. Data also needs to be validated before it is written into a database or passed to a web service. Symfony provides a `Validator`_ component to handle this for you. This component is based on the `JSR303 Bean Validation specification`_. Installation In applications using Symfony Flex , run this command to install the validator before using it: $ composer require symfony/validator If your application doesn't use Symfony Flex, you might need to do some manual configuration to enable validation. Check out the Validation configuration reference . The Basics of Validation The best way to understand validation is to see it in action. To start, suppose you've created a plain-old-PHP object that you need to use somewhere in your application:: // src/Entity/Author.php namespace App\\Entity; class Author { private string $name; } So far, this is an ordinary class that serves some purpose inside your application. The goal of validation is to tell you if the data of an object is valid. For this to work, you'll configure a list of rules (called constraints ) that the object must follow in order to be valid. These rules are usually defined using PHP code or attributes but they can also be defined as .yaml or .xml files inside the config/validator/ directory: For example, to indicate that the $name property must not be empty, add the following: // src/Entity/Author.php namespace App\\Entity; // ... use Symfony\\Component\\Validator\\Constraints as Assert; class Author { #[Assert\\NotBlank] private string $name; } # config/validator/validation.yaml App\\Entity\\Author: properties: name: - NotBlank: ~ <!-- config/validator/validation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Author\"> <property name=\"name\"> <constraint name=\"NotBlank\"/> </property> </class> </constraint-mapping> // src/Entity/Author.php namespace App\\Entity; // ... use Symfony\\Component\\Validator\\Constraints\\NotBlank; use Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Author { private string $name; public static function loadValidatorMetadata(ClassMetadata $metadata): void { $metadata->addPropertyConstraint('name', new NotBlank()); } } Adding this configuration by itself does not yet guarantee that the value will not be blank; you can still set it to a blank value if you want. To actually guarantee that the value adheres to the constraint, the object must be passed to the validator service to be checked. Symfony's validator uses PHP reflection, as well as *\"getter\"* methods, to get the value of any property, so they can be public, private or protected (see validator-constraint-targets). Using the Validator Service Next, to actually validate an Author object, use the validate() method on the validator service (which implements Symfony\\\\Component\\\\Validator\\\\Validator\\\\ValidatorInterface). The job of the validator is to read the constraints (i.e. rules) of a class and verify if the data on the object satisfies those constraints. If validation fails, a non-empty list of errors (Symfony\\\\Component\\\\Validator\\\\ConstraintViolationList class) is returned. Take this simple example from inside a controller:: // ... use App\\Entity\\Author; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Validator\\Validator\\ValidatorInterface; // ... public function author(ValidatorInterface $validator): Response { $author = new Author(); // ... do something to the $author object $errors = $validator->validate($author); if (count($errors) > 0) { /* * Uses a", "title": "Validation", "category": "validation"}
{"chunk_id": "validation.rst_fixed_1", "source": "validation.rst", "text": "an Author object, use the validate() method on the validator service (which implements Symfony\\\\Component\\\\Validator\\\\Validator\\\\ValidatorInterface). The job of the validator is to read the constraints (i.e. rules) of a class and verify if the data on the object satisfies those constraints. If validation fails, a non-empty list of errors (Symfony\\\\Component\\\\Validator\\\\ConstraintViolationList class) is returned. Take this simple example from inside a controller:: // ... use App\\Entity\\Author; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Validator\\Validator\\ValidatorInterface; // ... public function author(ValidatorInterface $validator): Response { $author = new Author(); // ... do something to the $author object $errors = $validator->validate($author); if (count($errors) > 0) { /* * Uses a __toString method on the $errors variable which is a * ConstraintViolationList object. This gives us a nice string * for debugging. */ $errorsString = (string) $errors; return new Response($errorsString); } return new Response('The author is valid! Yes!'); } If the $name property is empty, you will see the following error message: Object(App\\Entity\\Author).name: This value should not be blank. If you insert a value into the name property, the happy success message will appear. Most of the time, you won't interact directly with the validator service or need to worry about printing out the errors. Most of the time, you'll use validation indirectly when handling submitted form data. For more information, see how to validate Symfony forms . You could also pass the collection of errors into a template:: if (count($errors) > 0) { return $this->render('author/validation.html.twig', [ 'errors' => $errors, ]); } Inside the template, you can output the list of errors exactly as needed: {# templates/author/validation.html.twig #} <h3>The author has the following errors</h3> <ul> {% for error in errors %} <li>{{ error.message }}</li> {% endfor %} </ul> Each validation error (called a \"constraint violation\"), is represented by a Symfony\\\\Component\\\\Validator\\\\ConstraintViolation object. This object allows you, among other things, to get the constraint that caused this violation thanks to the ConstraintViolation::getConstraint() method. Validation Callables The Validation also allows you to create a closure to validate values against a set of constraints (useful for example when validating Console command answers or when validating OptionsResolver values ): Symfony\\\\Component\\\\Validator\\\\Validation::createCallable This returns a closure that throws ValidationFailedException when the constraints aren't matched. Symfony\\\\Component\\\\Validator\\\\Validation::createIsValidCallable This returns a closure that returns false when the constraints aren't matched. Constraints The validator is designed to validate objects against *constraints* (i.e. rules). In order to validate an object, simply map one or more constraints to its class and then pass it to the validator service. Behind the scenes, a constraint is simply a PHP object that makes an assertive statement. In real life, a constraint could be: 'The cake must not be burned'. In Symfony, constraints are similar: they are assertions that a condition is true. Given a value, a constraint will tell you if that value adheres to the rules of the constraint. Supported Constraints Symfony packages many of the most commonly-needed constraints: You can also create your own custom constraints. This topic is covered in the /validation/custom_constraint article. Constraint Configuration Some constraints, like NotBlank , are simple whereas others,", "title": "Validation", "category": "validation"}
{"chunk_id": "validation.rst_fixed_2", "source": "validation.rst", "text": "to the validator service. Behind the scenes, a constraint is simply a PHP object that makes an assertive statement. In real life, a constraint could be: 'The cake must not be burned'. In Symfony, constraints are similar: they are assertions that a condition is true. Given a value, a constraint will tell you if that value adheres to the rules of the constraint. Supported Constraints Symfony packages many of the most commonly-needed constraints: You can also create your own custom constraints. This topic is covered in the /validation/custom_constraint article. Constraint Configuration Some constraints, like NotBlank , are simple whereas others, like the Choice constraint, have several configuration options available. Suppose that the Author class has another property called genre that defines the literature genre mostly associated with the author, which can be set to either \"fiction\" or \"non-fiction\": // src/Entity/Author.php namespace App\\Entity; // ... use Symfony\\Component\\Validator\\Constraints as Assert; class Author { #[Assert\\Choice( choices: ['fiction', 'non-fiction'], message: 'Choose a valid genre.', )] private string $genre; // ... } # config/validator/validation.yaml App\\Entity\\Author: properties: genre: - Choice: { choices: [fiction, non-fiction], message: Choose a valid genre. } # ... <!-- config/validator/validation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Author\"> <property name=\"genre\"> <constraint name=\"Choice\"> <option name=\"choices\"> <value>fiction</value> <value>non-fiction</value> </option> <option name=\"message\">Choose a valid genre.</option> </constraint> </property> <!-- ... --> </class> </constraint-mapping> // src/Entity/Author.php namespace App\\Entity; // ... use Symfony\\Component\\Validator\\Constraints as Assert; use Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Author { private string $genre; // ... public static function loadValidatorMetadata(ClassMetadata $metadata): void { // ... $metadata->addPropertyConstraint('genre', new Assert\\Choice( choices: ['fiction', 'non-fiction'], message: 'Choose a valid genre.', )); } } Constraints in Form Classes Constraints can be defined while building the form via the constraints option of the form fields:: public function buildForm(FormBuilderInterface $builder, array $options): void { $builder ->add('myField', TextType::class, [ 'required' => true, 'constraints' => [new Length(['min' => 3])], ]) ; } Constraint Targets Constraints can be applied to a class property (e.g. name), a getter method (e.g. getFullName()) or an entire class. Property constraints are the most common and easy to use. Getter constraints allow you to specify more complex validation rules. Finally, class constraints are intended for scenarios where you want to validate a class as a whole. Properties Validating class properties is the most basic validation technique. Symfony allows you to validate private, protected or public properties. The next listing shows you how to configure the $firstName property of an Author class to have at least 3 characters. // src/Entity/Author.php // ... use Symfony\\Component\\Validator\\Constraints as Assert; class Author { #[Assert\\NotBlank] #[Assert\\Length(min: 3)] private string $firstName; } # config/validator/validation.yaml App\\Entity\\Author: properties: firstName: - NotBlank: ~ - Length: min: 3 <!-- config/validator/validation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Author\"> <property name=\"firstName\"> <constraint name=\"NotBlank\"/> <constraint name=\"Length\"> <option name=\"min\">3</option> </constraint> </property> </class> </constraint-mapping> // src/Entity/Author.php namespace App\\Entity; // ... use Symfony\\Component\\Validator\\Constraints as Assert; use Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Author { private string $firstName; public static function loadValidatorMetadata(ClassMetadata $metadata): void { $metadata->addPropertyConstraint('firstName', new Assert\\NotBlank()); $metadata->addPropertyConstraint( 'firstName', new Assert\\Length(min: 3) ); } } The", "title": "Validation", "category": "validation"}
{"chunk_id": "validation.rst_fixed_3", "source": "validation.rst", "text": "class to have at least 3 characters. // src/Entity/Author.php // ... use Symfony\\Component\\Validator\\Constraints as Assert; class Author { #[Assert\\NotBlank] #[Assert\\Length(min: 3)] private string $firstName; } # config/validator/validation.yaml App\\Entity\\Author: properties: firstName: - NotBlank: ~ - Length: min: 3 <!-- config/validator/validation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Author\"> <property name=\"firstName\"> <constraint name=\"NotBlank\"/> <constraint name=\"Length\"> <option name=\"min\">3</option> </constraint> </property> </class> </constraint-mapping> // src/Entity/Author.php namespace App\\Entity; // ... use Symfony\\Component\\Validator\\Constraints as Assert; use Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Author { private string $firstName; public static function loadValidatorMetadata(ClassMetadata $metadata): void { $metadata->addPropertyConstraint('firstName', new Assert\\NotBlank()); $metadata->addPropertyConstraint( 'firstName', new Assert\\Length(min: 3) ); } } The validator will use a value null if a typed property is uninitialized. This can cause unexpected behavior if the property holds a value when initialized. In order to avoid this, make sure all properties are initialized before validating them. Getters Constraints can also be applied to the return value of a method. Symfony allows you to add a constraint to any private, protected or public method whose name starts with \"get\", \"is\" or \"has\". In this guide, these types of methods are referred to as \"getters\". The benefit of this technique is that it allows you to validate your object dynamically. For example, suppose you want to make sure that a password field doesn't match the first name of the user (for security reasons). You can do this by creating an isPasswordSafe() method, and then asserting that this method must return true: // src/Entity/Author.php namespace App\\Entity; // ... use Symfony\\Component\\Validator\\Constraints as Assert; class Author { #[Assert\\IsTrue(message: 'The password cannot match your first name')] public function isPasswordSafe(): bool { // ... return true or false } } # config/validator/validation.yaml App\\Entity\\Author: getters: passwordSafe: - 'IsTrue': { message: 'The password cannot match your first name' } <!-- config/validator/validation.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\"> <class name=\"App\\Entity\\Author\"> <getter property=\"passwordSafe\"> <constraint name=\"IsTrue\"> <option name=\"message\">The password cannot match your first name</option> </constraint> </getter> </class> </constraint-mapping> // src/Entity/Author.php namespace App\\Entity; // ... use Symfony\\Component\\Validator\\Constraints as Assert; use Symfony\\Component\\Validator\\Mapping\\ClassMetadata; class Author { public static function loadValidatorMetadata(ClassMetadata $metadata): void { $metadata->addGetterConstraint('passwordSafe', new Assert\\IsTrue( message: 'The password cannot match your first name', )); } } Now, create the isPasswordSafe() method and include the logic you need:: public function isPasswordSafe(): bool { return $this->firstName !== $this->password; } The keen-eyed among you will have noticed that the prefix of the getter (\"get\", \"is\" or \"has\") is omitted in the mappings for the YAML, XML and PHP formats. This allows you to move the constraint to a property with the same name later (or vice versa) without changing your validation logic. Classes Some constraints apply to the entire class being validated. For example, the Callback constraint is a generic constraint that's applied to the class itself. When that class is validated, methods specified by that constraint are simply executed so that each can provide more custom validation. Validating Object With Inheritance When you validate an object that extends another class, the validator automatically validates constraints defined in the parent", "title": "Validation", "category": "validation"}
{"chunk_id": "validation.rst_fixed_4", "source": "validation.rst", "text": "the mappings for the YAML, XML and PHP formats. This allows you to move the constraint to a property with the same name later (or vice versa) without changing your validation logic. Classes Some constraints apply to the entire class being validated. For example, the Callback constraint is a generic constraint that's applied to the class itself. When that class is validated, methods specified by that constraint are simply executed so that each can provide more custom validation. Validating Object With Inheritance When you validate an object that extends another class, the validator automatically validates constraints defined in the parent class as well. **The constraints defined in the parent properties will be applied to the child properties even if the child properties override those constraints**. Symfony will always merge the parent constraints for each property. You can't change this behavior, but you can overcome it by defining the parent and the child constraints in different validation groups and then select the appropriate group when validating each object. Debugging the Constraints Use the debug:validator command to list the validation constraints of a given class: $ php bin/console debug:validator 'App\\Entity\\SomeClass' App\\Entity\\SomeClass | Property | Name | Groups | Options | | firstArgument | Symfony\\Component\\Validator\\Constraints\\NotBlank | Default | [ | | | | | \"message\" => \"This value should not be blank.\", | | | | | \"allowNull\" => false, | | | | | \"normalizer\" => null, | | | | | \"payload\" => null | | | | | ] | | firstArgument | Symfony\\Component\\Validator\\Constraints\\Email | Default | [ | | | | | \"message\" => \"This value is not a valid email address.\", | | | | | \"mode\" => null, | | | | | \"normalizer\" => null, | | | | | \"payload\" => null | | | | | ] | You can also validate all the classes stored in a given directory: $ php bin/console debug:validator src/Entity Final Thoughts The Symfony validator is a powerful tool that can be leveraged to guarantee that the data of any object is \"valid\". The power behind validation lies in \"constraints\", which are rules that you can apply to properties or getter methods of your object. And while you'll most commonly use the validation framework indirectly when using forms, remember that it can be used anywhere to validate any object. Learn more :maxdepth: 1 :glob: /validation/*", "title": "Validation", "category": "validation"}
